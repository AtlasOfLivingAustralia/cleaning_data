---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Taxonomy

<!-- Andrew: The distinction between taxonomy page here, and the taxonomy validation page, is that this page (taxonomy or whatever better name), is about treating the values as if they were any other data type, its just that they happen to be taxonomic and we are cleaning *our dataset* based on that attribute. It's not about cleaning taxnomic issues, its just cleaning data that falls within the category of taxonomy. The content here on this page so far hopefully will make that clearer - for example, filtering based on X, its like you would filter any other data type, or spatial records filtering based on distance and so on. Checking against extinct species, filtering based on life stage etc.
Taxonomic validation on the other hand (not sure on the name), should be about cleaning the actual specific values, and the cleaning *relates to the taxonomy itself*. Is the species name formatted correctly, do you have a naming issues, synynoms, checking upstream and validating etc.  -->
<!-- Where I was up to is that the taxnomy_validation page is mostly unchanged (previously taxonomy.qmd). But after looking through, there is probably some content that can be better placed in the new chapters, such as in strings (there is a bunch of string stuff there that is already covered in other sections, or if not can be moved to the strings section and hyperlinked, i dont think it needs to be with taxonomy), or here (if it meets the domain of this page), and then it can stand alone based on the scope i described above -->

```{r, setup, include=FALSE}
knitr::opts_chunk$set(
  comment = "",
  fig.width = 6,
  fig.height = 6,
  eval = TRUE,
  echo = TRUE,
  warning = FALSE,
  message = FALSE
)
options(tidyverse.quiet = TRUE)
```

Here we discuss techniques that directly pertain to taxonomic data fields. This
includes dealing with taxonomic synonyms, missing taxonomic information, as well
as checks for filting potentially unwanted records (invasive, extinct, etc.) 

## Missing data

One issue you might face is that higher taxonomy from different providers may
not match. If this is the case, we suggest choosing the data provider with the
higher taxonomy that is consistent with your naming authority and use it to back
fill the higher taxonomy of the other data sources

```{r}
# higher_taxonomy <- inverts %>%
#   select(scientificName) %>%
#   distinct() %>%
#   search_taxa()

# higher_taxonomy
```

## Filtering out taxa

Depending on your project's data scope, it may be necessary to remove certain
groups of taxa. Here we present a few use cases, based on some commonly required
criteria. This type of taxonomic filtering is particularly useful for large,
multi-species datasets. 

### Introduced or invasive species

If your project requires only native species, we can filter out those records
using lists available online. Here we are using the list for Australia from the
[Global Register of Introduced and Invasive Species
(GRIIS)](https://griis.org/download). After downloading this list, we read it
into R, and exclude invasive species from our example dataset:

```{r}
library(dplyr)
plants <- arrow::open_dataset("../data/dap/plants_subset") |> dplyr::collect()
griis_ls <- read.csv("../data/lists/GRIIS_Australia_20230331-121730.csv")
glimpse(griis_ls)

# Check which species matched the GRIIS list
matches <- filter(plants, scientific_name %in% griis_ls$accepted_name.species)

# If you are happy with the matches, you can proceed to remove any records
# that were matched
plants_no_griis <- filter(plants, !scientific_name %in% matches)
```

::: {.callout-tip}
You can apply this concept of filtering to any list of species, or other fields, that you would like to exclude (or include, by removing the `!` in the `filter()` step)
:::

### Extinct species 

In most cases, a year filter applied during your download query should remove
_most_ extinct species. Nevertheless, it is important to cross check for extinct
species. We can do this using the Interim Register of Marine and Nonmarine
Genera [(IRMNG)](https://www.irmng.org/). The list is comprehensive and actively
maintained. However, much of the data doesn't go down to species level. As such,
we recommend using the following approach to find _potentially extinct_ taxa and
further investigate the records that are flagged.

The required files are organised by year and can be downloaded from
[here](https://www.irmng.org/export/), and unzipped to your project directory.
Below we process the downloaded files and then check for matches in our dataset.

```{r}
irmng_taxa <- arrow::open_dataset("../data/lists/IRMNG_genera_DwCA_2023-05-19/taxon_subset") |>
  collect()

irmng_sp <- arrow::open_dataset("../data/lists/IRMNG_genera_DwCA_2023-05-19/speciesprofile") |>
  collect()
```

<!-- Notes/Andrew: This chunk below will need some explaining, I didn't look
into it but there is a few things happening but the comments dont give enough
context or logic -->

```{r}
library("stringr")
inverts <- arrow::open_dataset("../data/galah/inverts") |> dplyr::collect()

awc_pattern <- "(awaiting allocation)"
insed_pattern <- "incertae sedis"

cleaned_irmng_taxa <- irmng_taxa |>
  mutate(
    class = ifelse(str_detect(class, pattern = paste0(awc_pattern, "|", insed_pattern)),
      word(class), class
    )
  ) |>
  filter(taxonomicStatus == "accepted") |> # Filter to accepted names
  filter(
    kingdom %in% c("Animalia", "Plantae"),
    !kingdom == "Questionable / non-biota (fossil)"
  ) # Filter to Animal and plants - change if working with other kingdoms

# Join with species profile, remove pesky values and filter to extinct taxa
extinct_irmng <- irmng_taxa |>
  left_join(irmng_sp, by = "taxonID") |>
  filter(!scientificName == "Questionable / non-biota (fossil)") |>
  filter(isExtinct == TRUE)

# Summary of extinct species by taxonRank
extinct_irmng$taxonRank |> janitor::tabyl()

# Create genus
inverts_2 <- inverts |>
  mutate(genus = word(scientificName, 1))

# Extract unique extinct genus and remove genus that have punctuation in them
extinct_genus <- extinct_irmng |>
  tidyr::drop_na(genus) |>
  filter(!str_detect(genus, pattern = regex("[:punct:]"))) |>
  pull(genus) |>
  unique()

# Check if there are any matches at genus level
check <- inverts_2 |>
  filter(str_detect(genus, pattern = regex(paste0(extinct_genus, collapse = "|")))) |>
  pull(scientificName) |>
  unique()

print(check)
```

Alternatively, we can use the IUCN to retrieve a list of extinct species that
are in their database. See the [IUCN
API](https://apiv3.iucnredlist.org/api/v3/docs#species-category) for more
information on queries based on species categories. Below we will the `rredlist`
package to interface with the IUCN API. Note that you will need to register for
an API token, which can take a day or two to be approved. Then we use the
`rl_sp_category("EX")` to return extinct species, to check against our dataset. 

<!-- Andrew/Notes: Leaving eval = false because I tried to query for a token and got a 403 error. -->

```{r, eval = FALSE}
# Create IUCN token
rredlist::rl_use_iucn() # Application can take a day or two!
usethis::edit_r_environ() # Place the approved token in your R environment

extinct_iucn <- rredlist::rl_sp_category("EX")
skimr::skim(extinct_iucn)

# Note these are extinct species across the globe
extinct_sp <- tibble(extinct_iucn$result)

# Find matches
filter(inverts, scientificName %in% extinct_sp$scientific_name) # No matches
```

### Biological attributes and life cycle stages

In some cases, you may want to filter out records based on attributes such as
sex or life cycle stage, if this metadata is available for your records. In the
example below, we download a dataset, including the extra metadata fields
needed. We then examine the fields we want to filter by, to see what values are
available and how many records are missing values.

```{r, eval=TRUE}
library(galah)

galah_config(
  email = Sys.getenv("ALA_EMAIL"),
  atlas = "Australia"
)

bilby <- galah_call() |>
  galah_identify("Macrotis lagotis") |>
  galah_filter(year == 2022) |>
  galah_select(group = "basic", sex, lifeStage, reproductiveCondition) |>
  atlas_occurrences()

# Quick way to check the unique values for each field
lapply(bilby[c("sex", "lifeStage", "reproductiveCondition")], unique)
```

The check above shows that the `lifeStage` field has only NA values, so we won't
be able to use it. The other two fields have values so it's worth checking them
out in more detail using `skimr::skim()` For this example we will focus on the
`sex` field.

```{r}
# Skim without charts for a more compact output, making sure sex is treated as a factor
bilby$sex <- factor(bilby$sex)
skimr::skim_without_charts(bilby, sex) |>
  skimr::yank("factor")
```

The dataset is mostly NA values for the `sex` field, but say that our project is
focused only on female greater bilbies, now we can do our simple filter using
`==` as shown below. 
```{r}
head(filter(bilby, sex == "FEMALE"), 3)
```

We could also use `!= "MALE` to get the same result, since we only have two
factor levels, and `dplyr::filter()` drops NA values. Be aware that if filtering
with base R subsetting, the same approach would drop male rows but keep both
female and NA rows.

```{r}
nrow(filter(bilby, sex != "MALE"))
nrow(filter(bilby[bilby$sex != "MALE", ]))
```

### Ecosystems

Filtering by ecosystem, such as removing terrestrial records or aquatic records,
can be necessary depending on the project. Below we demonstrate an example of
filtering against the [World Register of Marine Species
(WoRMS)](https://www.marinespecies.org/), to remove marine invertebrates from
our dataset. Note that you could apply this approach to any other ecosystem by
using an appropriate list of species. 

<!-- Andrew/Notes: This is worth double checking, I only quickly checked this
and fixed the second half because it wasn't actually filtering anything even
though all but 1 of the species were marine. But this is just as far as I could
understand; I don't know the dataset or anything so its not clear to me if
what's happening is ok or not. --> 
<!-- Also - It was written up and coded with
the goal stated as removing marine species, if interested in terrestrial. But
this doesn't make sense, the inverts data is all marine but one species? Either
I'm completely misunderstanding or this was a misunderstanding at some point. As
I'm writing this I realised that if this was a mix up, the fix is really easy -
just change the wording to removing non-marine species, and changing the filter.
Makes a lot more sense -->
<!-- Side note - the only species that doesn't get filtered has NA or invalid
number as the value. not an actual value for confidence in not marine -->
```{r}
# Obtain species list
my_species <- inverts |>
  pull(scientificName) |>
  unique()

# Query WoRMs
marine_check <- purrr::map_dfr(
  my_species,
  purrr::possibly(~ worrms::wm_records_name(name = .x) |>
    mutate(search_term = .x))
)
# Filter species that are TRUE for isMarine
marine_inverts <- marine_check |>
  filter(isMarine == TRUE)

# Exclude marine invertebrates
filter(inverts, !scientificName %in% marine_inverts$search_term)
```

After filtering we are left with only four records of one species. It's always
worth double checking the results of your filtering, to make sure any species
excluded or included are as expected. 


---
editor: 
  markdown: 
    wrap: 72
---

# Missing values

Missing values are a nuisance in datasets, especially when using R. Missing values can unintentionally skew results if they remain unknown because quite often missing values are ignored when running visualisations or analyses. When function don't ignore missing values, however, they often prevent the function from running at all. So it's in everyone's best interest to either remove or at least be aware of the missing values in your dataset.

This chapter will show how to detect and remove missing values.

### Prerequisites

In this chapter, we will use gecko occurrence data since 2009 from the ALA. 

```{r prereq}
#| message: false
#| warning: false
#| echo: false
library(galah)
library(dplyr)
galah_config(email = Sys.getenv("ALA_EMAIL"),
             verbose = FALSE)
geckos <- galah_call() |>
  identify("Gekkonidae") |>
  filter(year >= 2009) |>
  select(group = "basic",
         kingdom, phylum, order, class, 
         family, genus, species, cl22, 
         eventDate, month) |>
  atlas_occurrences()
```

```{r}
#| eval: false
# packages
library(galah)
library(dplyr)

# data: Gecko records since 2009
galah_config(email = "your-email-here") # ALA Registered email

geckos <- galah_call() |>
  identify("Gekkonidae") |>
  filter(year >= 2009) |>
  select(group = "basic",
         kingdom, phylum, order, class, 
         family, genus, species, cl22, 
         eventDate, month) |>
  atlas_occurrences()
```

:::{.aside}

<img class = "rounded" src="https://ala-images.s3.ap-southeast-2.amazonaws.com/store/8/7/9/8/89ad2446-e89c-481c-97d7-375ffad18978/original"></img>

::: {.figure-caption}
[*Heteronotia binoei* camouflaged over rocks, sticks & leaves.<br>Photo by Reiner Richter CC-BY-NC 4.0
(Int)](https://biocache.ala.org.au/occurrences/b0085bb1-72b9-4a4d-8dbf-05174b85c973)
:::
:::

## Find missing values

One of the fastest and simplest ways to find where there are missing values in your data is using the skimr package to show which columns have missing values and how many there are.

```{r}
#| warning: false
#| message: false
library(skimr)

geckos |>
  skim() |>
  filter(n_missing > 0) |> 
  as_tibble()
```

The output shows that there are 7 columns with missing values, shown in `skim_variable`, along with information about the number of missing values in `n_missing` and the proportion of non-missing values in `complete_rate`.

Next we can return all rows with a missing variable.

```{r}
geckos |> 
  filter(if_any(everything(), is.na)) |>
  select(scientificName, genus, 
         species, cl22, everything()) # reorder columns
```

Or we can specify the column (in this case column `cl22`).

```{r}
geckos |> 
  filter(if_any(cl22, is.na)) |> 
  select(scientificName, genus, 
         species, cl22, everything()) # reorder columns
```


## Remove `NA` values

### Missing coordinates

If you are intending to make any maps or run any spatial analyses, it's a good idea to
exclude records with missing coordinates. Missing coordinate data often leads to one of the following: a function error, an undesirable map, or the (unintentional) exclusion of data points (many of which you might wish to include in other maps or analyses). 

It's good practice to tally and identify rows that have missing data before excluding them. We can use the same method as above to identify the records with missing coordinates.

```{r}
geckos |> 
  filter(if_any(c(decimalLongitude, decimalLatitude), is.na)) |>
  count()

geckos |> 
  filter(if_any(c(decimalLongitude, decimalLatitude), is.na)) |>
  select(scientificName, decimalLongitude, 
         decimalLatitude, everything()) # reorder columns
```

If we decide we are happy to exclude these records, we can use `drop_na()` to remove missing values from our dataset. 

```{r}
#| message: false
#| warning: false
library(tidyr)

geckos_filtered <- geckos |>
  drop_na(decimalLongitude, decimalLatitude)
```

We can check that `drop_na()` worked correctly by comparing the number of records in our initial data and our filtered data, specifically that `geckos_filtered` is smaller by the same number of `NA` values we found above.

```{r}
nrow(geckos) - nrow(geckos_filtered)
```

## Taxonomic values

### Missing higher rank

Sometimes data can be missing information in columns with higher taxonomic rankings, even if observations have been taxonomically identified down to the species level. In this case, the goal isn't only to remove the missing values, but to fill missing information with the correct information.

As an example, we'll use a slightly modified `geckos_missing` dataset with some missing data add into the higher columns[^1]. Below is a preview, and you'll notice that there are `NA` values in the `class` and `family` columns. 

[^1]: The Atlas of Living Australia matches taxonomic names when data is ingested from data providers. This process means that it's very rare for a species to be missing higher taxonomic rank names. This might not be the case for other data sources, though!


```{r geckos-missing-taxonomic-names}
#| warning: false
#| message: false
#| code-fold: true

# download older gecko data
# geckos_old <- galah_call() |>
#   identify("Gekkonidae") |>
#   filter(year > 2004 & year < 2009) |>
#   select(group = "basic",
#          kingdom, phylum, order, class, 
#          family, genus, species, cl22, 
#          eventDate, month) |>
#   atlas_occurrences()

# randomly replace class & family with NAs
set.seed(87654)

geckos_missing <- geckos |>
  mutate(class = replace(class, 
                         sample(row_number(), 
                                size = ceiling(0.15 * n())), 
                         NA),
         family = replace(family, 
                          sample(row_number(), 
                                 size = ceiling(0.15 * n())), 
                          NA))
```


```{r}
geckos_missing |>
  select(scientificName, class, family, genus, species, everything())
```

If you have a list of taxonomic names with complete ranking information from your preferred [taxonomic naming authority](link%20back%20to%20section), you can use this information to back-fill your missing data columns. In our case, we can use names from ALA's taxonomic backbone.

First we'll get the complete list of *Gekkonidae* taxonomic rank names using galah.

```{r}
geckos_species_list <- galah_call() |>
  identify("gekkonidae") |>
  atlas_species()

geckos_species_list
```

To match the complete names in `geckos_species_list` with the missing names in `geckos_missing`, we can use a strategy of match-and-merge. 

Using a reference columns, we'll merge our complete names data to our missing data. The information in the `species_name` column of `geckos_species_list` contains both the genus and species names; this is just like the `scientificName` column of our `geckos_missing` dataset[^2]. We can use these columns as our reference columns.

```{r}
geckos_species_list |> select(species_name) |> slice(10:15)
geckos_missing |> select(scientificName) |> slice(10:15)
```

Now we'll select the subset of columns from `geckos_species_list` that we wish to join with `geckos_missing` (and our reference column, `species_name`).

```{r}
list_subset <- geckos_species_list |>
  select(species, class, family)
```

We can use `left_join()` to merge `list_subset` to `geckos_missing`. Records that are identified at least down to the family level now have the correct rank information in the `class_new` and `family_new` columns [^3].

[^3]: This hasn't worked for every row, however, because `scientificName` contains the name of the lowest taxonomic rank the occurrence is identified to. Names like `Christinus` and `Gehyra` are genus names, so in these cases `scientificName` won't match our reference `species_name` column!

```{r}
geckos_missing |>
  left_join(list_subset, 
            by = join_by(scientificName == species_name), 
            suffix = c("_old", "_new")) |>
  select(scientificName, class_old, family_old, class_new, family_new) |>
  slice(20:30)
```


### Insufficient taxonomic rank

If a record is not identified down to the necessary taxonomic level required for your analysis (e.g. down to species or sub-species level), then the record should be removed.

One handy tip you can use with the galah package is to add the column [`taxonRank`](https://dwc.tdwg.org/terms/#dwc:taxonRank). This column usefully shows the taxonomic level of names in `scientificName`[^2]. `taxonRank` can be useful because we can filter to only include records down to a specific rank.

[^2]: This column contains the name of the lowest taxonomic rank the occurrence is identified to.

```{r}
#| warning: false
#| message: false
geckos_rank <- galah_call() |>
  identify("gekkonidae") |>
  filter(year == 2013) |>
  select(taxonRank, scientificName) |>
  atlas_occurrences()

geckos_rank |>
  filter(taxonRank == "species")
```

However, it is still possible to filter records using the tools above without using the `taxonRank` column. In this case we remove records not identified down to the genus. 

```{r}
geckos_filtered <- geckos |>
  drop_na(genus) |>
  select(scientificName, genus, everything()) # reorder columns
geckos_filtered
```

## Summary

This chapter showed ways to find and remove different types of missing records from your dataset.

In the next chapter...

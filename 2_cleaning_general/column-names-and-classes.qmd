---
editor_options: 
  chunk_output_type: console
---

# Column classes & names

This chapter explains how to check the class of each column and edit column names. 

Each column in a table contains data of a specific **class**. A class defines the type of data in a column, which determines how those data are interpreted in R and affects how we can modify those data. For instance, it doesn't make sense to apply a mathematical equation to a word or a sentence. The phrase "hello" doesn't reveal whether something is true or false. Knowing what *types* of data are in each column of your table will ensure those data behave as expected later on. 

Depending on the source of your dataset, the column names in a table may be uninformative (e.g. `col1`, `tga42.D`), oddly formatted once imported into R (e.g. `How.Much.Soil.Is.In.This.Plot..`), or internally inconsistent (e.g. `species_name`, `scientificName`). Modifying these can make it much easier to work with the data.


### Prerequisites

In this chapter, we will use *Litoria* frog occurrence data since 2020 in Tasmania.

```{r}
#| warning: false
#| message: false
#| echo: false
# packages
library(galah)
library(dplyr)

galah_config(email = Sys.getenv("ALA_EMAIL"),
             verbose = FALSE)
frogs <- galah_call() |>
  identify("Litoria") |>
  filter(year >= 2020, 
         cl22 == "Tasmania") |>
  select(group = "basic",
         genus, species) |>
  atlas_occurrences()
```

```{r}
#| eval: false
# packages
library(galah)
library(dplyr)

# data: frog records
galah_config(email = "your-email-here")

frogs <- galah_call() |>
  identify("Litoria") |>
  filter(year >= 2020, 
         cl22 == "Tasmania") |>
  select(group = "basic",
         genus, species) |>
  atlas_occurrences()

```

::: aside
<img src="https://ala-images.s3.ap-southeast-2.amazonaws.com/store/2/a/8/f/c3c17ed0-952c-46c5-8de2-0069ff38f8a2/original" class="rounded"/></img>

::: figure-caption
[*Litoria watjulumensis* seated on a rock.<br>Photo by simono CC-BY-NC 4.0 (Int)](https://biocache.ala.org.au/occurrences/44ed2cdd-ab7c-4974-b2fd-6a6394d5cd7b)
:::
:::

## Column classes

Columns define what type of data they contain by having a class, and it's important to know what these classes are because R handles each class differently.

Viewing your data using functions we introduced in the [Inspect chapter](LINK) allows you to get a quick overview of each column's class.

:::{.panel-tabset .nav-pills}

#### `glimpse()`

Using `glimpse()` displays the class beside each column name (e.g. <*chr*>)

```{r}
library(dplyr)

glimpse(frogs)
```

#### `str()`

Using `str()` displays the class after the column name and before the number of rows (e.g. `chr`)

```{r}
str(frogs)
```

#### `skim()`

The `skim()` function groups columns by their type/class.

```{r}
#| message: false
#| warning: false
library(skimr)

skim(frogs)
```

#### `sapply()`

You can return the class of every column using `sapply()` from base R.

```{r}
sapply(frogs, class)
```

#### `map()`

You can return the class of every column using `map()` from the purrr package.

```{r}
#| message: false
#| warning: false
library(purrr)

frogs |>
  purrr::map(class)
```

:::

If you are using a `tibble`, the class is also displayed below each column name when you view your table.

```{r}
frogs
```

From these quick overviews of the data, we've learned:

  *  Columns like `scientificName` are strings of text (type `character`)
  *  Columns like `decimalLatitude` and `decimalLongitude` are numbers with decimal points (type `double`)
  *  The `eventDate` column contains a date + time (type `POSIXct`/`dttm`)
  *  Columns like `recordID` and `taxonConceptID` contain both text and numbers, but are of type `character` because this type prevents any loss of data[^column-names-and-classes-2].

[^column-names-and-classes-2]: To avoid conflicts, R has an internal coercion hierarchy rule to avoid data loss. The rule of thumb is that if a data type can't exist in a child data type, then the parent data type is used instead. The R coercion hierarchy is:<br>  `logical` `->` `integer` `->` `numeric` `->` `complex` `->` `character`<br><br>You don't need to memorise this, but it's worth being aware of this hierarchy, as R might make decisions to prevent a class error and you might not know why! [Learn more in this article](https://annakrystalli.me/rrresearchACCE20/data-types-structures-and-classes.html).

Here, the column classes are what we'd expect given the types of data in each column. However, this is not always the case. For instance, changing just one of the values in `decimalLatitude` to a "degrees minutes seconds" format will cause the entire column's class to be changed to `character` to prevent loss of data.


```{r}
# duplicate data
frogs_class <- frogs

# check class
class(frogs_class$decimalLatitude)

# change one of the values to a degrees minutes seconds format
frogs_class$decimalLatitude[5] <- "40Â° 51' 59 N"

# check class
class(frogs_class$decimalLatitude)
```

A simple typo in the dataset you import into R could be all it takes to change the class of an entire column, so be sure to keep your eyes out for strange column classes!

## Column names

There are many reasons why you might need to change the name of one or more columns in a table. We've outlined a few of the more common use cases here. 

### Make column names consistent

Column names should use consistent naming conventions. R is case sensitive, so two names with the same letters but different capitalisations are considered different names (e.g. `event` vs. `Event`). Using a consistent naming convention, like camel case or snake case, makes it easier to avoid these errors. Common naming formats include "snake case" and "camel case", which are popular because they are both human- and machine-readable. 

**Camel case** begins in lowercase and uses uppercase for the first letter of every subsequent word (e.g. `scientificName`, `dataResourceName`, `eventDate`).  

**Snake case** uses lowercase letters only, with words separated by an underscore `_` (e.g. `scientific_name`, `data_resource_name`, `event_date`).  

Snake case is more popular in R, and is the naming convention we recommend. Data downloaded from the ALA is in camel case[^column-names-and-classes-1].

[^column-names-and-classes-1]: Queries to the ALA use other coding languages, namely `solr` and `JSON`, and column names in these languages are typically in camel case. To maintain consistency with what's in the ALA and to avoid hidden name cleaning, galah also returns names in camel case.

```{r}
colnames(frogs)
```

One of the most useful column name cleaning functions is `clean_names()` from the janitor package. This function will make all of your column names consistent, based on your preferred naming convention (defaults to snake case). 

```{r}
#| warning: false
#| message: false
library(janitor)

frogs_clean <- frogs |>
  clean_names() |>
  colnames()
frogs_clean
```

### Rename columns

Renaming columns is a frequent data cleaning task. Column names might need renaming to make it clearer what data they contain, or to make a name consistent with another dataset prior to merging their contents.

There are several ways to rename columns in R.

::: {.panel-tabset .nav-pills}
#### `rename()`

`dplyr::rename()` provides an easy way to rename one or more columns.

```{r}
frogs |>
  select(decimalLatitude, decimalLongitude) |>
  rename(latitude = decimalLatitude,
         longitude = decimalLongitude)
```

`rename_with()` is a more powerful verion of `rename()`. It allows more advanced renaming by using functions to rename matching columns.

```{r}
frogs |>
  rename_with(toupper, starts_with("decimal"))

frogs |>
  rename_with( ~ tolower(gsub("decimal", "new_", .x, fixed = TRUE)))
```

#### `names()` + `<-`

Index a specific column name in base R with the help of `names()`. Assign a new column name to replace an old column name using the assign operator `<-`.

```{r}
names(frogs)[names(frogs) == "decimalLatitude"] <- "latitude"
names(frogs)[names(frogs) == "decimalLongitude"] <- "longitude"

frogs[,c("latitude", "longitude")]
```

```{r}
#| echo: false
names(frogs)[names(frogs) == "latitude"] <- "decimaLatitude"
names(frogs)[names(frogs) == "longitude"] <- "decimalLongitude"
```

:::

### Separate columns

Sometimes it is useful to split information from one column into several columns. One good example is if genus and species names are contained in one column like `scientificName`. We can separate these names into two columns using `separate()` from the tidyr package.

```{r}
#| warning: false
#| message: false
library(tidyr)

frogs_separate <- frogs |>
  separate(scientificName, 
           c("genus", "species"), # new column names
           fill = "right",        # fill missing values in right column
           remove = FALSE         # keep input column
           ) |> 
  select(scientificName, genus, species)
frogs_separate
```

### Join columns

Conversely, we might want to combine information from multiple columns into a single column. We can rejoin the `genus` and `species` columns we created in the previous section using `unite()` from the tidyr package.

```{r}
frogs_separate |>
  unite("single_name", 
        genus:species, # select columns to join
        sep = " ",     # separate with a space
        na.rm = TRUE,  # remove NA values
        remove = FALSE # keep input column
        ) |>
  select(genus, species, single_name)
```

## Summary

In this chapter, we've explored different ways to check the class of each column in your table to make sure R is interpreting your data correctly, to change column names to make it easier to work with them, and to split or combine columns to access data more conveniently. 

In the next chapter we will learn to xxx...

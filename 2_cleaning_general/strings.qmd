---
editor: 
  markdown: 
    wrap: 72
code-annotations: hover
number-depth: 3
---

# Strings

*Strings* are sequences of characters that make up spaces, letters, abbreviations, words or sentences. They can be formatted in many different ways in an individual dataset. For example, these are just some possible ways the scientific name of species could be recorded in a dataset:  
  
  * `"Dendrolagus lumholtzi"`
  * `"dendrolagus lumholtzi"`
  * `":Dendrolagus_lumholtzi34"`
  * `"  Dendrolagus lumholtzi  "`

Terms might be capitalised (or not), have (accidental) spaces at the beginning or end of a word or sentence, possess typos or punctuation; all of these things impact your ability to consolidate and analyse data accurately.

In this chapter, we focus on general data science techniques to clean strings in a dataset.

### Prerequisites

In this chapter, we will use tree kangaroo (*Dendrolagus*) occurrence data from the ALA and a subset of bee (*Apidae*) data taken from the [Curated Plant and Invertebrate Data for Bushfire Modelling data set](https://data.csiro.au/collection/csiro:56679). Download the `bees` dataset from the [Data in this book chapter](../data-in-this-book.html).

```{r prereq-internal}
#| echo: false
#| warning: false
#| message: false
# packages
library(galah)
library(dplyr)
library(tidyverse)
library(janitor)
library(here)
library(arrow)
galah_config(email = Sys.getenv("ALA_EMAIL"),
             verbose = FALSE)

# get DOIs for chapter
doi_table <- here::here("data", "galah-dois", "doi_table") |>
  arrow::open_dataset() |>
  filter(chapter == "Strings") |>
  collect()

# extract dois
doi_tree_kangaroo <- doi_table |> filter(name == "tree_kangaroo") |> pull(doi)

# download
tree_kangaroo <- galah_call() |>
  filter(doi == doi_tree_kangaroo) |>
  atlas_occurrences()

bees <- arrow::read_parquet(here("data", "dap", "bees.parquet"))
```

```{r prereq-external}
#| echo: false
test <- glue::glue(
"
# packages
library(galah)
library(dplyr)
library(tidyverse)
library(janitor)
library(here)
library(arrow)
galah_config(email = \"your-email-here\") # ALA-registered email

tree_kangaroo <- galah_call() |>
  filter(doi == \"{doi_tree_kangaroo}\") |>
  atlas_occurrences()

bees <- read_parquet(here(\"path\", \"to\", \"bees.parquet\"))
"
)
```

```{r prereq-printed}
#| eval: false
#| code: !expr test
#| echo: true
```

:::{.aside}

<img class = "rounded" src="https://ala-images.s3.ap-southeast-2.amazonaws.com/store/2/d/7/e/1f21b7e5-1cc7-45a0-8f83-d8e5dd51e7d2/original"></img>

::: {.figure-caption}
[*Dendrolagus lumholtzi* sitting on a branch.<br>Photo by matthewkwan  CC-BY](https://biocache.ala.org.au/occurrences/290bcdef-d02a-49fe-b96b-96865527f02f)
:::

<img class = "rounded" src="https://ala-images.s3.ap-southeast-2.amazonaws.com/store/0/0/e/5/277a5c28-827a-49c7-8588-d16333925e00/original"></img>

::: {.figure-caption}
[*Braunsapis* species hovering in front of a ghost gum tree flower.<br>Photo by Zig Madycki CC-BY-NC-ND 4.0 (Int)](https://biocache.ala.org.au/occurrences/92928258-92a1-4e6b-b9e2-46da0d8df383)
:::
:::

<!-- Queries -->
:::{.callout-note collapse="true" appearance="minimal"}

#### Original download queries

**Note:** You don't need to run this code block to read this chapter. It can, however, be useful to see the original download query. This code will download the latest data from the ALA, which you are welcome to use instead, though the data might not exactly reproduce results in this chapter.

```{r prereq-orig-query}
#| eval: false
library(galah)
galah_config(email = "your-email-here")

tree_kangaroo <- galah_call() |>
  galah_identify("Dendrolagus") |>
  atlas_occurrences() # <1>
```
1. We created a custom DOI for our download by using `atlas_occurrences(mint_doi = TRUE)`.

:::

## Basic string manipulation

The `stringr` package provides a number of useful functions for working with strings. 

```{r}
#| warning: false
#| message: false
library(stringr)
```

#### Trim

Trim whitespace on either side of a string.

```{r}
str_trim("  Genus specificus  ")
```

Or just one side. 

```{r}
str_trim("  Genus specificus  ", side = "left")
```

#### Squish

Squish strings into sentence spacing.

```{r}
str_squish("  Genus   specificus  ")
```

#### Truncate

Truncate a long string to a specified length. 

```{r}
str_trunc("Genus specificus", width = 10, side = "right")
```

#### Split

Split a string into separate pieces based on a specified character.

```{r}
str_split("Genus specificus", " ")
```

#### Concatenate

Concatenate (i.e. join) separate strings into one string separated by a specified character.

```{r}
str_c("Genus", "specificus", sep = "_")
```


## Matching

Matching strings using patterns can be a powerful way to identify or filter records during the data cleaning process.  

### Detect a pattern

Detect a pattern within a string.

```{r}
# detect if a pattern exists
str_detect("Genus specificus", "Genus")
```

Use `str_detect()` to filter your `data.frame`. Here, we filter the species names to only those containing the pattern `"lum"`.

```{r}
# 3 possible names in scientificName column
tree_kangaroo |> distinct(scientificName)
```

```{r}
# detect names matching "lum"
tree_kangaroo |>
  filter(str_detect(scientificName, "lum")) |>
  select(scientificName)
```


### Remove a pattern

Remove a pattern from a string.

```{r}
# remove match for Genus (followed by a whitespace)
str_remove("Genus specificus", pattern = "Genus ")
```

Use `str_remove()` to clean or extract names. Here, we remove the genus name from `scientificName` and save the result in a new `species` column. 

```{r}
tree_kangaroo |>
  mutate(
    species = ifelse(scientificName != "Dendrolagus",
                     str_remove(scientificName, "Dendrolagus "),
                     NA)
  ) |>
  select(scientificName, species)
```


### Locate a pattern

Locate the position of a pattern within a string. We'll create an example dataset below.

```{r}
records <- c("Genus", 
             "species", 
             "ZZGenus species", 
             "Difgenus difspecies")
```

Find the start and end position of a pattern.

```{r}
str_locate(records, "Genus")
```

Find which indices match a pattern. Here, the first and third strings in `records` contain the pattern `"Genus"`. 

```{r}
str_which(records, "Genus")
```

Add pattern location information to a `data.frame`.

```{r}
tree_kangaroo |>
  mutate(
    start = str_locate(scientificName, "lum")[, 1], # <1>
    end = str_locate(scientificName, "lum")[, 2] # <2>
  ) |>
  select(scientificName, start, end)
```
1. `[, 1]` returns column 1 of `str_locate()` output
2. `[, 2]` returns column 2 of `str_locate()` output

:::{.aside}

<img class = "rounded" src="https://ala-images.s3.ap-southeast-2.amazonaws.com/store/8/1/4/e/3ab85f6a-af7f-47a5-a0d8-19cfae02e418/original"></img>

::: {.figure-caption}
[*Dendrolagus bennettianus* grasping a tree branch.<br>Photo by David White CC-BY](https://biocache.ala.org.au/occurrences/277f995e-0e7e-45c2-afc6-8fe4bf765294)
:::
:::

### Regex matching

The examples above demonstrate the use of basic patterns. But for cases that
need more specific or advanced matching, we can use **regular expressions (or "regex")**. Regex is a powerful tool used to match patterns, replace characters, and extract text from strings. Regex can be complex and unintuitive, but there are websites available, such as [Regex Generator](https://regex-generator.olafneumann.org/), that are extremely helpful. 

Here we explore a few basic examples, and keep in mind that these methods can be applied to both column name strings and column values.

The `str_view()` function is a useful way to see what a regular expression will return. The results are shown in the **console**, and elements matched by the regex are surrounded with angle brackets `<` `>`. 

```{r}
# Match the first word in the string (the genus)
str_view(tree_kangaroo$scientificName, "^[A-Z][a-z]+") # <1>
```
1. This regex reads "Do not match all letters (capitalised or not) after word one."

```{r}
# Match only the second word (species name)
str_view(tree_kangaroo$scientificName, "(?<=\\s)[a-z]+") # <1>
```
1. This regex reads "Remove everything until and including the space. Return all uncapitalised letters."

### Replace

Another common way to clean strings is to match and replace specific patterns. Here are several examples using the [stringr package](https://stringr.tidyverse.org/) and base R.

:::{.panel-tabset .nav-pills}

#### `str_replace()`

In stringr, the `str_replace()` function can be used to replace the first match
of a string. The `str_replace_all()` function can be used to replace all
matches. 

```{r}
records <- c("Genus", 
             "species", 
             "ZZGenus species", 
             "Difgenus difspecies")
```


```{r}
str_replace(records, "[aeiou]", "-")     # first match
str_replace_all(records, "[aeiou]", "-") # all matches
```

Replace a matched pattern in a dataframe.

```{r}
tree_kangaroo |>
  mutate(
    name_updated = str_replace(
      scientificName, "^[A-Z][a-z]+", "new_name" # <1>
      )
  ) |>
  select(scientificName, name_updated)
```
1. This regex reads "Do not match all letters (capitalised or not) after word one." We then this with "`new_name`". 

#### `gsub()`

In base R the `gsub()` function can be used for pattern replacement. 

```{r}
records <- c("Genus", 
             "species", 
             "ZZGenus species", 
             "Difgenus difspecies")
```

```{r}
gsub("[aeiou]", "-", records) # all matches
```

Replace a matched pattern in a dataframe.

```{r}
tree_kangaroo$name_updated <- gsub(
  pattern = "Dendrolagus",
  replacement = "new_name",
  x = tree_kangaroo$scientificName
)

tree_kangaroo[,c("scientificName", "name_updated")]
```
:::

<!-- 
It might be a good idea to show what advanced regex looks like, but it needs to be a more useful example than the one below 
- DK

Yeah I agree - this article is quite long and overwhelming already. How is this example more advanced than the examples provided above? Is it just longer? I need a bit of clarification on that otherwise I think readers will struggle to see the relevance 
- OT 

Ok ommitting for now because the example wasn't great anyway. Will have to think of another example if it ever comes up. I think galah has one monster one I made, which could show how bespoke you can get 
- DK
-->

<!--
#### Advanced regex

In some cases a more specific detection and replacement is required. 

-->

## Capitalisation

Capitalisation (also called case style) can vary between data providers. Each data provider can have their own naming conventions, and even small differences in conventions must be standardised in order to use a data set. There are some basic functions available to change the case of strings in `stringr`:

```{r}
# example
tree_kangaroo$scientificName[1]
```

```{r}
str_to_lower(tree_kangaroo$scientificName[1])
str_to_upper(tree_kangaroo$scientificName[1])
str_to_title(tree_kangaroo$scientificName[1])
str_to_sentence(tree_kangaroo$scientificName[1])
```

Normally higher taxonomy are capitalised e.g. *Myrtaceae* or *Aves*. Capitalisation errors are usually quick to spot when you print the data object. Alternatively, you can try using `str_subset()` to return capitalisation matches in columns you expect to have capital letters.

For example, in our `bees` dataset (downloaded at [start of this chapter](strings.qmd#Prerequisites)) some higher taxonomy columns don't capitalise names. The code below subsets out unique values for the variable `class` that have upper case letters. Notice that no matches are found.

```{r}
str_subset(unique(bees$class), "[:upper:]")
```

:::{.aside}

<img class = "rounded" src="https://images.ala.org.au/image/details?imageId=b3e3de8e-b7dd-4edc-8985-74a6e2052b66"></img>

::: {.figure-caption}
[*Apis (Apis) mellifera* looking for some pollen.<br>Photo by Reiner Richter  CC-BY](https://biocache.ala.org.au/occurrences/93bd7c6e-7872-483b-b12e-f715ac967e29)
:::
:::

We can confirm that there are no upper case matches by subsetting unique values that have lower case letters to see what is going on. This shows us that *Insecta* is inputted entirely in lowercase.

```{r}
str_subset(unique(bees$class), "[:lower:]")
```

We can correct the lower case formatting as below, remember to check the fix before overwriting/removing the erroneous column(s).

```{r}
bees |>
  mutate(class_corrected = str_to_sentence(class)) |>
  select(starts_with("class"))

bees_corrected <- bees |>
  mutate(class_corrected = str_to_sentence(class)) |>
  select(-class) |>               # Remove erroneous column
  rename(class = class_corrected) # Rename new column to `class`
```


## Summary 

In this chapter, we discussed how to identify and clean strings and character patterns data. As you might have noticed, there truly are *many* ways that strings can appear in datasets, which is why there are so many tools and functions to detect them! 

In the next chapter, we look at how to clean dates and other temporal data.

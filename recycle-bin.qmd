## Recycle bin

<!--
This section used to follow "A first glimpse" in the Inspect chapter
On second thought, it seems redundant - many other chapters handle more detailed evaluation, so we might as well delete
-->

## Evaluate your dataset

It is also good at this initial point to evaluate whether your dataset is
what you expect. Ask yourself, does this data look like what you thought it would look like? Are the values in each column reasonable? Are there noticeable gaps or errors that might need
to be fixed (or stop you from using the data altogether)?

Here are some initial questions you might answer first. Note that
many of these statistics can be checked from the output of `skimr::skim()`.

### Is the number of records what you expected? {.unnumbered}

If the number is higher or lower than expected, there might be an issue with your query or the data source.

As an example using the galah package, the record count from `atlas_counts()`
should match the number of rows returned by `atlas_occurrences()` for the same
query.

```{r}
# Our original query
galah_call() |>
  identify("alcedinidae") |>
  filter(year == 2023) |>
  atlas_counts() # return counts

# occurrences
nrow(birds)
```


### Is there any missing data? {.unnumbered}

Missing values usually appear as `NA`, `NaN` or `""` in R. A high number of missing values can make it difficult to use a dataset for an analysis.

A quick way to check this is to breakdown values & their proportional frequency.

:::{.panel-tabset .nav-pills}

##### count()

Return the count of each group using dplyr.

```{r}
#| message: false
#| warning: false
library(dplyr)

birds |>
  group_by(genus) |>
  count()
```

##### tabyl()

Return summary tables with totals & percentages using `tabyl()` from janitor.

```{r}
#| message: false
#| warning: false
library(janitor)

birds |>
  tabyl(genus) |>
  adorn_pct_formatting()
```
:::

You can also return any rows with `NA` values in **any** column...

```{r}
# return rows with any NA values 
birds |>
  filter(if_any(everything(), is.na))
```

...or in a **specified** column.

```{r}
# return rows with NA values for genus
birds |>
  filter(is.na(genus))
```

<!-- The following few sections might fit better in the next chapter? -->

### What values do columns with text contain? {.unnumbered}

Incorrect or unrecognised names can inicate an issue with your download or the dataset. You can also get an idea of whether there are any typos, different spellings, capitalisation, strange characters

We can quickly return unique values using `distinct()` from dplyr.

```{r}
birds |>
  select(scientificName) |>
  distinct()
```

Sometimes it's also useful to see the number of rows grouped by each value.

```{r}
birds |>
  group_by(scientificName) |>
  count()
```


### How is numeric data distributed? {.unnumbered}

Distributions can help you get the sense of the spread of your data. Take note
of any unexpected values to investigate further.

To check the distribution of our longitude and latitude columns, for example, we can quickly select each column and plot the distribution using ggplot2.

```{r}
#| layout-ncol: 2
birds |>
  select(decimalLongitude) |>
  ggplot(aes(x = decimalLongitude)) + 
  geom_density(fill="#69b3a2",
               alpha=0.8)

birds |>
  select(decimalLatitude) |>
  ggplot(aes(x = decimalLatitude)) + 
  geom_density(fill="#69b3a2",
               alpha=0.8)
```

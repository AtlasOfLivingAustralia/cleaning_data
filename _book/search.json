[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ALA’s Data Cleaning Booklet",
    "section": "",
    "text": "Welcome\nWelcome to the Atlas of Living Australia’s Data Cleaning Booklet. This book is designed to be a practical guide on cleaning georeferenced biodiversity data using R. We focus on processes and challenges you’ll face with biodiversity data. As such, this book isn’t a guide to data cleaning in general, but a targeted resource for anyone working with or interested in georeferenced biodiversity data.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#how-to-contribute",
    "href": "index.html#how-to-contribute",
    "title": "ALA’s Data Cleaning Booklet",
    "section": "How to contribute",
    "text": "How to contribute\nContributions to this document are welcome. For questions or feedback, please open an issue in our GitHub repository. If you’d like to suggest content changes, feel free to submit a pull request. We recommend opening an issue first to discuss potential changes. Our contribution guidelines can be found here.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#how-to-cite",
    "href": "index.html#how-to-cite",
    "title": "ALA’s Data Cleaning Booklet",
    "section": "How to cite",
    "text": "How to cite\nYou can cite this book as: Kar, F., Schneider, M., Schwenke, A., Kellie, D., Balasubramaniam, S., Torresan, 0., Fenker, J., Westgate, M. (2023). ALA’s Data Cleaning Booklet. Retrieved Month dd, yyyy, from https://atlasoflivingaustralia.github.io/cleaning_data/\n\n\nThis book is available free to read, and is licenced under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#acknowledgement-of-country",
    "href": "index.html#acknowledgement-of-country",
    "title": "ALA’s Data Cleaning Booklet",
    "section": "Acknowledgement of Country",
    "text": "Acknowledgement of Country\nThe Atlas of Living Australia acknowledges that we live and work on Aboriginal and Torres Strait Islander lands, rivers, and seas. Indigenous Australian peoples held and continue to hold incomparably intricate environmental knowledge as first peoples of this country. As a data repository we are working to acknowledge and archive in a culturally sensitive way many different kinds of this knowledge with communities.\nThe authors of this book currently reside on Ngunnawal and Ngambri (Canberra), Wurundjeri and Bunurong (Melbourne), Turrbal and Yuggera (Brisbane), and Gadigal (Sydney) lands, and we pay our respects to Elders past and present.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "ALA’s Data Cleaning Booklet",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nThis book was inspired by an Australian Research Data Commons project where our team worked closely with research partners to streamline their data cleaning workflows. This book is a collaborative effort from the Science and Decision Support team at the Atlas of Living Australia (ALA)\nAuthors:\n\nShandiya Balasubramaniam\nFonti Kar\nDax Kellie\nJessica Fenker\nMargot Schneider\nAndrew Schwenke\nOlivia Torresan\nMartin Westgate",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Introduction",
    "section": "",
    "text": "Who is this book for?\nIf you are new to working with georeferenced biodiversity data in R, or are looking for a quick reference to data cleaning processes or concepts in R, then this book is for you. By learning how to download and apply common data cleaning steps, you will also develop a better understanding of biodiversity data, and common issues to be aware of.\nWe use R as it is commonly used across ecological projects, and has a rich ecosystem of packages for data cleaning and visualisation. It’s also free and open source.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#what-this-book-covers",
    "href": "intro.html#what-this-book-covers",
    "title": "Introduction",
    "section": "What this book covers",
    "text": "What this book covers\nIn this book, we provide an overview of a typical data cleaning workflow for open-access geo-referenced biodiversity data—from acquisition, to error identification, to correction. These processes are broken down into four sections. The chapters within each section include practical guidelines, example R code, and additional resources that may aid with each data cleaning step.\nThe first section is about accessing data. [summary]\nThe second section is about exploring data. [summary]\nThe third section is about general data cleaning processes. [summary]\nThe fourth section is about data cleaning processes that require expertise in your study species. [summary]",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#what-we-dont-cover",
    "href": "intro.html#what-we-dont-cover",
    "title": "Introduction",
    "section": "What we don’t cover",
    "text": "What we don’t cover\nThe areas of research and uses of biodiversity data are many and varied. Here we have focused on just one facet - downloading and cleaning georeferenced occurrence / biodiversity data. As such, this book will not cover:\n\nHypothesis testing or experimental design\nHow to clean environmental data that is not occurrence / biodiversity data (e.g. trait data)\nHow to perform analyses (e.g. species distribution modelling)",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#requirements",
    "href": "intro.html#requirements",
    "title": "Introduction",
    "section": "Requirements",
    "text": "Requirements\n\nUser accounts\nWe will be working with point-based species occurrence data retrieved from online infrastructures such as Global Biodiversity Information Facility (GBIF) and the Atlas of Living Australia (ALA). To retrieve data from these services, you will need to create a user account, if you do not already have one:\n\nRegister account: Atlas of Living Australia\nRegister account: Global Biodiversity Information Facility\n\n\n\nR\nTo get the most out of this book, a basic knowledge of using R and RStudio is recommended. If you are new to R or need a refresher, there are many amazing and freely available resources available online. Data Analysis and Visualisation in R for Ecologists, and R for Data Science are both excellent starting points.\nDownload R from CRAN, selecting the version that matches your operating system, and install it on your device.\n\n\nRStudio\nRStudio is an integrated development environment (IDE) for R programming. RStudio provides a range of tools to make working with R easier, and you can download and install RStudio for your operating system here.\nShould we offer a list of other IDEs that also work for R?\n\n\nPackages\nWe use a range of R packages throughout the book, primarily for data cleaning and visualisation. These packages will be noted at the beginning of a code block, typically at the start of a chapter. To access biodiversity data we will be working with the galah package. If you have collected your own occurrence data, you should still find this book useful.\nA list of the most common packages in this book can be found on the Packages page.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#conventions",
    "href": "intro.html#conventions",
    "title": "Introduction",
    "section": "Conventions",
    "text": "Conventions\n\nCode blocks\nDemonstrations and instructions throughout this book are accompanied by code blocks. These blocks show how a particular task was executed in R:\n\n# This is a code block with a comment\nlibrary(package-name)\n\nmtcars |&gt;\n   dplyr::group_by(cyl) |&gt;\n   dplyr::summarise(mean_mpg = mean(mpg))\n\n\n\n\n\n\n\nYou can copy code by clicking the [clipboard icon] button in the top right corner of a code block.\n\n\n\n\n\nCode line comments\nSome code blocks have circled numbers near the right edge of the code block. You can hover over these numbers to read additional context about that specific line of code.\n\nmtcars |&gt;\n1  dplyr::group_by(cyl)\n\n\n1\n\nThis line of code groups mtcars data by each distinct value in the variable cyl\n\n\n\n\nThroughout this book, we use “pipes” in our code (|&gt;, or %&gt;% from the magrittr package). Pipes allow you to chain multiple functions sequentially to an object or a dataset. Pipes can be read as saying “and then”.\nFor example, the code block above can be read as “Get data mtcars, and then group by cyl, and then summarise (setting mean_mpg to contain the mean of mpg).”",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "data.html",
    "href": "data.html",
    "title": "1  Data for this book",
    "section": "",
    "text": "1.1 inverts & plants\n#To create data used in this chapter\n#\n# inverts &lt;- open_dataset(\"../data_cleaning_workflows/ignore/Curated_Plant_and_Invertebrate_Data_for_Bushfire_Modelling/invertebrate.data.csv\", format = \"csv\")\n# \n# inverts |&gt; \n#   filter(family == \"apidae\") |&gt; \n#   write_parquet(sink = \"data/dap/bees.parquet\")\n#\n# Smaller subset of the dataset\n# set.seed(5)\n\n# inverts |&gt;\n#   collect() |&gt; \n#   sample_frac(0.05) |&gt;\n#   write_parquet(sink = \"data/dap/inverts_subset\")\n\n\n# Plants data with errors\n# plants &lt;- read_csv(\"../data_cleaning_workflows/ignore/Curated_Plant_and_Invertebrate_Data_for_Bushfire_Modelling/vascularplant.data.csv\")\n# \n# plants |&gt;\n#   select(record_id:longitude_used) |&gt;\n#   rename(latitude = latitude_used,\n#          longitude = longitude_used) |&gt;\n#   sample_frac(0.05) |&gt;\n#   write_parquet(\"data/dap/plants_subset\")",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Data for this book</span>"
    ]
  },
  {
    "objectID": "1_exploring/1_intro.html",
    "href": "1_exploring/1_intro.html",
    "title": "Exploring biodiversity data",
    "section": "",
    "text": "This section details how to get an initial glimpse of your dataset, explore its structure, and create summaries of the different types of data within it.\nClick on the buttons to jump to a section\n\n\n\n\n\nInspect\n\n\n\n\n\nSummarise",
    "crumbs": [
      "Exploring biodiversity data"
    ]
  },
  {
    "objectID": "1_exploring/inspect.html",
    "href": "1_exploring/inspect.html",
    "title": "2  Inspect",
    "section": "",
    "text": "2.0.1 Prerequisites\n# packages\nlibrary(ggplot2)\nlibrary(galah)\n\n# data: Kingfisher records from 2023\ngalah_config(email = \"your-email-here\") # ALA Registered email\n\nbirds &lt;- galah_call() |&gt;\n  identify(\"alcedinidae\") |&gt;\n  filter(year == 2023) |&gt;\n  select(group = \"basic\", genus, species) |&gt;\n  atlas_occurrences()",
    "crumbs": [
      "Exploring biodiversity data",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Inspect</span>"
    ]
  },
  {
    "objectID": "1_exploring/inspect.html#getting-to-know-your-data",
    "href": "1_exploring/inspect.html#getting-to-know-your-data",
    "title": "2  Inspect",
    "section": "2.1 Getting to know your data",
    "text": "2.1 Getting to know your data\nMetadata describes your dataset, defines its variables and previews their contents. Metadata tells you details like what unit of measurement was used, what the conditions were like, or whether a certain observation might be an outlier.\nReviewing the metadata of your dataset is always a good first step, as it allows you to understand the kind of data you are working with and any potential limitations of the data that might affect your analyses later.\nMany datasets include descriptions of the data’s taxonomic, spatial and temporal scope. An example of well formatted metadata is of FrogID from the Australian Museum.\n\n\n\nMetadata of the FrogID dataset on the ALA\n\n\nFrom reading FrogID’s metadata (Rowley and Callaghan 2020), you’ll find:\n\nThe data is acoustic data1\nThis is citizen science data2\nAudio is recorded via a smartphone app\nThese data record presences, but not absences\nThe data are under a Creative Commons license which is relevant for reuse and republishing\n\n\n\n\n\n\n\nData standards\n\n\n\n\n\nMany data infrastructures like the Atlas of Living Australia also follow a data standard to help consolidate data from many different data providers3.\nThe data standard used by the Atlas of Living Australia is called “Darwin Core”, which defines a set of standard terms4 to use across datasets (used as column names within datasets) and the accepted values that are recorded under specific terms. Darwin Core standards also require that additional files detailing metadata and data structure are supplied along with the dataset, which helps make sure the data is ingested correctly into the data infrastructure.\nKnowing whether your dataset follows a standard can allow you to look up term definitions as you become familiar with the data.",
    "crumbs": [
      "Exploring biodiversity data",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Inspect</span>"
    ]
  },
  {
    "objectID": "1_exploring/inspect.html#a-first-glimpse",
    "href": "1_exploring/inspect.html#a-first-glimpse",
    "title": "2  Inspect",
    "section": "2.2 A first glimpse",
    "text": "2.2 A first glimpse\nWhen starting with a new dataset, we want to get an initial idea:\n\nHow many rows and columns are there?\nWhat are the column names?\nWhat types of data are in each column?\nWhat are their possible values or ranges?\n\nThese answers are usefult o know before jumping into wrangling and cleaning data.\nThere are several ways to return an overview of your data, ranging in how comprehensively you wish to summarise your data’s structure.\n\nglimpse()skim()str()\n\n\nReturn a condensed summary of your data’s structure using glimpse() from dplyr.\n\nlibrary(dplyr)\n\nglimpse(birds)\n\nRows: 44,006\nColumns: 10\n$ recordID         &lt;chr&gt; \"00018120-2238-4122-ac0a-697a56de98ef\", \"00030a7e-a6c…\n$ scientificName   &lt;chr&gt; \"Dacelo (Dacelo) novaeguineae\", \"Todiramphus (Todiram…\n$ taxonConceptID   &lt;chr&gt; \"https://biodiversity.org.au/afd/taxa/1fc76c4d-4830-4…\n$ decimalLatitude  &lt;dbl&gt; -27.43493, -35.09131, -25.26933, -29.34741, -37.85030…\n$ decimalLongitude &lt;dbl&gt; 153.1473, 147.3581, 152.7561, 149.2783, 145.2905, 151…\n$ eventDate        &lt;dttm&gt; 2023-03-09 06:27:00, 2023-02-07 13:32:00, 2023-10-14…\n$ occurrenceStatus &lt;chr&gt; \"PRESENT\", \"PRESENT\", \"PRESENT\", \"PRESENT\", \"PRESENT\"…\n$ dataResourceName &lt;chr&gt; \"eBird Australia\", \"eBird Australia\", \"iNaturalist Au…\n$ genus            &lt;chr&gt; \"Dacelo\", \"Todiramphus\", \"Dacelo\", \"Todiramphus\", \"Da…\n$ species          &lt;chr&gt; \"Dacelo novaeguineae\", \"Todiramphus sanctus\", \"Dacelo…\n\n\n\n\nReturn tables of descriptive statistics for each variable, grouped by data type (e.g., numeric, character, date) using skim() from skimr.\n\nlibrary(skimr)\n\nskim(birds)\n\n\nData summary\n\n\nName\nbirds\n\n\nNumber of rows\n44006\n\n\nNumber of columns\n10\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n7\n\n\nnumeric\n2\n\n\nPOSIXct\n1\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\nrecordID\n0\n1.00\n36\n36\n0\n44006\n0\n\n\nscientificName\n0\n1.00\n6\n42\n0\n23\n0\n\n\ntaxonConceptID\n0\n1.00\n73\n73\n0\n23\n0\n\n\noccurrenceStatus\n0\n1.00\n7\n7\n0\n1\n0\n\n\ndataResourceName\n0\n1.00\n8\n46\n0\n12\n0\n\n\ngenus\n57\n1.00\n4\n11\n0\n5\n0\n\n\nspecies\n936\n0.98\n12\n24\n0\n10\n0\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\ndecimalLatitude\n0\n1\n-29.87\n7.35\n-43.6\n-35.32\n-31.82\n-27.33\n44.80\n▇▂▁▁▁\n\n\ndecimalLongitude\n0\n1\n147.14\n7.93\n14.0\n145.31\n149.69\n152.75\n167.97\n▁▁▁▁▇\n\n\n\nVariable type: POSIXct\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nmedian\nn_unique\n\n\n\n\neventDate\n0\n1\n2022-12-31 16:04:00\n2023-12-31 19:28:00\n2023-02-15 18:12:30\n26922\n\n\n\n\n\n\n\nReturn a quick summary of your data’s structure using base R str()\n\nstr(birds)\n\nspc_tbl_ [44,006 × 10] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ recordID        : chr [1:44006] \"00018120-2238-4122-ac0a-697a56de98ef\" \"00030a7e-a6cc-4f13-b37c-6672ca0b0ed3\" \"0005aa70-a30f-4ff0-9c82-9d05e66717d0\" \"0005e748-e148-4f57-8946-3d45d3a7dbcc\" ...\n $ scientificName  : chr [1:44006] \"Dacelo (Dacelo) novaeguineae\" \"Todiramphus (Todiramphus) sanctus\" \"Dacelo (Dacelo) novaeguineae\" \"Todiramphus (Todiramphus) sanctus\" ...\n $ taxonConceptID  : chr [1:44006] \"https://biodiversity.org.au/afd/taxa/1fc76c4d-4830-4129-9b86-1c7e944c3c50\" \"https://biodiversity.org.au/afd/taxa/135cc880-f84e-4470-a1c1-fbce3a0ed534\" \"https://biodiversity.org.au/afd/taxa/1fc76c4d-4830-4129-9b86-1c7e944c3c50\" \"https://biodiversity.org.au/afd/taxa/135cc880-f84e-4470-a1c1-fbce3a0ed534\" ...\n $ decimalLatitude : num [1:44006] -27.4 -35.1 -25.3 -29.3 -37.9 ...\n $ decimalLongitude: num [1:44006] 153 147 153 149 145 ...\n $ eventDate       : POSIXct[1:44006], format: \"2023-03-09 06:27:00\" \"2023-02-07 13:32:00\" ...\n $ occurrenceStatus: chr [1:44006] \"PRESENT\" \"PRESENT\" \"PRESENT\" \"PRESENT\" ...\n $ dataResourceName: chr [1:44006] \"eBird Australia\" \"eBird Australia\" \"iNaturalist Australia\" \"NSW BioNet Atlas\" ...\n $ genus           : chr [1:44006] \"Dacelo\" \"Todiramphus\" \"Dacelo\" \"Todiramphus\" ...\n $ species         : chr [1:44006] \"Dacelo novaeguineae\" \"Todiramphus sanctus\" \"Dacelo novaeguineae\" \"Todiramphus sanctus\" ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   recordID = col_character(),\n  ..   scientificName = col_character(),\n  ..   taxonConceptID = col_character(),\n  ..   decimalLatitude = col_double(),\n  ..   decimalLongitude = col_double(),\n  ..   eventDate = col_datetime(format = \"\"),\n  ..   occurrenceStatus = col_character(),\n  ..   dataResourceName = col_character(),\n  ..   genus = col_character(),\n  ..   species = col_character()\n  .. )\n - attr(*, \"problems\")=&lt;externalptr&gt; \n - attr(*, \"search_url\")= chr \"https://biocache.ala.org.au/occurrences/search?&q=*%3A*&fq=%28lsid%3A%22https%3A%2F%2Fbiodiversity.org.au%2Fafd\"| __truncated__\n\n\n\n\n\nIt is also good at this initial point to evaluate whether your dataset is what you expect. Ask yourself, does this data look like what you thought it would look like? Are the values in each column reasonable? Are there noticeable gaps or errors that might need to be fixed (or stop you from using the data altogether)?",
    "crumbs": [
      "Exploring biodiversity data",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Inspect</span>"
    ]
  },
  {
    "objectID": "1_exploring/inspect.html#next-steps",
    "href": "1_exploring/inspect.html#next-steps",
    "title": "2  Inspect",
    "section": "2.3 Next steps",
    "text": "2.3 Next steps\nWe have just learned some ways to initially inspect our dataset. Keep in mind, we don’t expect everything in our dataset to be perfect. Some issues are expected, and may reveal that there are issues with our query or with the data themselves. The initial inspection is a good opportunity to get an idea of where these issues might be and how serious they are.\nWhen you are satisfied that the dataset is largely as expected, you are ready to start summarising your data.\n\n\n\n\nRowley, Jodi JL, and Corey T Callaghan. 2020. “The FrogID Dataset: Expert-Validated Occurrence Records of Australia’s Frogs Collected by Citizen Scientists.” ZooKeys 912: 139.",
    "crumbs": [
      "Exploring biodiversity data",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Inspect</span>"
    ]
  },
  {
    "objectID": "1_exploring/inspect.html#footnotes",
    "href": "1_exploring/inspect.html#footnotes",
    "title": "2  Inspect",
    "section": "",
    "text": "Meaning the majority of the species recorded are male.↩︎\nSuggesting these data could be biased towards populated areas↩︎\nMaking datasets easier to consolidate is also referred to as interoperability, one of the principles of FAIR data.↩︎\nWe suggest using Ctrl/CMD + F and searching your variable name on the webpage. Don’t hesitate to Google variable names if you are unsure what they represent.↩︎",
    "crumbs": [
      "Exploring biodiversity data",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Inspect</span>"
    ]
  },
  {
    "objectID": "1_exploring/summarise.html",
    "href": "1_exploring/summarise.html",
    "title": "3  Summarise",
    "section": "",
    "text": "3.0.1 Prerequisite\n# packages\nlibrary(ggplot2)\nlibrary(galah)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(janitor)\n\n# data: Kingfisher records from 2023\ngalah_config(email = \"your-email-here\") # ALA Registered email\n\nbirds &lt;- galah_call() |&gt;\n  identify(\"alcedinidae\") |&gt;\n  filter(year == 2022) |&gt;\n  select(group = \"basic\", \n         family, genus, species, cl22, eventDate, month) |&gt;\n  atlas_occurrences()",
    "crumbs": [
      "Exploring biodiversity data",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Summarise</span>"
    ]
  },
  {
    "objectID": "1_exploring/summarise.html#taxonomic",
    "href": "1_exploring/summarise.html#taxonomic",
    "title": "3  Summarise",
    "section": "3.1 Taxonomic",
    "text": "3.1 Taxonomic\n\n3.1.1 Counts\nPrior to downloading occurrences, it can be useful to summarise the number of records…\n\ngalah_call() |&gt;\n  identify(\"alcedinidae\") |&gt;\n  filter(year == 2022) |&gt;\n  atlas_counts()\n\n# A tibble: 1 × 1\n   count\n   &lt;int&gt;\n1 138577\n\n\n…and break them down by a taxonomic clade like genus…\n\ngalah_call() |&gt;\n  identify(\"alcedinidae\") |&gt;\n  filter(year == 2022) |&gt;\n  group_by(genus) |&gt;\n  atlas_counts()\n\n# A tibble: 5 × 2\n  genus       count\n  &lt;chr&gt;       &lt;int&gt;\n1 Dacelo      90667\n2 Todiramphus 40720\n3 Ceyx         5852\n4 Tanysiptera   886\n5 Syma          338\n\n\n…or species.\n\ngalah_call() |&gt;\n  identify(\"alcedinidae\") |&gt;\n  filter(year == 2022) |&gt;\n  group_by(species) |&gt;\n  atlas_counts()\n\n# A tibble: 10 × 2\n   species                  count\n   &lt;chr&gt;                    &lt;int&gt;\n 1 Dacelo novaeguineae      83402\n 2 Todiramphus sanctus      25815\n 3 Todiramphus macleayii     9850\n 4 Dacelo leachii            7260\n 5 Ceyx azureus              5195\n 6 Todiramphus pyrrhopygius  2319\n 7 Tanysiptera sylvia         886\n 8 Ceyx pusillus              657\n 9 Syma torotoro              338\n10 Todiramphus chloris         27\n\n\nOur results show that the large majority of records are of Dacelo novaeguineae (aka the Laughing Kookaburra).\nYou can get the same summaries after downloading the data locally using dplyr or janitor.\n\ndplyrjanitor\n\n\n\n# Using our pre-downloaded dataset\nbirds |&gt;\n  group_by(genus) |&gt;\n  count() |&gt;\n  arrange(desc(-n))\n\n# A tibble: 6 × 2\n# Groups:   genus [6]\n  genus           n\n  &lt;chr&gt;       &lt;int&gt;\n1 &lt;NA&gt;          114\n2 Syma          338\n3 Tanysiptera   886\n4 Ceyx         5852\n5 Todiramphus 40720\n6 Dacelo      90667\n\nbirds |&gt;\n  group_by(species) |&gt;\n  count() |&gt;\n  arrange(desc(-n))\n\n# A tibble: 11 × 2\n# Groups:   species [11]\n   species                      n\n   &lt;chr&gt;                    &lt;int&gt;\n 1 Todiramphus chloris         27\n 2 Syma torotoro              338\n 3 Ceyx pusillus              657\n 4 Tanysiptera sylvia         886\n 5 Todiramphus pyrrhopygius  2319\n 6 &lt;NA&gt;                      2828\n 7 Ceyx azureus              5195\n 8 Dacelo leachii            7260\n 9 Todiramphus macleayii     9850\n10 Todiramphus sanctus      25815\n11 Dacelo novaeguineae      83402\n\n\n\n\n\n# Using our pre-downloaded dataset\nbirds |&gt;\n  tabyl(genus) |&gt;\n  adorn_pct_formatting()\n\n       genus     n percent valid_percent\n        Ceyx  5852    4.2%          4.2%\n      Dacelo 90667   65.4%         65.5%\n        Syma   338    0.2%          0.2%\n Tanysiptera   886    0.6%          0.6%\n Todiramphus 40720   29.4%         29.4%\n        &lt;NA&gt;   114    0.1%             -\n\nbirds |&gt;\n  tabyl(species) |&gt;\n  adorn_pct_formatting()\n\n                  species     n percent valid_percent\n             Ceyx azureus  5195    3.7%          3.8%\n            Ceyx pusillus   657    0.5%          0.5%\n           Dacelo leachii  7260    5.2%          5.3%\n      Dacelo novaeguineae 83402   60.2%         61.4%\n            Syma torotoro   338    0.2%          0.2%\n       Tanysiptera sylvia   886    0.6%          0.7%\n      Todiramphus chloris    27    0.0%          0.0%\n    Todiramphus macleayii  9850    7.1%          7.3%\n Todiramphus pyrrhopygius  2319    1.7%          1.7%\n      Todiramphus sanctus 25815   18.6%         19.0%\n                     &lt;NA&gt;  2828    2.0%             -",
    "crumbs": [
      "Exploring biodiversity data",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Summarise</span>"
    ]
  },
  {
    "objectID": "1_exploring/summarise.html#spatial",
    "href": "1_exploring/summarise.html#spatial",
    "title": "3  Summarise",
    "section": "3.2 Spatial",
    "text": "3.2 Spatial\n\n3.2.1 Counts by region\nIt can be useful to summarise occurrence numbers by a specific region. In galah, you can do this prior to downloading your data.\nFor example, you might wish to summarise your data by state/territory. We can search for the correct field to use in galah, determining that field ID cl22 seems to suit our needs best.\n\nsearch_all(fields, \"states\")\n\n# A tibble: 5 × 3\n  id       description                            type  \n  &lt;chr&gt;    &lt;chr&gt;                                  &lt;chr&gt; \n1 cl2013   ASGS Australian States and Territories fields\n2 cl22     Australian States and Territories      fields\n3 cl927    States including coastal waters        fields\n4 cl10925  PSMA States (2016)                     fields\n5 cl110925 PSMA States - Abbreviated (2016)       fields\n\n\nNow we can use the field ID cl22 to group our counts.\n\ngalah_call() |&gt;\n  identify(\"alcedinidae\") |&gt;\n  filter(year == 2022) |&gt;\n  group_by(cl22) |&gt;\n  atlas_counts()\n\n# A tibble: 8 × 2\n  cl22                         count\n  &lt;chr&gt;                        &lt;int&gt;\n1 Queensland                   50266\n2 New South Wales              36867\n3 Victoria                     23917\n4 Northern Territory            9783\n5 Western Australia             7646\n6 Australian Capital Territory  3518\n7 Tasmania                      2441\n8 South Australia               2429\n\n\nWe can also group our counts by state/territory and a taxonomic rank like genus.\n\ngalah_call() |&gt;\n  identify(\"alcedinidae\") |&gt;\n  filter(year == 2022) |&gt;\n  group_by(cl22, genus) |&gt;\n  atlas_counts()\n\n# A tibble: 26 × 3\n   cl22            genus       count\n   &lt;chr&gt;           &lt;chr&gt;       &lt;int&gt;\n 1 Queensland      Dacelo      27025\n 2 Queensland      Todiramphus 19390\n 3 Queensland      Ceyx         2562\n 4 Queensland      Tanysiptera   885\n 5 Queensland      Syma          336\n 6 New South Wales Dacelo      28023\n 7 New South Wales Todiramphus  7420\n 8 New South Wales Ceyx         1415\n 9 Victoria        Dacelo      19643\n10 Victoria        Todiramphus  3757\n# ℹ 16 more rows\n\n\nOur results show that we have the most records in Queensland and New South Wales.\nYou can get the same summaries after downloading the data locally with dplyr and janitor.\n\ndplyrjanitor\n\n\n\n# Using our pre-downloaded dataset\nbirds |&gt;\n  group_by(cl22) |&gt;\n  count() |&gt;\n  arrange(desc(n))\n\n# A tibble: 9 × 2\n# Groups:   cl22 [9]\n  cl22                             n\n  &lt;chr&gt;                        &lt;int&gt;\n1 Queensland                   50266\n2 New South Wales              36867\n3 Victoria                     23917\n4 Northern Territory            9783\n5 Western Australia             7646\n6 Australian Capital Territory  3518\n7 Tasmania                      2441\n8 South Australia               2429\n9 &lt;NA&gt;                          1710\n\nbirds |&gt;\n  group_by(species, cl22) |&gt;\n  count() |&gt;\n  arrange(desc(n))\n\n# A tibble: 59 × 3\n# Groups:   species, cl22 [59]\n   species               cl22                   n\n   &lt;chr&gt;                 &lt;chr&gt;              &lt;int&gt;\n 1 Dacelo novaeguineae   New South Wales    28023\n 2 Dacelo novaeguineae   Queensland         23903\n 3 Dacelo novaeguineae   Victoria           19642\n 4 Todiramphus sanctus   Queensland         10255\n 5 Todiramphus sanctus   New South Wales     6660\n 6 Todiramphus macleayii Queensland          6357\n 7 Dacelo novaeguineae   Western Australia   3957\n 8 Todiramphus sanctus   Victoria            3749\n 9 Todiramphus macleayii Northern Territory  3134\n10 Dacelo leachii        Queensland          3121\n# ℹ 49 more rows\n\n\n\n\n\n# Using our pre-downloaded dataset\nbirds |&gt;\n  tabyl(cl22) |&gt;\n  adorn_pct_formatting()\n\n                         cl22     n percent valid_percent\n Australian Capital Territory  3518    2.5%          2.6%\n              New South Wales 36867   26.6%         26.9%\n           Northern Territory  9783    7.1%          7.1%\n                   Queensland 50266   36.3%         36.7%\n              South Australia  2429    1.8%          1.8%\n                     Tasmania  2441    1.8%          1.8%\n                     Victoria 23917   17.3%         17.5%\n            Western Australia  7646    5.5%          5.6%\n                         &lt;NA&gt;  1710    1.2%             -\n\nbirds |&gt;\n  tabyl(species, cl22) |&gt;\n  adorn_pct_formatting()\n\n                  species Australian Capital Territory New South Wales\n             Ceyx azureus                      4700.0%       141500.0%\n            Ceyx pusillus                         0.0%            0.0%\n           Dacelo leachii                         0.0%            0.0%\n      Dacelo novaeguineae                    283500.0%      2802300.0%\n            Syma torotoro                         0.0%            0.0%\n       Tanysiptera sylvia                         0.0%            0.0%\n      Todiramphus chloris                         0.0%          600.0%\n    Todiramphus macleayii                         0.0%        32400.0%\n Todiramphus pyrrhopygius                         0.0%        24700.0%\n      Todiramphus sanctus                     63600.0%       666000.0%\n                     &lt;NA&gt;                         0.0%        19200.0%\n Northern Territory Queensland South Australia  Tasmania   Victoria\n           93000.0%  202600.0%          200.0%   2100.0%   51700.0%\n           11300.0%   53600.0%            0.0%      0.0%       0.0%\n          304100.0%  312100.0%            0.0%      0.0%       0.0%\n               0.0% 2390300.0%       180600.0% 240000.0% 1964200.0%\n               0.0%   33600.0%            0.0%      0.0%       0.0%\n               0.0%   88500.0%            0.0%      0.0%       0.0%\n               0.0%     100.0%            0.0%      0.0%       0.0%\n          313400.0%  635700.0%            0.0%      0.0%       0.0%\n           74600.0%   74100.0%        26800.0%      0.0%     800.0%\n          145200.0% 1025500.0%        35000.0%   2000.0%  374900.0%\n           36700.0%  210500.0%          300.0%      0.0%     100.0%\n Western Australia      NA_\n          16300.0%  7400.0%\n              0.0%   800.0%\n         106000.0%  3800.0%\n         395700.0% 83600.0%\n              0.0%   200.0%\n              0.0%   100.0%\n           1300.0%   700.0%\n              0.0%  3500.0%\n          30800.0%   100.0%\n         211700.0% 57600.0%\n           2800.0% 13200.0%\n\n\n\n\n\n\n\n3.2.2 Maps\nWe can use maps to visually summarise our data. To do so, we will use the sf package to handle spatial data, and the ozmaps package to get maps of Australia (as vector data).\n\nlibrary(sf)\nlibrary(ozmaps)\n\nThe easiest way to get a spatial summary is to create a quick map of observations.\nThere are a few stray data points in our birds data that are outside of Australia. For simplicity, we will filter our data to records within Australia’s land mass.\n\n# filter records to within Australia\nbirds_filtered &lt;- birds |&gt;\n  filter(decimalLongitude &gt; 110,\n         decimalLongitude &lt; 155, \n         decimalLatitude &gt; -45,\n         decimalLatitude &lt; -10)\n\nOur first step is to get a map of Australia, and an excellent place to get one is from the ozmaps package. We will transform its Coordinate Reference System (CRS)1 projection to EPSG:4326 to match the CRS projection of ALA data2.\n\n# Get map of australia, and transform projection\naus &lt;- ozmaps::ozmap_states |&gt;\n  st_transform(crs = st_crs(4326))\n\nThen we can plot our occurrence points onto our map.\n\nPoint mapPoint density mapFacetted maps\n\n\nPoint maps are quick and useful visualisations of where your occurrence records are located. Here we have also adjusted the size and alpha values to make the points slightly larger and more transparent.\n\n# Plot the observations on our map of Australia\nggplot() +\n  geom_sf(data = aus, \n          colour = \"grey60\", \n          fill = \"white\") +\n  geom_point(data = birds_filtered,\n             aes(x = decimalLongitude, \n                 y = decimalLatitude),\n             colour = \"#428afe\",\n             size = 1.8, \n             alpha = 0.6) +\n  theme_void()\n\n\n\n\n\n\n\n\n\n\nWith over 40,000 points plotted on our map, it can be hard to see every single point, or where many points overlap.\nWe can use the ggpointdensity package to visualise locations where there are many overlapping occurrences.\n\nlibrary(ggpointdensity)\nlibrary(viridis) # colour palette\n\nggplot() +\n  geom_sf(data = aus, \n          colour = \"grey60\", \n          fill = \"white\") +\n  geom_pointdensity(data = birds_filtered,\n             aes(x = decimalLongitude, \n                 y = decimalLatitude),\n             size = 1.8, \n             alpha = 0.6) +\n  scale_colour_viridis_c(option = \"F\",     # palette\n                         end = .8,         # final light colour value\n                         direction = -1) + # reverse light-to-dark\n  guides(\n    colour = guide_colourbar(\n      title = \"Number of\\noverlapping\\nobservations\")\n    ) +\n  theme_void()\n\n\n\n\n\n\n\n\n\n\nIt can also be useful to create a collection of maps grouped by a specific variable (i.e., facetted).\nHere is one taxonomic example, grouping by species. Visualising by groups can reveal spatial trends, and also help you determine whether there is enough data for each species or taxonomic group for your later analyses.\n\nggplot() +\n  geom_sf(data = aus, \n          colour = \"grey60\", \n          fill = \"white\") +\n  geom_point(data = birds_filtered |&gt; \n               drop_na(species), # remove NA values \n             aes(x = decimalLongitude, \n                 y = decimalLatitude,\n                 colour = species),\n             size = 1.8, \n             alpha = 0.6) +\n  pilot::scale_color_pilot() +\n  theme_void() + \n  facet_wrap( ~ species) + \n  theme(legend.position = \"none\")",
    "crumbs": [
      "Exploring biodiversity data",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Summarise</span>"
    ]
  },
  {
    "objectID": "1_exploring/summarise.html#temporal",
    "href": "1_exploring/summarise.html#temporal",
    "title": "3  Summarise",
    "section": "3.3 Temporal",
    "text": "3.3 Temporal\n\n3.3.1 Counts by time scales\nKnowing the breakdown of when occurrence records are recorded can reveal trends in seasonality between species. Checking this breakdown can also help you determine whether you have enough data to make inferences about patterns over the span of a year, or whether you’re inferences about temporal trends are limited by the amount of data.\n\n3.3.1.1 Year\nFor example, an easy first summary is to know the number of records in each year. You can do this in galah prior to download data. We can search for the correct field to use in galah, determining that field ID year seems to suit our needs best.\n\nsearch_all(fields, \"year\")\n\n# A tibble: 8 × 3\n  id                  description            type  \n  &lt;chr&gt;               &lt;chr&gt;                  &lt;chr&gt; \n1 year                Year                   fields\n2 raw_year            Year (unprocessed)     fields\n3 endDayOfYear        End Day Of Year        fields\n4 startDayOfYear      Start Day Of Year      fields\n5 occurrenceYear      Date (by decade)       fields\n6 raw_endDayOfYear    &lt;NA&gt;                   fields\n7 raw_startDayOfYear  &lt;NA&gt;                   fields\n8 namePublishedInYear Name Published In Year fields\n\n\nNow we can use the field ID year to group our counts, returning years since 2016.\n\ngalah_call() |&gt;\n  identify(\"alcedinidae\") |&gt;\n  filter(year &gt; 2016) |&gt;\n  group_by(year) |&gt;\n  atlas_counts()\n\n# A tibble: 8 × 2\n  year   count\n  &lt;chr&gt;  &lt;int&gt;\n1 2022  138577\n2 2021  128665\n3 2020  108916\n4 2018   95615\n5 2019   93810\n6 2017   78634\n7 2023   44006\n8 2024    1030\n\n\nYou can summarise after downloading counts locally with help from the lubridate package.\nWe’ll convert our column eventDate to a date class in R. Then we can extract relevant date data…\n\n# Using our pre-downloaded dataset\nlibrary(lubridate)\n\nbirds_date &lt;- birds |&gt;\n  mutate(eventDate = date(eventDate), # convert to date\n         year = year(eventDate),      # extract year\n         month = month(eventDate,     # extract month\n                       label = TRUE))\n\nbirds_date |&gt;\n  select(scientificName, eventDate, year, month)\n\n# A tibble: 138,577 × 4\n   scientificName                    eventDate   year month\n   &lt;chr&gt;                             &lt;date&gt;     &lt;dbl&gt; &lt;ord&gt;\n 1 Dacelo (Dacelo) novaeguineae      2022-04-19  2022 Apr  \n 2 Dacelo (Dacelo) novaeguineae      2022-12-25  2022 Dec  \n 3 Dacelo (Dacelo) novaeguineae      2022-10-27  2022 Oct  \n 4 Dacelo (Dacelo) novaeguineae      2022-01-23  2022 Jan  \n 5 Dacelo (Dacelo) novaeguineae      2022-11-09  2022 Nov  \n 6 Todiramphus (Todiramphus) sanctus 2022-02-05  2022 Feb  \n 7 Todiramphus (Todiramphus) sanctus 2022-11-24  2022 Nov  \n 8 Dacelo (Dacelo) novaeguineae      2022-10-01  2022 Oct  \n 9 Dacelo (Dacelo) novaeguineae      2022-03-21  2022 Mar  \n10 Dacelo (Dacelo) novaeguineae      2022-08-14  2022 Aug  \n# ℹ 138,567 more rows\n\n\n…and summarise using dplyr or janitor.\n\ndplyrjanitor\n\n\n\n# by year\nbirds_date |&gt;   \n  group_by(year) |&gt;\n  count()\n\n# A tibble: 3 × 2\n# Groups:   year [3]\n   year      n\n  &lt;dbl&gt;  &lt;int&gt;\n1  2021      4\n2  2022 138571\n3    NA      2\n\n\n\n# by month\nbirds_date |&gt;\n  group_by(month) |&gt;\n  count() |&gt;\n  arrange(-desc(month))\n\n# A tibble: 13 × 2\n# Groups:   month [13]\n   month     n\n   &lt;ord&gt; &lt;int&gt;\n 1 Jan   14757\n 2 Feb    9294\n 3 Mar    8822\n 4 Apr    9457\n 5 May    8543\n 6 Jun    9068\n 7 Jul   10556\n 8 Aug   11671\n 9 Sep   13056\n10 Oct   15759\n11 Nov   13995\n12 Dec   13597\n13 &lt;NA&gt;      2\n\n\n\n\n\n# by year\nbirds_date |&gt;\n  tabyl(year) |&gt;\n  adorn_pct_formatting()\n\n year      n percent valid_percent\n 2021      4    0.0%          0.0%\n 2022 138571  100.0%        100.0%\n   NA      2    0.0%             -\n\n\n\n# by month\nbirds_date |&gt;\n  tabyl(month) |&gt;\n  arrange(desc(month))\n\n month     n      percent valid_percent\n   Dec 13597 9.811874e-02    0.09812015\n   Nov 13995 1.009908e-01    0.10099224\n   Oct 15759 1.137202e-01    0.11372181\n   Sep 13056 9.421477e-02    0.09421613\n   Aug 11671 8.422033e-02    0.08422154\n   Jul 10556 7.617426e-02    0.07617536\n   Jun  9068 6.543654e-02    0.06543749\n   May  8543 6.164804e-02    0.06164893\n   Apr  9457 6.824365e-02    0.06824463\n   Mar  8822 6.366136e-02    0.06366228\n   Feb  9294 6.706741e-02    0.06706837\n   Jan 14757 1.064895e-01    0.10649107\n  &lt;NA&gt;     2 1.443241e-05            NA\n\n\n\n\n\n\n\n3.3.1.2 Line plots\nAnother way to summarise temporal data is using line plots to visualise trends at different time scales over one or more years.\nThere are a few records that seem to be from 2021 despite downloading data for 2022. For simplicity, we’ll filter them out.\n\n# filter dataset to 2022 only\nbirds_day &lt;- birds_date |&gt;\n  filter(year(eventDate) == 2022) |&gt;\n  mutate(\n    day = yday(eventDate))\n\nNow we can group our records by each day of the year, and summarise the record count for each day.\n\nbirds_day &lt;- birds_day |&gt;\n  group_by(day) |&gt;\n  summarise(count = n()) \nbirds_day\n\n# A tibble: 365 × 2\n     day count\n   &lt;dbl&gt; &lt;int&gt;\n 1     1   891\n 2     2   745\n 3     3   692\n 4     4   595\n 5     5   461\n 6     6   440\n 7     7   398\n 8     8   572\n 9     9   682\n10    10   433\n# ℹ 355 more rows\n\n\n…. and now we can visualise our data.\n\nggplot(birds_day, aes(x = day, y = count)) +\n  geom_line() +  # Add lines\n  geom_point() + # Add points\n  labs(x = \"Day\", y = \"Count (log10)\") +\n  scale_x_continuous(breaks = seq(1, 365, by = 30)) +\n  scale_y_log10() +  # Set logarithmic scale for y-axis\n  theme_minimal()  # Set a minimal theme\n\n\n\n\nNumber of observations per day (2022)\n\n\n\n\nYou can use the same method above to group record counts by week.\n\n\nCode\nbirds_week &lt;- birds_date |&gt;\n  filter(year(eventDate) == 2022) |&gt;\n  mutate(\n    week = week(eventDate)) |&gt;\n  group_by(week) |&gt;\n  summarise(count = n()) \n\nggplot(birds_week, aes(x = week, y = count)) +\n  geom_line() +  # Add lines\n  geom_point() + # Add points\n  labs(x = \"Week\", y = \"Count (log10)\") +\n  scale_x_continuous(breaks = seq(1, 52, by = 4)) + \n  # scale_y_log10() +  # Set logarithmic scale for y-axis\n  theme_minimal()  # Set a minimal theme\n\n\n\n\n\nNumber of observations per week (2022)",
    "crumbs": [
      "Exploring biodiversity data",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Summarise</span>"
    ]
  },
  {
    "objectID": "1_exploring/summarise.html#summary",
    "href": "1_exploring/summarise.html#summary",
    "title": "3  Summarise",
    "section": "3.4 Summary",
    "text": "3.4 Summary\nIn this chapter we have provided a few ways to summarise your data taxonomically, spatially and temporally. We hope that you can copy these code chunks and use them to summarise your own data. Summarising and visualising data is one of the most useful ways to spot errors for data cleaning. As such, we suggest using these tools often over your entire analysis.\nIn the next part of this book, we will tackle these issues to clean your dataset.",
    "crumbs": [
      "Exploring biodiversity data",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Summarise</span>"
    ]
  },
  {
    "objectID": "1_exploring/summarise.html#footnotes",
    "href": "1_exploring/summarise.html#footnotes",
    "title": "3  Summarise",
    "section": "",
    "text": "The Coordinate Reference System (CRS) determines how to display our shape of Australia, which exists on a spherical globe (the Earth), onto a flat surface (our map).↩︎\nData from the ALA use EPSG:4326 (also known as “WGS84”) as the Coordinate Reference System. Transforming our map to the same projection of our data ensures the points are plotted in their actual locations on the map.↩︎",
    "crumbs": [
      "Exploring biodiversity data",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Summarise</span>"
    ]
  },
  {
    "objectID": "2_cleaning_general/1_intro.html",
    "href": "2_cleaning_general/1_intro.html",
    "title": "General data cleaning",
    "section": "",
    "text": "This section will detail some steps and functions to clean a dataset for analysis. These steps will remove problematic values that are due to the data’s formatting, solved by more general data cleaning tasks. These tasks include removing duplicates, correcting dates, and removing or correcting missing or unexpected values.\nThe steps in this chapter are not linear, and they don’t have to be done in order. Treat this section as more of a checklist.\nClick on the following chapters to get started:\n\n\n\n\n\nDuplicates\n\n\n\n\n\nMissing values\n\n\n\n\n\nUnexpected values\n\n\n\n\n\nStrings\n\n\n\n\n\nDates\n\n\n\n\n\nColumn names + classes",
    "crumbs": [
      "General data cleaning"
    ]
  },
  {
    "objectID": "2_cleaning_general/column-names-and-classes.html",
    "href": "2_cleaning_general/column-names-and-classes.html",
    "title": "4  Column classes & names",
    "section": "",
    "text": "4.0.1 Prerequisites\nIn this chapter, we will use Litoria frog occurrence data since 2020 in Tasmania.\n# packages\nlibrary(galah)\nlibrary(dplyr)\n\n# data: frog records\ngalah_config(email = \"your-email-here\")\n\nfrogs &lt;- galah_call() |&gt;\n  identify(\"Litoria\") |&gt;\n  filter(year &gt;= 2020, \n         cl22 == \"Tasmania\") |&gt;\n  select(group = \"basic\",\n         genus, species) |&gt;\n  atlas_occurrences()\n\n# WORMS dataset\nmarine_species &lt;- readr::read_csv(here::here(\"data\", \"worms\", \"worms.csv\"))",
    "crumbs": [
      "General data cleaning",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Column classes & names</span>"
    ]
  },
  {
    "objectID": "2_cleaning_general/column-names-and-classes.html#column-classes",
    "href": "2_cleaning_general/column-names-and-classes.html#column-classes",
    "title": "4  Column classes & names",
    "section": "4.1 Column classes",
    "text": "4.1 Column classes\nColumns define what type of data they contain by specifying a class. Classes are important because R handles each differently depending what they are.\nViewing your data using functions we used in the Inspect chapter allows you to get a quick glimpse of each column’s class.\n\nglimpse()str()skim()sapply()map()\n\n\nUsing glimpse() displays the column class beside the column names (e.g., )\n\nlibrary(dplyr)\n\nglimpse(frogs)\n\nRows: 1,725\nColumns: 10\n$ recordID         &lt;chr&gt; \"00168ca6-84d0-4af1-8fa8-875fd69d25da\", \"00250163-ec5…\n$ scientificName   &lt;chr&gt; \"Litoria raniformis\", \"Litoria raniformis\", \"Litoria …\n$ taxonConceptID   &lt;chr&gt; \"https://biodiversity.org.au/afd/taxa/89a7a289-bf04-4…\n$ decimalLatitude  &lt;dbl&gt; -41.19207, -41.15305, -42.85886, -41.67640, -43.10238…\n$ decimalLongitude &lt;dbl&gt; 146.4331, 146.5241, 147.6137, 146.9180, 147.0494, 147…\n$ eventDate        &lt;dttm&gt; 2023-12-20 23:20:19, 2023-08-23 01:49:28, 2022-12-23…\n$ occurrenceStatus &lt;chr&gt; \"PRESENT\", \"PRESENT\", \"PRESENT\", \"PRESENT\", \"PRESENT\"…\n$ dataResourceName &lt;chr&gt; \"iNaturalist Australia\", \"iNaturalist Australia\", \"iN…\n$ genus            &lt;chr&gt; \"Litoria\", \"Litoria\", \"Litoria\", \"Litoria\", \"Litoria\"…\n$ species          &lt;chr&gt; \"Litoria raniformis\", \"Litoria raniformis\", \"Litoria …\n\n\n\n\nUsing str() displays the column class after the column name and before the number of rows (e.g., chr)\n\nstr(frogs)\n\nspc_tbl_ [1,725 × 10] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ recordID        : chr [1:1725] \"00168ca6-84d0-4af1-8fa8-875fd69d25da\" \"00250163-ec50-4eda-a5d5-58ae98bc5834\" \"003e0f63-9f95-4af9-b272-10db6d7b6371\" \"00410554-5289-416f-9848-74df4a814b93\" ...\n $ scientificName  : chr [1:1725] \"Litoria raniformis\" \"Litoria raniformis\" \"Litoria ewingii\" \"Litoria ewingii\" ...\n $ taxonConceptID  : chr [1:1725] \"https://biodiversity.org.au/afd/taxa/89a7a289-bf04-40e0-aaef-7ec6bc968a9c\" \"https://biodiversity.org.au/afd/taxa/89a7a289-bf04-40e0-aaef-7ec6bc968a9c\" \"https://biodiversity.org.au/afd/taxa/1c89eedb-42b6-4675-b688-2e0b59ea689e\" \"https://biodiversity.org.au/afd/taxa/1c89eedb-42b6-4675-b688-2e0b59ea689e\" ...\n $ decimalLatitude : num [1:1725] -41.2 -41.2 -42.9 -41.7 -43.1 ...\n $ decimalLongitude: num [1:1725] 146 147 148 147 147 ...\n $ eventDate       : POSIXct[1:1725], format: \"2023-12-20 23:20:19\" \"2023-08-23 01:49:28\" ...\n $ occurrenceStatus: chr [1:1725] \"PRESENT\" \"PRESENT\" \"PRESENT\" \"PRESENT\" ...\n $ dataResourceName: chr [1:1725] \"iNaturalist Australia\" \"iNaturalist Australia\" \"iNaturalist Australia\" \"FrogID\" ...\n $ genus           : chr [1:1725] \"Litoria\" \"Litoria\" \"Litoria\" \"Litoria\" ...\n $ species         : chr [1:1725] \"Litoria raniformis\" \"Litoria raniformis\" \"Litoria ewingii\" \"Litoria ewingii\" ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   recordID = col_character(),\n  ..   scientificName = col_character(),\n  ..   taxonConceptID = col_character(),\n  ..   decimalLatitude = col_double(),\n  ..   decimalLongitude = col_double(),\n  ..   eventDate = col_datetime(format = \"\"),\n  ..   occurrenceStatus = col_character(),\n  ..   dataResourceName = col_character(),\n  ..   genus = col_character(),\n  ..   species = col_character()\n  .. )\n - attr(*, \"problems\")=&lt;externalptr&gt; \n - attr(*, \"search_url\")= chr \"https://biocache.ala.org.au/occurrences/search?&q=*%3A*&fq=%28lsid%3A%22https%3A%2F%2Fbiodiversity.org.au%2Fafd\"| __truncated__\n\n\n\n\nThe skim() function groups columns by their type/class.\n\nlibrary(skimr)\n\nskim(frogs)\n\n\nData summary\n\n\nName\nfrogs\n\n\nNumber of rows\n1725\n\n\nNumber of columns\n10\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n7\n\n\nnumeric\n2\n\n\nPOSIXct\n1\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\nrecordID\n0\n1\n36\n36\n0\n1725\n0\n\n\nscientificName\n0\n1\n7\n18\n0\n5\n0\n\n\ntaxonConceptID\n0\n1\n73\n73\n0\n5\n0\n\n\noccurrenceStatus\n0\n1\n7\n7\n0\n1\n0\n\n\ndataResourceName\n0\n1\n6\n27\n0\n3\n0\n\n\ngenus\n0\n1\n7\n7\n0\n1\n0\n\n\nspecies\n1\n1\n15\n18\n0\n4\n0\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\ndecimalLatitude\n0\n1\n-42.11\n0.87\n-43.49\n-42.95\n-41.86\n-41.31\n-39.71\n▇▁▆▃▁\n\n\ndecimalLongitude\n0\n1\n147.01\n0.69\n143.84\n146.92\n147.14\n147.34\n148.30\n▁▁▁▇▂\n\n\n\nVariable type: POSIXct\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nmedian\nn_unique\n\n\n\n\neventDate\n0\n1\n2020-01-02\n2024-02-24 01:21:02\n2021-03-26\n857\n\n\n\n\n\n\n\nYou can return the class of every column using sapply() from base R.\n\nsapply(frogs, class)\n\n$recordID\n[1] \"character\"\n\n$scientificName\n[1] \"character\"\n\n$taxonConceptID\n[1] \"character\"\n\n$decimalLatitude\n[1] \"numeric\"\n\n$decimalLongitude\n[1] \"numeric\"\n\n$eventDate\n[1] \"POSIXct\" \"POSIXt\" \n\n$occurrenceStatus\n[1] \"character\"\n\n$dataResourceName\n[1] \"character\"\n\n$genus\n[1] \"character\"\n\n$species\n[1] \"character\"\n\n\n\n\nYou can return the class of every column using map() from the purrr package.\n\nlibrary(purrr)\n\nfrogs |&gt;\n  purrr::map(class)\n\n$recordID\n[1] \"character\"\n\n$scientificName\n[1] \"character\"\n\n$taxonConceptID\n[1] \"character\"\n\n$decimalLatitude\n[1] \"numeric\"\n\n$decimalLongitude\n[1] \"numeric\"\n\n$eventDate\n[1] \"POSIXct\" \"POSIXt\" \n\n$occurrenceStatus\n[1] \"character\"\n\n$dataResourceName\n[1] \"character\"\n\n$genus\n[1] \"character\"\n\n$species\n[1] \"character\"\n\n\n\n\n\nIf you are using a tibble(), the class is also displayed below each column name when you view your dataframe.\n\nfrogs\n\n# A tibble: 1,725 × 10\n   recordID       scientificName taxonConceptID decimalLatitude decimalLongitude\n   &lt;chr&gt;          &lt;chr&gt;          &lt;chr&gt;                    &lt;dbl&gt;            &lt;dbl&gt;\n 1 00168ca6-84d0… Litoria ranif… https://biodi…           -41.2             146.\n 2 00250163-ec50… Litoria ranif… https://biodi…           -41.2             147.\n 3 003e0f63-9f95… Litoria ewing… https://biodi…           -42.9             148.\n 4 00410554-5289… Litoria ewing… https://biodi…           -41.7             147.\n 5 0070521f-bb45… Litoria ewing… https://biodi…           -43.1             147.\n 6 0081e7ef-459b… Litoria ewing… https://biodi…           -43.2             147.\n 7 0086def1-8415… Litoria ewing… https://biodi…           -41.2             147.\n 8 00b40ee7-074b… Litoria ewing… https://biodi…           -41.5             147.\n 9 014584b3-5fc7… Litoria ewing… https://biodi…           -41.0             145.\n10 0160369c-f2f6… Litoria ewing… https://biodi…           -42.8             148.\n# ℹ 1,715 more rows\n# ℹ 5 more variables: eventDate &lt;dttm&gt;, occurrenceStatus &lt;chr&gt;,\n#   dataResourceName &lt;chr&gt;, genus &lt;chr&gt;, species &lt;chr&gt;\n\n\nLet’s breakdown what we can learn about our class types:\n\nColumns like scientificName are are text strings of type character\nColumns like decimalLatitude and decimalLongitude are decimal numbers of type numeric\nThe eventDate column contains a date + time and is of type POSIXct/dttm\nColumns like recordID and taxonConceptID contain both characters and numbers, but are of type character because this type prevents any loss of data1.\n\nThe important point to takeaway: Our columns’ type classes are what we expect given their data. This isn’t always the case.\nIf we change just one of the values in decimalLatitude to a “degrees minutes seconds” format, R will change the entire column’s class to character to prevent any loss of data.\n\n# duplicate data\nfrogs_class &lt;- frogs\n\n# check class\nclass(frogs_class$decimalLatitude)\n\n[1] \"numeric\"\n\n# change one of the values to a degrees minutes seconds format\nfrogs_class$decimalLatitude[5] &lt;- \"40° 51' 59 N\"\n\n# check class\nclass(frogs_class$decimalLatitude)\n\n[1] \"character\"\n\n\nA simple typo in the raw data or spreadsheet you load into R could be all it takes to change the type class of an entire column. Be sure to keep your eyes out for strange column classes!",
    "crumbs": [
      "General data cleaning",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Column classes & names</span>"
    ]
  },
  {
    "objectID": "2_cleaning_general/column-names-and-classes.html#column-names",
    "href": "2_cleaning_general/column-names-and-classes.html#column-names",
    "title": "4  Column classes & names",
    "section": "4.2 Column names",
    "text": "4.2 Column names\nThere are many reasons why you might need to change the name of one or more columns in a dataset. Let’s look at a few of the more common tasks when cleaning ecological data.\n\n4.2.1 Make column names consistent\nColumn names should use consistent naming conventions. Common naming formats include “snake case” and “camel case”. These naming formats are popular because they are readable and easy to work with in code.\nCamel case uses a lowercase first letter, then capitalises every word after.\n\n\n[1] \"scientificName\"   \"dataResourceName\" \"eventDate\"       \n\n\nSnake case uses entirely lowercase names, separating words using an underscore (_).\n\n\n[1] \"scientific_name\"    \"data_resource_name\" \"event_date\"        \n\n\nData downloaded from the ALA uses camel case2.\n\ncolnames(frogs)\n\n [1] \"recordID\"         \"scientificName\"   \"taxonConceptID\"   \"decimalLatitude\" \n [5] \"decimalLongitude\" \"eventDate\"        \"occurrenceStatus\" \"dataResourceName\"\n [9] \"genus\"            \"species\"         \n\n\nHowever, R is case sensitive. If two names have exactly the same letters but different capitalisation, R considers them different names entirely. To help avoid mistakes caused by capitalisation, it is more popular to use snake case in R. This is also the column name convention we recommend.\nOne of the most useful column name cleaning functions is clean_names() from the janitor package. This function can read in any column names and convert them to snake case if possible.\n\nlibrary(janitor)\n\nfrogs_clean &lt;- frogs |&gt;\n  clean_names() |&gt;\n  colnames()\nfrogs_clean\n\n [1] \"record_id\"          \"scientific_name\"    \"taxon_concept_id\"  \n [4] \"decimal_latitude\"   \"decimal_longitude\"  \"event_date\"        \n [7] \"occurrence_status\"  \"data_resource_name\" \"genus\"             \n[10] \"species\"           \n\n\n\n\n4.2.2 Rename columns\nRenaming columns is a frequent data cleaning task. Column names might need renaming to make it clearer what data they contain, or to make a name consistent with another dataset prior to merging their contents together.\nThere are several ways to rename columns in R.\n\nrename()names() + &lt;-\n\n\nrename() (from dplyr) provides an easy way to rename one or more columns.\n\nfrogs |&gt;\n  select(decimalLatitude, decimalLongitude) |&gt;\n  rename(latitude = decimalLatitude,\n         longitude = decimalLongitude)\n\n# A tibble: 1,725 × 2\n   latitude longitude\n      &lt;dbl&gt;     &lt;dbl&gt;\n 1    -41.2      146.\n 2    -41.2      147.\n 3    -42.9      148.\n 4    -41.7      147.\n 5    -43.1      147.\n 6    -43.2      147.\n 7    -41.2      147.\n 8    -41.5      147.\n 9    -41.0      145.\n10    -42.8      148.\n# ℹ 1,715 more rows\n\n\nrename_with() is a more powerful verion of rename(). It allows more advanced renaming by using functions to rename matching columns.\n\nfrogs |&gt;\n  rename_with(toupper, starts_with(\"decimal\"))\n\n# A tibble: 1,725 × 10\n   recordID       scientificName taxonConceptID DECIMALLATITUDE DECIMALLONGITUDE\n   &lt;chr&gt;          &lt;chr&gt;          &lt;chr&gt;                    &lt;dbl&gt;            &lt;dbl&gt;\n 1 00168ca6-84d0… Litoria ranif… https://biodi…           -41.2             146.\n 2 00250163-ec50… Litoria ranif… https://biodi…           -41.2             147.\n 3 003e0f63-9f95… Litoria ewing… https://biodi…           -42.9             148.\n 4 00410554-5289… Litoria ewing… https://biodi…           -41.7             147.\n 5 0070521f-bb45… Litoria ewing… https://biodi…           -43.1             147.\n 6 0081e7ef-459b… Litoria ewing… https://biodi…           -43.2             147.\n 7 0086def1-8415… Litoria ewing… https://biodi…           -41.2             147.\n 8 00b40ee7-074b… Litoria ewing… https://biodi…           -41.5             147.\n 9 014584b3-5fc7… Litoria ewing… https://biodi…           -41.0             145.\n10 0160369c-f2f6… Litoria ewing… https://biodi…           -42.8             148.\n# ℹ 1,715 more rows\n# ℹ 5 more variables: eventDate &lt;dttm&gt;, occurrenceStatus &lt;chr&gt;,\n#   dataResourceName &lt;chr&gt;, genus &lt;chr&gt;, species &lt;chr&gt;\n\nfrogs |&gt;\n  rename_with( ~ tolower(gsub(\"decimal\", \"new_\", .x, fixed = TRUE)))\n\n# A tibble: 1,725 × 10\n   recordid             scientificname taxonconceptid new_latitude new_longitude\n   &lt;chr&gt;                &lt;chr&gt;          &lt;chr&gt;                 &lt;dbl&gt;         &lt;dbl&gt;\n 1 00168ca6-84d0-4af1-… Litoria ranif… https://biodi…        -41.2          146.\n 2 00250163-ec50-4eda-… Litoria ranif… https://biodi…        -41.2          147.\n 3 003e0f63-9f95-4af9-… Litoria ewing… https://biodi…        -42.9          148.\n 4 00410554-5289-416f-… Litoria ewing… https://biodi…        -41.7          147.\n 5 0070521f-bb45-46fb-… Litoria ewing… https://biodi…        -43.1          147.\n 6 0081e7ef-459b-42a9-… Litoria ewing… https://biodi…        -43.2          147.\n 7 0086def1-8415-4bb3-… Litoria ewing… https://biodi…        -41.2          147.\n 8 00b40ee7-074b-4dae-… Litoria ewing… https://biodi…        -41.5          147.\n 9 014584b3-5fc7-43df-… Litoria ewing… https://biodi…        -41.0          145.\n10 0160369c-f2f6-48a1-… Litoria ewing… https://biodi…        -42.8          148.\n# ℹ 1,715 more rows\n# ℹ 5 more variables: eventdate &lt;dttm&gt;, occurrencestatus &lt;chr&gt;,\n#   dataresourcename &lt;chr&gt;, genus &lt;chr&gt;, species &lt;chr&gt;\n\n\n\n\nIndex a specific column name in base R with the help of names(). Assign a new column name to replace an old column name using the assign operator &lt;-.\n\nnames(frogs)[names(frogs) == \"decimalLatitude\"] &lt;- \"latitude\"\nnames(frogs)[names(frogs) == \"decimalLongitude\"] &lt;- \"longitude\"\n\nfrogs[,c(\"latitude\", \"longitude\")]\n\n# A tibble: 1,725 × 2\n   latitude longitude\n      &lt;dbl&gt;     &lt;dbl&gt;\n 1    -41.2      146.\n 2    -41.2      147.\n 3    -42.9      148.\n 4    -41.7      147.\n 5    -43.1      147.\n 6    -43.2      147.\n 7    -41.2      147.\n 8    -41.5      147.\n 9    -41.0      145.\n10    -42.8      148.\n# ℹ 1,715 more rows\n\n\n\n\n\n\n\n4.2.3 Separate columns\nSometimes it is useful to split information in one column into several columns. One good example is if genus and species names are held within one column like scientificName. Let’s separate these names into two columns using separate() from the tidyr package.\n\nlibrary(tidyr)\n\nfrogs_separate &lt;- frogs |&gt;\n  separate(scientificName, \n           c(\"genus\", \"species\"), # new column names\n           fill = \"right\",        # fill missing values in right column\n           remove = FALSE         # keep input column\n           ) |&gt; \n  select(scientificName, genus, species)\nfrogs_separate\n\n# A tibble: 1,725 × 3\n   scientificName     genus   species   \n   &lt;chr&gt;              &lt;chr&gt;   &lt;chr&gt;     \n 1 Litoria raniformis Litoria raniformis\n 2 Litoria raniformis Litoria raniformis\n 3 Litoria ewingii    Litoria ewingii   \n 4 Litoria ewingii    Litoria ewingii   \n 5 Litoria ewingii    Litoria ewingii   \n 6 Litoria ewingii    Litoria ewingii   \n 7 Litoria ewingii    Litoria ewingii   \n 8 Litoria ewingii    Litoria ewingii   \n 9 Litoria ewingii    Litoria ewingii   \n10 Litoria ewingii    Litoria ewingii   \n# ℹ 1,715 more rows\n\n\n\n\n4.2.4 Join columns\nAlternatively, it is useful to join information in multiple columns. One good example is to create label names when genus and species names are in separate columns. Let’s rejoin the genus and species columns we created in the previous section using unite() from the tidyr package.\n\nfrogs_separate |&gt;\n  unite(\"single_name\", \n        genus:species, # select columns to join\n        sep = \" \",     # separate with a space\n        na.rm = TRUE,  # remove NA values\n        remove = FALSE # keep input column\n        ) |&gt;\n  select(genus, species, single_name)\n\n# A tibble: 1,725 × 3\n   genus   species    single_name       \n   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;             \n 1 Litoria raniformis Litoria raniformis\n 2 Litoria raniformis Litoria raniformis\n 3 Litoria ewingii    Litoria ewingii   \n 4 Litoria ewingii    Litoria ewingii   \n 5 Litoria ewingii    Litoria ewingii   \n 6 Litoria ewingii    Litoria ewingii   \n 7 Litoria ewingii    Litoria ewingii   \n 8 Litoria ewingii    Litoria ewingii   \n 9 Litoria ewingii    Litoria ewingii   \n10 Litoria ewingii    Litoria ewingii   \n# ℹ 1,715 more rows",
    "crumbs": [
      "General data cleaning",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Column classes & names</span>"
    ]
  },
  {
    "objectID": "2_cleaning_general/column-names-and-classes.html#summary",
    "href": "2_cleaning_general/column-names-and-classes.html#summary",
    "title": "4  Column classes & names",
    "section": "4.3 Summary",
    "text": "4.3 Summary\nIn this chapter, we provided some ways to check the data types/classes of your data set’s columns, and showed how to rename or edit columns.\nIn the next chapter we will learn to xxx…",
    "crumbs": [
      "General data cleaning",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Column classes & names</span>"
    ]
  },
  {
    "objectID": "2_cleaning_general/column-names-and-classes.html#footnotes",
    "href": "2_cleaning_general/column-names-and-classes.html#footnotes",
    "title": "4  Column classes & names",
    "section": "",
    "text": "To avoid conflicts, R has an internal coercion hierarchy rule to avoid data loss. The rule of thumb is that if a data type can’t exist in a child data type, then the parent data type is used instead. The R coercion hierarchy is: logical -&gt; integer -&gt; numeric -&gt; complex -&gt; characterYou don’t need to memorise this, but it’s worth being aware of this hierarchy, as R might make decisions to prevent a class error and you might not know why! Learn more in this article.↩︎\nThis is because queries to the ALA use other coding languages, namely solr and JSON, and the column names in these languages are typically written in camel case. To maintain consistency with what’s on the ALA and to avoid hidden name cleaning, galah chooses to return camel case names, too.↩︎",
    "crumbs": [
      "General data cleaning",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Column classes & names</span>"
    ]
  },
  {
    "objectID": "2_cleaning_general/duplicates.html",
    "href": "2_cleaning_general/duplicates.html",
    "title": "5  Duplicates",
    "section": "",
    "text": "5.0.1 Prerequisites\n# packages\nlibrary(galah)\nlibrary(dplyr)\nlibrary(janitor)\n\n# data: Kingfisher records from 2023\ngalah_config(email = \"your-email-here\") # ALA Registered email\n\nbirds &lt;- galah_call() |&gt;\n  identify(\"alcedinidae\") |&gt;\n  filter(year == 2023) |&gt;\n  select(group = \"basic\", \n         family, genus, species, cl22, eventDate, month) |&gt;\n  atlas_occurrences()",
    "crumbs": [
      "General data cleaning",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Duplicates</span>"
    ]
  },
  {
    "objectID": "2_cleaning_general/duplicates.html#find-duplicates",
    "href": "2_cleaning_general/duplicates.html#find-duplicates",
    "title": "5  Duplicates",
    "section": "5.1 Find duplicates",
    "text": "5.1 Find duplicates\nLet’s remove any records that have multiple occurrences on the same location, specified by their latitude and longitude coordinates.\nThe first thing to do is find the duplicate records.\n\ndplyrjanitor\n\n\nReturn the number of duplicates with each set of coordinates.\n\nbirds |&gt; \n  group_by(decimalLongitude, decimalLatitude) |&gt;\n  filter(n() &gt; 1) |&gt;\n  summarise(n = n())\n\n`summarise()` has grouped output by 'decimalLongitude'. You can override using\nthe `.groups` argument.\n\n\n# A tibble: 5,105 × 3\n# Groups:   decimalLongitude [5,087]\n   decimalLongitude decimalLatitude     n\n              &lt;dbl&gt;           &lt;dbl&gt; &lt;int&gt;\n 1             115.           -34.1     2\n 2             115.           -33.8     2\n 3             115.           -33.7     2\n 4             115.           -33.6     2\n 5             115.           -34.0     2\n 6             115.           -33.9    12\n 7             115.           -33.9     2\n 8             115.           -33.6     2\n 9             115.           -33.6     2\n10             115.           -33.6     2\n# ℹ 5,095 more rows\n\n\nReturn duplicated rows.\n\nbirds |&gt;\n  filter(duplicated(decimalLongitude) & duplicated(decimalLatitude))\n\n# A tibble: 27,051 × 13\n   recordID       scientificName taxonConceptID decimalLatitude decimalLongitude\n   &lt;chr&gt;          &lt;chr&gt;          &lt;chr&gt;                    &lt;dbl&gt;            &lt;dbl&gt;\n 1 0036fdd3-947e… Todiramphus (… https://biodi…           -35.3             149.\n 2 006cea57-9ec8… Dacelo (Dacel… https://biodi…           -33.9             151.\n 3 007a75a3-aba2… Dacelo (Dacel… https://biodi…           -27.5             153.\n 4 007b39cf-2660… Todiramphus (… https://biodi…           -27.4             153.\n 5 0090348a-41bb… Todiramphus (… https://biodi…           -27.4             153.\n 6 009dd9a8-e12b… Todiramphus (… https://biodi…           -27.4             153.\n 7 00bde3fa-6095… Dacelo (Dacel… https://biodi…           -19.4             147.\n 8 00e8c718-f305… Dacelo (Dacel… https://biodi…           -31.7             116.\n 9 00fe93fc-86b9… Dacelo (Dacel… https://biodi…           -27.4             153.\n10 01006006-78b2… Todiramphus (… https://biodi…           -19.2             147.\n# ℹ 27,041 more rows\n# ℹ 8 more variables: eventDate &lt;dttm&gt;, occurrenceStatus &lt;chr&gt;,\n#   dataResourceName &lt;chr&gt;, family &lt;chr&gt;, genus &lt;chr&gt;, species &lt;chr&gt;,\n#   cl22 &lt;chr&gt;, month &lt;dbl&gt;\n\n\n\n\n\n\nReturn duplicated rows and the number of duplicates of decimalLatitude OR decimalLongitude (note that this differs from the dplyr example).\n\nbirds |&gt; \n  get_dupes(decimalLatitude, decimalLongitude)\n\n# A tibble: 32,130 × 14\n   decimalLatitude decimalLongitude dupe_count recordID           scientificName\n             &lt;dbl&gt;            &lt;dbl&gt;      &lt;int&gt; &lt;chr&gt;              &lt;chr&gt;         \n 1           -27.4             153.        686 00018120-2238-412… Dacelo (Dacel…\n 2           -27.4             153.        686 007b39cf-2660-415… Todiramphus (…\n 3           -27.4             153.        686 0090348a-41bb-4f3… Todiramphus (…\n 4           -27.4             153.        686 009dd9a8-e12b-45d… Todiramphus (…\n 5           -27.4             153.        686 00fe93fc-86b9-4cd… Dacelo (Dacel…\n 6           -27.4             153.        686 017e052c-dd85-43d… Todiramphus (…\n 7           -27.4             153.        686 01bda731-b532-43c… Dacelo (Dacel…\n 8           -27.4             153.        686 023f2c30-93a9-4d6… Dacelo (Dacel…\n 9           -27.4             153.        686 03d44a01-7863-469… Todiramphus (…\n10           -27.4             153.        686 03dee6d8-4ae9-46a… Todiramphus (…\n# ℹ 32,120 more rows\n# ℹ 9 more variables: taxonConceptID &lt;chr&gt;, eventDate &lt;dttm&gt;,\n#   occurrenceStatus &lt;chr&gt;, dataResourceName &lt;chr&gt;, family &lt;chr&gt;, genus &lt;chr&gt;,\n#   species &lt;chr&gt;, cl22 &lt;chr&gt;, month &lt;dbl&gt;\n\n\n\n\n\nOur results show that there are more than 27,000 records that overlap!\nWe want to remove duplicate records, but we don’t necessarily want to remove all duplicates. Our dataset contains several different species, and sometimes several species might be in the same location. Rather than removing all but one species in a location, we probably want to remove duplicates for each species. This should leave one observation for each species in each location.\nTo filter our duplicates by species, we can first split our data by species…\n\nbirds |&gt;\n  group_split(species)\n\n\n\n&lt;list_of&lt;\n  tbl_df&lt;\n    recordID        : character\n    scientificName  : character\n    taxonConceptID  : character\n    decimalLatitude : double\n    decimalLongitude: double\n    eventDate       : datetime&lt;UTC&gt;\n    occurrenceStatus: character\n    dataResourceName: character\n    family          : character\n    genus           : character\n    species         : character\n    cl22            : character\n    month           : double\n  &gt;\n&gt;[11]&gt;\n[[1]]\n# A tibble: 1,940 × 13\n   recordID       scientificName taxonConceptID decimalLatitude decimalLongitude\n   &lt;chr&gt;          &lt;chr&gt;          &lt;chr&gt;                    &lt;dbl&gt;            &lt;dbl&gt;\n 1 0007f679-255f… Ceyx azureus   https://biodi…           -35.3             149.\n 2 00237f72-7b95… Ceyx azureus   https://biodi…           -33.6             151.\n 3 002d4683-fdeb… Ceyx azureus   https://biodi…           -22.8             151.\n 4 0030b417-ad83… Ceyx azureus   https://biodi…           -23.5             151.\n 5 005c21b0-3066… Ceyx azureus   https://biodi…           -16.2             145.\n 6 00671765-ed23… Ceyx azureus   https://biodi…           -36.1             145.\n 7 0086cd20-926a… Ceyx azureus   https://biodi…           -35.6             150.\n 8 00a39798-5118… Ceyx azureus   https://biodi…           -17.1             146.\n 9 00c02d79-58ef… Ceyx azureus   https://biodi…           -16.2             145.\n10 012140cd-fac0… Ceyx azureus   https://biodi…           -33.7             151.\n# ℹ 1,930 more rows\n# ℹ 8 more variables: eventDate &lt;dttm&gt;, occurrenceStatus &lt;chr&gt;,\n#   dataResourceName &lt;chr&gt;, family &lt;chr&gt;, genus &lt;chr&gt;, species &lt;chr&gt;,\n#   cl22 &lt;chr&gt;, month &lt;dbl&gt;\n\n[[2]]\n# A tibble: 197 × 13\n   recordID       scientificName taxonConceptID decimalLatitude decimalLongitude\n   &lt;chr&gt;          &lt;chr&gt;          &lt;chr&gt;                    &lt;dbl&gt;            &lt;dbl&gt;\n 1 00b3fbaf-20d1… Ceyx pusillus  https://biodi…           -12.3             131.\n 2 02ec2065-820c… Ceyx pusillus  https://biodi…           -12.4             131.\n 3 02f2b1e9-f706… Ceyx pusillus  https://biodi…           -16.9             146.\n 4 030dd9ae-3f67… Ceyx pusillus  https://biodi…           -12.4             131.\n 5 03a15b6a-b666… Ceyx pusillus  https://biodi…           -16.9             146.\n 6 04c838f4-8641… Ceyx pusillus  https://biodi…           -12.4             131.\n 7 058ef10d-247b… Ceyx pusillus  https://biodi…           -12.6             131.\n 8 078b046a-9cf3… Ceyx pusillus  https://biodi…           -12.8             143.\n 9 0791d280-a26c… Ceyx pusillus  https://biodi…           -12.4             131.\n10 0843ea42-367f… Ceyx pusillus  https://biodi…           -16.1             145.\n# ℹ 187 more rows\n# ℹ 8 more variables: eventDate &lt;dttm&gt;, occurrenceStatus &lt;chr&gt;,\n#   dataResourceName &lt;chr&gt;, family &lt;chr&gt;, genus &lt;chr&gt;, species &lt;chr&gt;,\n#   cl22 &lt;chr&gt;, month &lt;dbl&gt;\n\n[[3]]\n# A tibble: 1,373 × 13\n   recordID       scientificName taxonConceptID decimalLatitude decimalLongitude\n   &lt;chr&gt;          &lt;chr&gt;          &lt;chr&gt;                    &lt;dbl&gt;            &lt;dbl&gt;\n 1 00085f92-58d1… Dacelo (Dacel… https://biodi…           -14.2             132.\n 2 005e94f6-d0d7… Dacelo (Dacel… https://biodi…           -12.7             143.\n 3 0083fbfd-3f14… Dacelo (Dacel… https://biodi…           -17.5             141.\n 4 00bd28e3-20aa… Dacelo (Dacel… https://biodi…           -13.4             132.\n 5 00bde3fa-6095… Dacelo (Dacel… https://biodi…           -19.4             147.\n 6 00c8ff2c-9282… Dacelo (Dacel… https://biodi…           -16.7             146.\n 7 01462284-b0aa… Dacelo (Dacel… https://biodi…           -12.4             131.\n 8 01db4718-55f5… Dacelo (Dacel… https://biodi…           -16.5             145.\n 9 0268d927-927e… Dacelo (Dacel… https://biodi…           -14.5             132.\n10 02712b54-8b8f… Dacelo (Dacel… https://biodi…           -19.4             147.\n# ℹ 1,363 more rows\n# ℹ 8 more variables: eventDate &lt;dttm&gt;, occurrenceStatus &lt;chr&gt;,\n#   dataResourceName &lt;chr&gt;, family &lt;chr&gt;, genus &lt;chr&gt;, species &lt;chr&gt;,\n#   cl22 &lt;chr&gt;, month &lt;dbl&gt;\n\n[[4]]\n# A tibble: 26,627 × 13\n   recordID       scientificName taxonConceptID decimalLatitude decimalLongitude\n   &lt;chr&gt;          &lt;chr&gt;          &lt;chr&gt;                    &lt;dbl&gt;            &lt;dbl&gt;\n 1 00018120-2238… Dacelo (Dacel… https://biodi…           -27.4             153.\n 2 0005aa70-a30f… Dacelo (Dacel… https://biodi…           -25.3             153.\n 3 0006ff02-853a… Dacelo (Dacel… https://biodi…           -37.9             145.\n 4 00076c8d-957e… Dacelo (Dacel… https://biodi…           -28.0             153.\n 5 00080e38-ee2d… Dacelo (Dacel… https://biodi…           -33.1             150.\n 6 000c7c7c-3603… Dacelo (Dacel… https://biodi…           -38.5             144.\n 7 000f692d-8013… Dacelo (Dacel… https://biodi…           -19.3             147.\n 8 000f87c2-9028… Dacelo (Dacel… https://biodi…           -35.3             149.\n 9 0010012d-435e… Dacelo (Dacel… https://biodi…           -16.8             146.\n10 001021bd-b8f1… Dacelo (Dacel… https://biodi…           -27.5             153.\n# ℹ 26,617 more rows\n# ℹ 8 more variables: eventDate &lt;dttm&gt;, occurrenceStatus &lt;chr&gt;,\n#   dataResourceName &lt;chr&gt;, family &lt;chr&gt;, genus &lt;chr&gt;, species &lt;chr&gt;,\n#   cl22 &lt;chr&gt;, month &lt;dbl&gt;\n\n[[5]]\n# A tibble: 155 × 13\n   recordID       scientificName taxonConceptID decimalLatitude decimalLongitude\n   &lt;chr&gt;          &lt;chr&gt;          &lt;chr&gt;                    &lt;dbl&gt;            &lt;dbl&gt;\n 1 0120314d-38b4… Syma torotoro  https://biodi…           -12.6             143.\n 2 04b2e915-4419… Syma torotoro  https://biodi…           -12.8             143.\n 3 04d3acf0-acdb… Syma torotoro  https://biodi…           -12.7             143.\n 4 0bf14fe4-01fc… Syma torotoro  https://biodi…           -12.7             143.\n 5 0c0a3bc9-431f… Syma torotoro  https://biodi…           -12.7             143.\n 6 0e428bdf-d6fb… Syma torotoro  https://biodi…           -10.8             142.\n 7 0f29d245-adc8… Syma torotoro  https://biodi…           -12.6             143.\n 8 0ff604e2-fbe3… Syma torotoro  https://biodi…           -10.8             142.\n 9 1121aa01-3173… Syma torotoro  https://biodi…           -12.8             143.\n10 131d66ad-46d8… Syma torotoro  https://biodi…           -12.8             143.\n# ℹ 145 more rows\n# ℹ 8 more variables: eventDate &lt;dttm&gt;, occurrenceStatus &lt;chr&gt;,\n#   dataResourceName &lt;chr&gt;, family &lt;chr&gt;, genus &lt;chr&gt;, species &lt;chr&gt;,\n#   cl22 &lt;chr&gt;, month &lt;dbl&gt;\n\n[[6]]\n# A tibble: 566 × 13\n   recordID       scientificName taxonConceptID decimalLatitude decimalLongitude\n   &lt;chr&gt;          &lt;chr&gt;          &lt;chr&gt;                    &lt;dbl&gt;            &lt;dbl&gt;\n 1 004c61ec-ed26… Tanysiptera (… https://biodi…           -16.6             145.\n 2 014b3666-a322… Tanysiptera (… https://biodi…           -16.6             145.\n 3 0152bed4-9459… Tanysiptera (… https://biodi…           -12.8             143.\n 4 01685613-fe2f… Tanysiptera (… https://biodi…           -12.7             143.\n 5 019804dd-c3fc… Tanysiptera (… https://biodi…           -16.6             145.\n 6 02a51caa-861f… Tanysiptera (… https://biodi…           -12.7             143.\n 7 02f21d71-27c2… Tanysiptera (… https://biodi…           -10.8             142.\n 8 02f96918-b627… Tanysiptera (… https://biodi…           -12.7             143.\n 9 044df2a6-7d32… Tanysiptera (… https://biodi…           -16.2             145.\n10 04baf9c0-fd82… Tanysiptera (… https://biodi…           -16.6             145.\n# ℹ 556 more rows\n# ℹ 8 more variables: eventDate &lt;dttm&gt;, occurrenceStatus &lt;chr&gt;,\n#   dataResourceName &lt;chr&gt;, family &lt;chr&gt;, genus &lt;chr&gt;, species &lt;chr&gt;,\n#   cl22 &lt;chr&gt;, month &lt;dbl&gt;\n\n[[7]]\n# A tibble: 12 × 13\n   recordID       scientificName taxonConceptID decimalLatitude decimalLongitude\n   &lt;chr&gt;          &lt;chr&gt;          &lt;chr&gt;                    &lt;dbl&gt;            &lt;dbl&gt;\n 1 3aa845a0-902e… Todiramphus (… https://biodi…            1.32             104.\n 2 5f59e40a-87d2… Todiramphus (… https://biodi…            1.28             104.\n 3 789e7794-af27… Todiramphus (… https://biodi…            1.32             104.\n 4 7c6e2ffa-73a8… Todiramphus (… https://biodi…          -28.2              154.\n 5 806d0434-8d8f… Todiramphus (… https://biodi…            1.28             104.\n 6 83d392d7-a15f… Todiramphus (… https://biodi…            1.28             104.\n 7 85bd0100-ea5d… Todiramphus (… https://biodi…            1.28             104.\n 8 aeda1763-cd85… Todiramphus (… https://biodi…            1.28             104.\n 9 dac72d12-bf2c… Todiramphus (… https://biodi…            1.28             104.\n10 e156dd38-95f5… Todiramphus (… https://biodi…            1.28             104.\n11 e5574549-7cec… Todiramphus (… https://biodi…            1.28             104.\n12 fd6435b4-32d6… Todiramphus (… https://biodi…            1.31             104.\n# ℹ 8 more variables: eventDate &lt;dttm&gt;, occurrenceStatus &lt;chr&gt;,\n#   dataResourceName &lt;chr&gt;, family &lt;chr&gt;, genus &lt;chr&gt;, species &lt;chr&gt;,\n#   cl22 &lt;chr&gt;, month &lt;dbl&gt;\n\n[[8]]\n# A tibble: 2,336 × 13\n   recordID       scientificName taxonConceptID decimalLatitude decimalLongitude\n   &lt;chr&gt;          &lt;chr&gt;          &lt;chr&gt;                    &lt;dbl&gt;            &lt;dbl&gt;\n 1 0024aef4-4a8b… Todiramphus (… https://biodi…           -19.4             147.\n 2 004b8b6c-8a89… Todiramphus (… https://biodi…           -12.4             131.\n 3 007b39cf-2660… Todiramphus (… https://biodi…           -27.4             153.\n 4 00993728-10d2… Todiramphus (… https://biodi…           -27.1             153.\n 5 009e7664-1b3e… Todiramphus (… https://biodi…           -27.4             153.\n 6 00b1c419-0612… Todiramphus (… https://biodi…           -26.2             153.\n 7 00cdcbdf-36a6… Todiramphus (… https://biodi…           -12.5             131.\n 8 00deabe0-1d59… Todiramphus (… https://biodi…           -12.3             131.\n 9 0120a6ea-66f1… Todiramphus (… https://biodi…           -30.4             153.\n10 012e4a46-ead1… Todiramphus (… https://biodi…           -20.0             146.\n# ℹ 2,326 more rows\n# ℹ 8 more variables: eventDate &lt;dttm&gt;, occurrenceStatus &lt;chr&gt;,\n#   dataResourceName &lt;chr&gt;, family &lt;chr&gt;, genus &lt;chr&gt;, species &lt;chr&gt;,\n#   cl22 &lt;chr&gt;, month &lt;dbl&gt;\n\n[[9]]\n# A tibble: 289 × 13\n   recordID       scientificName taxonConceptID decimalLatitude decimalLongitude\n   &lt;chr&gt;          &lt;chr&gt;          &lt;chr&gt;                    &lt;dbl&gt;            &lt;dbl&gt;\n 1 001c48ef-8329… Todiramphus (… https://biodi…           -31.9             142.\n 2 016ec933-df3e… Todiramphus (… https://biodi…           -23.7             134.\n 3 01833f43-b3d5… Todiramphus (… https://biodi…           -28.0             146.\n 4 01e0d185-50ed… Todiramphus (… https://biodi…           -29.8             151.\n 5 02d54da5-cfb0… Todiramphus (… https://biodi…           -19.0             146.\n 6 033bf94d-cd11… Todiramphus (… https://biodi…           -20.0             140.\n 7 06d7a1fc-9464… Todiramphus (… https://biodi…           -23.5             144.\n 8 06e22048-0569… Todiramphus (… https://biodi…           -18.3             143.\n 9 07fc074c-fff9… Todiramphus (… https://biodi…           -31.9             141.\n10 09e67cf4-3fbf… Todiramphus (… https://biodi…           -17.7             140.\n# ℹ 279 more rows\n# ℹ 8 more variables: eventDate &lt;dttm&gt;, occurrenceStatus &lt;chr&gt;,\n#   dataResourceName &lt;chr&gt;, family &lt;chr&gt;, genus &lt;chr&gt;, species &lt;chr&gt;,\n#   cl22 &lt;chr&gt;, month &lt;dbl&gt;\n\n[[10]]\n# A tibble: 9,575 × 13\n   recordID       scientificName taxonConceptID decimalLatitude decimalLongitude\n   &lt;chr&gt;          &lt;chr&gt;          &lt;chr&gt;                    &lt;dbl&gt;            &lt;dbl&gt;\n 1 00030a7e-a6cc… Todiramphus (… https://biodi…           -35.1             147.\n 2 0005e748-e148… Todiramphus (… https://biodi…           -29.3             149.\n 3 00072b9e-b843… Todiramphus (… https://biodi…           -33.7             151.\n 4 00280b9f-8fc4… Todiramphus (… https://biodi…           -27.5             153.\n 5 002e666e-a69c… Todiramphus (… https://biodi…           -19.2             147.\n 6 002fcf2c-7a6c… Todiramphus (… https://biodi…           -33.1             151.\n 7 003327aa-c684… Todiramphus (… https://biodi…           -36.5             147.\n 8 0036208a-7764… Todiramphus (… https://biodi…           -32.8             117.\n 9 0036fdd3-947e… Todiramphus (… https://biodi…           -35.3             149.\n10 003ba830-1f22… Todiramphus (… https://biodi…           -27.3             153.\n# ℹ 9,565 more rows\n# ℹ 8 more variables: eventDate &lt;dttm&gt;, occurrenceStatus &lt;chr&gt;,\n#   dataResourceName &lt;chr&gt;, family &lt;chr&gt;, genus &lt;chr&gt;, species &lt;chr&gt;,\n#   cl22 &lt;chr&gt;, month &lt;dbl&gt;\n\n[[11]]\n# A tibble: 936 × 13\n   recordID       scientificName taxonConceptID decimalLatitude decimalLongitude\n   &lt;chr&gt;          &lt;chr&gt;          &lt;chr&gt;                    &lt;dbl&gt;            &lt;dbl&gt;\n 1 0034efe7-4a01… Todiramphus    https://biodi…           -27.2             153.\n 2 00478798-95f7… Todiramphus    https://biodi…           -28.2             154.\n 3 0064cb36-4eee… Todiramphus    https://biodi…           -27.5             153.\n 4 00bcefdb-f852… Todiramphus    https://biodi…           -25.6             153.\n 5 00ebd2bb-0c34… Todiramphus    https://biodi…           -27.3             153.\n 6 0116442d-a7f6… Todiramphus    https://biodi…           -16.9             146.\n 7 01d19d01-c721… Todiramphus    https://biodi…           -27.5             153.\n 8 020b9283-447f… Todiramphus    https://biodi…           -16.9             146.\n 9 02511840-3813… Todiramphus    https://biodi…           -16.9             146.\n10 03a9e4bd-37db… Todiramphus    https://biodi…           -25.6             153.\n# ℹ 926 more rows\n# ℹ 8 more variables: eventDate &lt;dttm&gt;, occurrenceStatus &lt;chr&gt;,\n#   dataResourceName &lt;chr&gt;, family &lt;chr&gt;, genus &lt;chr&gt;, species &lt;chr&gt;,\n#   cl22 &lt;chr&gt;, month &lt;dbl&gt;\n\n\n…and use purrr::map()1 to remove duplicates for each species group, binding our dataframes together again with bind_rows().\n\nlibrary(purrr)\n\nbirds |&gt;\n  group_split(species) |&gt;\n  map(\\(df) \n      df |&gt; \n        filter(duplicated(decimalLongitude) & duplicated(decimalLatitude))\n      ) |&gt;\n  bind_rows()\n\n# A tibble: 23,600 × 13\n   recordID       scientificName taxonConceptID decimalLatitude decimalLongitude\n   &lt;chr&gt;          &lt;chr&gt;          &lt;chr&gt;                    &lt;dbl&gt;            &lt;dbl&gt;\n 1 04b5c741-1afb… Ceyx azureus   https://biodi…           -37.8             145.\n 2 06eb5cd7-413f… Ceyx azureus   https://biodi…           -34.5             151.\n 3 083ec28b-68d3… Ceyx azureus   https://biodi…           -26.3             153.\n 4 087d63fc-2505… Ceyx azureus   https://biodi…           -27.5             153.\n 5 0afd32d4-c759… Ceyx azureus   https://biodi…           -37.8             145.\n 6 0b2b6aab-1283… Ceyx azureus   https://biodi…           -28.8             154.\n 7 0b8ea27e-2ca2… Ceyx azureus   https://biodi…           -34.5             151.\n 8 0ba0afc4-1cf2… Ceyx azureus   https://biodi…           -27.3             153.\n 9 0c570ead-3759… Ceyx azureus   https://biodi…           -33.0             151.\n10 0c9f8e48-1c44… Ceyx azureus   https://biodi…           -27.3             153.\n# ℹ 23,590 more rows\n# ℹ 8 more variables: eventDate &lt;dttm&gt;, occurrenceStatus &lt;chr&gt;,\n#   dataResourceName &lt;chr&gt;, family &lt;chr&gt;, genus &lt;chr&gt;, species &lt;chr&gt;,\n#   cl22 &lt;chr&gt;, month &lt;dbl&gt;\n\n\nSplitting by species has reduced the total number of duplicate records by ~3,500 rows.",
    "crumbs": [
      "General data cleaning",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Duplicates</span>"
    ]
  },
  {
    "objectID": "2_cleaning_general/duplicates.html#remove-duplicates",
    "href": "2_cleaning_general/duplicates.html#remove-duplicates",
    "title": "5  Duplicates",
    "section": "5.2 Remove duplicates",
    "text": "5.2 Remove duplicates\nTo remove these duplicates from our dataframe, we can use the ! operator to return records that are not duplicated, rather than those that are.\n\nbirds_filtered &lt;- birds |&gt;\n  group_split(species) |&gt;\n  map(\\(df) \n      df |&gt;\n        filter(!duplicated(decimalLongitude) & !duplicated(decimalLatitude))) |&gt;\n  bind_rows()\nbirds_filtered\n\n# A tibble: 20,205 × 13\n   recordID       scientificName taxonConceptID decimalLatitude decimalLongitude\n   &lt;chr&gt;          &lt;chr&gt;          &lt;chr&gt;                    &lt;dbl&gt;            &lt;dbl&gt;\n 1 0007f679-255f… Ceyx azureus   https://biodi…           -35.3             149.\n 2 00237f72-7b95… Ceyx azureus   https://biodi…           -33.6             151.\n 3 002d4683-fdeb… Ceyx azureus   https://biodi…           -22.8             151.\n 4 0030b417-ad83… Ceyx azureus   https://biodi…           -23.5             151.\n 5 005c21b0-3066… Ceyx azureus   https://biodi…           -16.2             145.\n 6 00671765-ed23… Ceyx azureus   https://biodi…           -36.1             145.\n 7 0086cd20-926a… Ceyx azureus   https://biodi…           -35.6             150.\n 8 00a39798-5118… Ceyx azureus   https://biodi…           -17.1             146.\n 9 00c02d79-58ef… Ceyx azureus   https://biodi…           -16.2             145.\n10 012140cd-fac0… Ceyx azureus   https://biodi…           -33.7             151.\n# ℹ 20,195 more rows\n# ℹ 8 more variables: eventDate &lt;dttm&gt;, occurrenceStatus &lt;chr&gt;,\n#   dataResourceName &lt;chr&gt;, family &lt;chr&gt;, genus &lt;chr&gt;, species &lt;chr&gt;,\n#   cl22 &lt;chr&gt;, month &lt;dbl&gt;\n\n\nTo check our results, we can grab a random row from our unfiltered dataframe…\n\ntest_row &lt;- birds |&gt;\n  filter(duplicated(decimalLongitude) & duplicated(decimalLatitude)) |&gt;\n  slice(10)\n\ntest_row |&gt;\n  select(species, decimalLatitude, decimalLongitude, recordID) # show relevant columns\n\n# A tibble: 1 × 4\n  species             decimalLatitude decimalLongitude recordID                 \n  &lt;chr&gt;                         &lt;dbl&gt;            &lt;dbl&gt; &lt;chr&gt;                    \n1 Todiramphus sanctus           -19.2             147. 01006006-78b2-4d19-bb99-…\n\n\n…and see whether any rows in birds_filtered have the same combination of longitude and latitude coordinates.\n\nbirds_filtered |&gt;\n  filter(\n    decimalLatitude %in% test_row$decimalLatitude & \n      decimalLongitude %in% test_row$decimalLongitude\n    ) |&gt;\n  select(species, decimalLatitude, decimalLongitude, recordID) # show relevant columns\n\n# A tibble: 4 × 4\n  species               decimalLatitude decimalLongitude recordID               \n  &lt;chr&gt;                           &lt;dbl&gt;            &lt;dbl&gt; &lt;chr&gt;                  \n1 Dacelo leachii                  -19.2             147. 0bac3731-116a-4f7b-8b2…\n2 Dacelo novaeguineae             -19.2             147. 161a96bb-e9af-4a6b-ae3…\n3 Todiramphus macleayii           -19.2             147. 0208aa99-b3ce-449a-99d…\n4 Todiramphus sanctus             -19.2             147. 00c3f294-01dd-4f66-b8a…\n\n\nAs expected, there are a few species with those latitude and longitude coordinates, but we now only have 1 row for each species in that location in birds_filtered.\nUsing %in% can be a powerful tool for finding duplicates in your dataframe. Extracting rows like we did above with our test_row example above (or a list of values in a column) can help you weed out more specific duplicate records you are interested in.",
    "crumbs": [
      "General data cleaning",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Duplicates</span>"
    ]
  },
  {
    "objectID": "2_cleaning_general/duplicates.html#summary",
    "href": "2_cleaning_general/duplicates.html#summary",
    "title": "5  Duplicates",
    "section": "5.3 Summary",
    "text": "5.3 Summary\nThis chapter has offered a quick look at how to find duplicate records, remove them from your dataset and check whether your records have been removed correctly. You may have to check for duplicates in several ways to ensure you have cleaned all the duplicate records that you wish to remove from your dataset. The next chapter will show you how to clean missing values from your dataset.",
    "crumbs": [
      "General data cleaning",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Duplicates</span>"
    ]
  },
  {
    "objectID": "2_cleaning_general/duplicates.html#footnotes",
    "href": "2_cleaning_general/duplicates.html#footnotes",
    "title": "5  Duplicates",
    "section": "",
    "text": "We have used \\(df) as shorthand within purrr::map(). This shorthand can be rewritten as map(.x = df, function(.x) {}). We provide an input, in this case the piped dataframe which we’ve called df, and use it in a custom function (defined within {}). This function is run over each dataframe in our list of dataframes.Check out this description from a recent purrr package update for another example.↩︎",
    "crumbs": [
      "General data cleaning",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Duplicates</span>"
    ]
  },
  {
    "objectID": "2_cleaning_general/missing-values.html",
    "href": "2_cleaning_general/missing-values.html",
    "title": "6  Missing values",
    "section": "",
    "text": "6.0.1 Prerequisites\nIn this chapter, we will use gecko occurrence data since 2009 from the ALA.\n# packages\nlibrary(galah)\nlibrary(dplyr)\n\n# data: Gecko records since 2009\ngalah_config(email = \"your-email-here\") # ALA Registered email\n\ngeckos &lt;- galah_call() |&gt;\n  identify(\"Gekkonidae\") |&gt;\n  filter(year &gt;= 2009) |&gt;\n  select(group = \"basic\",\n         kingdom, phylum, order, class, \n         family, genus, species, cl22, \n         eventDate, month) |&gt;\n  atlas_occurrences()",
    "crumbs": [
      "General data cleaning",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Missing values</span>"
    ]
  },
  {
    "objectID": "2_cleaning_general/missing-values.html#find-missing-values",
    "href": "2_cleaning_general/missing-values.html#find-missing-values",
    "title": "6  Missing values",
    "section": "6.1 Find missing values",
    "text": "6.1 Find missing values\nOne of the fastest and simplest ways to find where there are missing values in your data is using the skimr package to show which columns have missing values and how many there are.\n\nlibrary(skimr)\n\ngeckos |&gt;\n  skim() |&gt;\n  filter(n_missing &gt; 0) |&gt; \n  as_tibble()\n\n# A tibble: 7 × 21\n  skim_type skim_variable    n_missing complete_rate POSIXct.min        \n  &lt;chr&gt;     &lt;chr&gt;                &lt;int&gt;         &lt;dbl&gt; &lt;dttm&gt;             \n1 POSIXct   eventDate              658         0.976 2009-01-01 00:00:00\n2 character genus                  663         0.976 NA                 \n3 character species               2085         0.924 NA                 \n4 character cl22                  1219         0.955 NA                 \n5 numeric   decimalLatitude        153         0.994 NA                 \n6 numeric   decimalLongitude       153         0.994 NA                 \n7 numeric   month                  649         0.976 NA                 \n# ℹ 16 more variables: POSIXct.max &lt;dttm&gt;, POSIXct.median &lt;dttm&gt;,\n#   POSIXct.n_unique &lt;int&gt;, character.min &lt;int&gt;, character.max &lt;int&gt;,\n#   character.empty &lt;int&gt;, character.n_unique &lt;int&gt;,\n#   character.whitespace &lt;int&gt;, numeric.mean &lt;dbl&gt;, numeric.sd &lt;dbl&gt;,\n#   numeric.p0 &lt;dbl&gt;, numeric.p25 &lt;dbl&gt;, numeric.p50 &lt;dbl&gt;, numeric.p75 &lt;dbl&gt;,\n#   numeric.p100 &lt;dbl&gt;, numeric.hist &lt;chr&gt;\n\n\nThe output shows that there are 7 columns with missing values, shown in skim_variable, along with information about the number of missing values in n_missing and the proportion of non-missing values in complete_rate.\nNext we can return all rows with a missing variable.\n\ngeckos |&gt; \n  filter(if_any(everything(), is.na)) |&gt;\n  select(scientificName, genus, \n         species, cl22, everything()) # reorder columns\n\n# A tibble: 3,444 × 17\n   scientificName    genus species cl22  recordID taxonConceptID decimalLatitude\n   &lt;chr&gt;             &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;                    &lt;dbl&gt;\n 1 Gehyra            Gehy… &lt;NA&gt;    Sout… 001949e… https://biodi…          -28.1 \n 2 Gehyra            Gehy… &lt;NA&gt;    Nort… 001ab80… https://biodi…          -16.1 \n 3 Gehyra australis  Gehy… Gehyra… Nort… 002f70c… https://biodi…          -13.1 \n 4 Lepidodactylus p… Lepi… Lepido… &lt;NA&gt;  00336d7… https://biodi…           -8.81\n 5 Christinus        Chri… &lt;NA&gt;    Sout… 003e84f… https://biodi…          -35.0 \n 6 Gehyra            Gehy… &lt;NA&gt;    Quee… 0046174… https://biodi…          -26.7 \n 7 Gehyra nana       Gehy… Gehyra… &lt;NA&gt;  005ea26… https://biodi…           NA   \n 8 GEKKONIDAE        &lt;NA&gt;  &lt;NA&gt;    Quee… 007172d… https://biodi…          -19.3 \n 9 Gehyra            Gehy… &lt;NA&gt;    Nort… 0073628… https://biodi…          -22.2 \n10 Christinus marmo… Chri… Christ… &lt;NA&gt;  007a1a3… https://biodi…          -34.9 \n# ℹ 3,434 more rows\n# ℹ 10 more variables: decimalLongitude &lt;dbl&gt;, eventDate &lt;dttm&gt;,\n#   occurrenceStatus &lt;chr&gt;, dataResourceName &lt;chr&gt;, kingdom &lt;chr&gt;,\n#   phylum &lt;chr&gt;, order &lt;chr&gt;, class &lt;chr&gt;, family &lt;chr&gt;, month &lt;dbl&gt;\n\n\nOr we can specify the specific column with NA values.\n\ngeckos |&gt; \n  filter(if_any(cl22, is.na)) |&gt;\n  select(scientificName, genus, \n         species, cl22, everything()) # reorder columns\n\n# A tibble: 1,219 × 17\n   scientificName    genus species cl22  recordID taxonConceptID decimalLatitude\n   &lt;chr&gt;             &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;                    &lt;dbl&gt;\n 1 Lepidodactylus p… Lepi… Lepido… &lt;NA&gt;  00336d7… https://biodi…           -8.81\n 2 Gehyra nana       Gehy… Gehyra… &lt;NA&gt;  005ea26… https://biodi…           NA   \n 3 Christinus marmo… Chri… Christ… &lt;NA&gt;  007a1a3… https://biodi…          -34.9 \n 4 Gehyra punctata   Gehy… Gehyra… &lt;NA&gt;  007a329… https://biodi…           NA   \n 5 Christinus marmo… Chri… Christ… &lt;NA&gt;  009be60… https://biodi…          -32.1 \n 6 Cyrtodactylus     Cyrt… &lt;NA&gt;    &lt;NA&gt;  00a3522… https://biodi…           -5.73\n 7 Hemidactylus fre… Hemi… Hemida… &lt;NA&gt;  00c6832… https://biodi…            1.29\n 8 Cyrtodactylus     Cyrt… &lt;NA&gt;    &lt;NA&gt;  00fdca4… https://biodi…           -7.42\n 9 Christinus marmo… Chri… Christ… &lt;NA&gt;  0143054… https://biodi…          -32.0 \n10 Hemidactylus fre… Hemi… Hemida… &lt;NA&gt;  01aae23… https://biodi…           16.0 \n# ℹ 1,209 more rows\n# ℹ 10 more variables: decimalLongitude &lt;dbl&gt;, eventDate &lt;dttm&gt;,\n#   occurrenceStatus &lt;chr&gt;, dataResourceName &lt;chr&gt;, kingdom &lt;chr&gt;,\n#   phylum &lt;chr&gt;, order &lt;chr&gt;, class &lt;chr&gt;, family &lt;chr&gt;, month &lt;dbl&gt;",
    "crumbs": [
      "General data cleaning",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Missing values</span>"
    ]
  },
  {
    "objectID": "2_cleaning_general/missing-values.html#remove-na-values",
    "href": "2_cleaning_general/missing-values.html#remove-na-values",
    "title": "6  Missing values",
    "section": "6.2 Remove NA values",
    "text": "6.2 Remove NA values\n\n6.2.1 Missing coordinates\nIf you are intending to make any maps or run any spatial analyses, it’s a good idea to exclude records with missing coordinates. Missing coordinate data often leads to one of the following: a function error, an undesirable map, or the (unintentional) exclusion of data points (many of which you might wish to include in other maps or analyses).\nIt’s good practice to tally and identify rows that have missing data before excluding them. We can use the same method as above to identify the records with missing coordinates.\n\ngeckos |&gt; \n  filter(if_any(c(decimalLongitude, decimalLatitude), is.na)) |&gt;\n  count()\n\n# A tibble: 1 × 1\n      n\n  &lt;int&gt;\n1   153\n\ngeckos |&gt; \n  filter(if_any(c(decimalLongitude, decimalLatitude), is.na)) |&gt;\n  select(scientificName, decimalLongitude, \n         decimalLatitude, everything()) # reorder columns\n\n# A tibble: 153 × 17\n   scientificName      decimalLongitude decimalLatitude recordID  taxonConceptID\n   &lt;chr&gt;                          &lt;dbl&gt;           &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;         \n 1 Gehyra nana                       NA              NA 005ea268… https://biodi…\n 2 Gehyra punctata                   NA              NA 007a3298… https://biodi…\n 3 Heteronotia binoei                NA              NA 03a123ed… https://biodi…\n 4 Gehyra australis                  NA              NA 05bef070… https://biodi…\n 5 Gehyra occidentalis               NA              NA 0846001e… https://biodi…\n 6 GEKKONIDAE                        NA              NA 0a078043… https://biodi…\n 7 Gehyra xenopus                    NA              NA 0ad77ff9… https://biodi…\n 8 Gehyra occidentalis               NA              NA 0c5390b2… https://biodi…\n 9 Gehyra punctata                   NA              NA 11bbc940… https://biodi…\n10 Gehyra nana                       NA              NA 12d9f935… https://biodi…\n# ℹ 143 more rows\n# ℹ 12 more variables: eventDate &lt;dttm&gt;, occurrenceStatus &lt;chr&gt;,\n#   dataResourceName &lt;chr&gt;, kingdom &lt;chr&gt;, phylum &lt;chr&gt;, order &lt;chr&gt;,\n#   class &lt;chr&gt;, family &lt;chr&gt;, genus &lt;chr&gt;, species &lt;chr&gt;, cl22 &lt;chr&gt;,\n#   month &lt;dbl&gt;\n\n\nIf we decide we are happy to exclude these records, we can use drop_na() to remove missing values from our dataset.\n\nlibrary(tidyr)\n\ngeckos_filtered &lt;- geckos |&gt;\n  drop_na(decimalLongitude, decimalLatitude)\n\nWe can see that drop_na() worked correctly by comparing the number of records in our data after filtering geckos_filtered is smaller by the same number of rows as our tibble of rows with NA values above.\n\nnrow(geckos) - nrow(geckos_filtered)\n\n[1] 153",
    "crumbs": [
      "General data cleaning",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Missing values</span>"
    ]
  },
  {
    "objectID": "2_cleaning_general/missing-values.html#taxonomic-values",
    "href": "2_cleaning_general/missing-values.html#taxonomic-values",
    "title": "6  Missing values",
    "section": "6.3 Taxonomic values",
    "text": "6.3 Taxonomic values\n\n6.3.1 Missing higher rank\nSometimes data can be missing information in columns with higher taxonomic rankings, even species have been identified down to the species level. In this case, the goal isn’t to only remove the missing values, but to fill missing information with the correct information.\nAs an example, we’ll use a slightly modified geckos_missing dataset with some missing data add into the higher columns1. Below is a preview, and you’ll notice that there are NA values in the class and family columns.\n\n\nCode\n# download older gecko data\n# geckos_old &lt;- galah_call() |&gt;\n#   identify(\"Gekkonidae\") |&gt;\n#   filter(year &gt; 2004 & year &lt; 2009) |&gt;\n#   select(group = \"basic\",\n#          kingdom, phylum, order, class, \n#          family, genus, species, cl22, \n#          eventDate, month) |&gt;\n#   atlas_occurrences()\n\n# randomly replace class & family with NAs\nset.seed(87654)\n\ngeckos_missing &lt;- geckos |&gt;\n  mutate(class = replace(class, \n                         sample(row_number(), \n                                size = ceiling(0.15 * n())), \n                         NA),\n         family = replace(family, \n                          sample(row_number(), \n                                 size = ceiling(0.15 * n())), \n                          NA))\n\n\n\ngeckos_missing |&gt;\n  select(scientificName, class, family, genus, species, everything())\n\n# A tibble: 27,265 × 17\n   scientificName        class    family   genus species recordID taxonConceptID\n   &lt;chr&gt;                 &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;    &lt;chr&gt;         \n 1 Gehyra dubia          Reptilia Gekkoni… Gehy… Gehyra… 00002a3… https://biodi…\n 2 Christinus marmoratus Reptilia Gekkoni… Chri… Christ… 0002970… https://biodi…\n 3 Heteronotia binoei    Reptilia Gekkoni… Hete… Hetero… 0007fcc… https://biodi…\n 4 Gehyra australis      Reptilia Gekkoni… Gehy… Gehyra… 00087c0… https://biodi…\n 5 Hemidactylus frenatus Reptilia Gekkoni… Hemi… Hemida… 000c00b… https://biodi…\n 6 Heteronotia binoei    Reptilia Gekkoni… Hete… Hetero… 000cd36… https://biodi…\n 7 Christinus marmoratus Reptilia Gekkoni… Chri… Christ… 0018b78… https://biodi…\n 8 Gehyra                Reptilia Gekkoni… Gehy… &lt;NA&gt;    001949e… https://biodi…\n 9 Heteronotia binoei    Reptilia Gekkoni… Hete… Hetero… 0019729… https://biodi…\n10 Gehyra                Reptilia Gekkoni… Gehy… &lt;NA&gt;    001ab80… https://biodi…\n# ℹ 27,255 more rows\n# ℹ 10 more variables: decimalLatitude &lt;dbl&gt;, decimalLongitude &lt;dbl&gt;,\n#   eventDate &lt;dttm&gt;, occurrenceStatus &lt;chr&gt;, dataResourceName &lt;chr&gt;,\n#   kingdom &lt;chr&gt;, phylum &lt;chr&gt;, order &lt;chr&gt;, cl22 &lt;chr&gt;, month &lt;dbl&gt;\n\n\nIf you have a list of taxonomic names with complete ranking information from your preferred taxonomic naming authority, you can use this information to back-fill your missing data columns. In our case, we can use names from ALA’s taxonomic backbone.\nFirst we’ll get the complete list of Gekkonidae taxonomic rank names using galah.\n\ngeckos_species_list &lt;- galah_call() |&gt;\n  identify(\"gekkonidae\") |&gt;\n  atlas_species()\n\ngeckos_species_list\n\n# A tibble: 80 × 10\n   species_guid           species author kingdom phylum class order family genus\n   &lt;chr&gt;                  &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;\n 1 https://biodiversity.… Hetero… (Gray… Animal… Chord… Rept… Squa… Gekko… Hete…\n 2 https://biodiversity.… Christ… (Gray… Animal… Chord… Rept… Squa… Gekko… Chri…\n 3 https://biodiversity.… Gehyra… (Dumé… Animal… Chord… Rept… Squa… Gekko… Gehy…\n 4 https://biodiversity.… Gehyra… (Macl… Animal… Chord… Rept… Squa… Gekko… Gehy…\n 5 https://biodiversity.… Hemida… Dumér… Animal… Chord… Rept… Squa… Gekko… Hemi…\n 6 https://biodiversity.… Gehyra… Hutch… Animal… Chord… Rept… Squa… Gekko… Gehy…\n 7 https://biodiversity.… Gehyra… Storr… Animal… Chord… Rept… Squa… Gekko… Gehy…\n 8 https://biodiversity.… Gehyra… Gray,… Animal… Chord… Rept… Squa… Gekko… Gehy…\n 9 https://biodiversity.… Gehyra… Storr… Animal… Chord… Rept… Squa… Gekko… Gehy…\n10 https://biodiversity.… Lepido… (Dumé… Animal… Chord… Rept… Squa… Gekko… Lepi…\n# ℹ 70 more rows\n# ℹ 1 more variable: vernacular_name &lt;chr&gt;\n\n\nTo match the complete names in geckos_species_list with the missing names in geckos_missing, we can use a strategy of match-and-merge.\nUsing a reference columns, we’ll merge our complete names data to our missing data. The information in the species column of geckos_species_list contains both the genus and species names; this is just like the scientificName column of our geckos_missing dataset. We can use these columns as our reference columns.\n\ngeckos_species_list |&gt; select(species) |&gt; slice(10:15)\n\n# A tibble: 6 × 1\n  species                \n  &lt;chr&gt;                  \n1 Lepidodactylus lugubris\n2 Gehyra montium         \n3 Gehyra lazelli         \n4 Nactus pelagicus       \n5 Nactus eboracensis     \n6 Gehyra punctata        \n\ngeckos_missing |&gt; select(scientificName) |&gt; slice(10:15)\n\n# A tibble: 6 × 1\n  scientificName         \n  &lt;chr&gt;                  \n1 Gehyra                 \n2 Gehyra versicolor      \n3 Gehyra variegata       \n4 Hemidactylus frenatus  \n5 Christinus marmoratus  \n6 Lepidodactylus lugubris\n\n\nNow we’ll select the subset of columns from geckos_species_list that we wish to join with geckos_missing (and our reference column, species).\n\nlist_subset &lt;- geckos_species_list |&gt;\n  select(species, class, family)\n\nWe can use left_join() to merge list_subset to geckos_missing. Records that are identified at least down to the family level now have the correct rank information in the class_new and family_new columns.\n\ngeckos_missing |&gt;\n  left_join(list_subset, \n            by = join_by(scientificName == species), \n            suffix = c(\"_old\", \"_new\")) |&gt;\n  select(scientificName, class_old, family_old, class_new, family_new) |&gt;\n  slice(20:30)\n\n# A tibble: 11 × 5\n   scientificName         class_old family_old class_new family_new\n   &lt;chr&gt;                  &lt;chr&gt;     &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt;     \n 1 Gehyra australis       Reptilia  &lt;NA&gt;       Reptilia  Gekkonidae\n 2 Lepidodactylus pumilus Reptilia  Gekkonidae Reptilia  Gekkonidae\n 3 Heteronotia binoei     Reptilia  Gekkonidae Reptilia  Gekkonidae\n 4 Christinus marmoratus  Reptilia  Gekkonidae Reptilia  Gekkonidae\n 5 Christinus             Reptilia  Gekkonidae &lt;NA&gt;      &lt;NA&gt;      \n 6 Heteronotia binoei     Reptilia  Gekkonidae Reptilia  Gekkonidae\n 7 Nactus eboracensis     Reptilia  Gekkonidae Reptilia  Gekkonidae\n 8 Heteronotia binoei     Reptilia  Gekkonidae Reptilia  Gekkonidae\n 9 Gehyra                 Reptilia  Gekkonidae &lt;NA&gt;      &lt;NA&gt;      \n10 Heteronotia binoei     &lt;NA&gt;      &lt;NA&gt;       Reptilia  Gekkonidae\n11 Christinus marmoratus  Reptilia  Gekkonidae Reptilia  Gekkonidae\n\n\n\n\n6.3.2 Insufficient taxonomic rank\nIf a record is not identified down to the necessary taxonomic level required for your analysis (e.g. down to species or sub-species level), then the record should be removed.\nOn handy tip you can use with the galah package is to add the column taxonRank. This column usefully shows the taxonomic level of names in scientificName2. taxonRank can be useful because we can filter to only include records down to a specific rank.\n\ngeckos_rank &lt;- galah_call() |&gt;\n  identify(\"gekkonidae\") |&gt;\n  filter(year == 2013) |&gt;\n  select(taxonRank, scientificName) |&gt;\n  atlas_occurrences()\n\ngeckos_rank |&gt;\n  filter(taxonRank == \"species\")\n\n# A tibble: 1,814 × 2\n   taxonRank scientificName       \n   &lt;chr&gt;     &lt;chr&gt;                \n 1 species   Heteronotia binoei   \n 2 species   Hemidactylus frenatus\n 3 species   Gehyra variegata     \n 4 species   Gehyra variegata     \n 5 species   Heteronotia binoei   \n 6 species   Heteronotia binoei   \n 7 species   Gehyra pamela        \n 8 species   Gehyra lapistola     \n 9 species   Hemidactylus frenatus\n10 species   Heteronotia binoei   \n# ℹ 1,804 more rows\n\n\nHowever, it is still possible to filter records using the tools above without using the taxonRank column.\n\ngeckos_filtered &lt;- geckos |&gt;\n  drop_na(genus) |&gt;\n  select(scientificName, genus, everything()) # reorder columns\ngeckos_filtered\n\n# A tibble: 26,602 × 17\n   scientificName genus recordID taxonConceptID decimalLatitude decimalLongitude\n   &lt;chr&gt;          &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;                    &lt;dbl&gt;            &lt;dbl&gt;\n 1 Gehyra dubia   Gehy… 00002a3… https://biodi…           -24.1             151.\n 2 Christinus ma… Chri… 0002970… https://biodi…           -34.7             139.\n 3 Heteronotia b… Hete… 0007fcc… https://biodi…           -12.6             132.\n 4 Gehyra austra… Gehy… 00087c0… https://biodi…           -14.4             129.\n 5 Hemidactylus … Hemi… 000c00b… https://biodi…           -27.5             153.\n 6 Heteronotia b… Hete… 000cd36… https://biodi…           -13.3             131.\n 7 Christinus ma… Chri… 0018b78… https://biodi…           -36.1             147.\n 8 Gehyra         Gehy… 001949e… https://biodi…           -28.1             140.\n 9 Heteronotia b… Hete… 0019729… https://biodi…           -12.7             131.\n10 Gehyra         Gehy… 001ab80… https://biodi…           -16.1             130.\n# ℹ 26,592 more rows\n# ℹ 11 more variables: eventDate &lt;dttm&gt;, occurrenceStatus &lt;chr&gt;,\n#   dataResourceName &lt;chr&gt;, kingdom &lt;chr&gt;, phylum &lt;chr&gt;, order &lt;chr&gt;,\n#   class &lt;chr&gt;, family &lt;chr&gt;, species &lt;chr&gt;, cl22 &lt;chr&gt;, month &lt;dbl&gt;",
    "crumbs": [
      "General data cleaning",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Missing values</span>"
    ]
  },
  {
    "objectID": "2_cleaning_general/missing-values.html#footnotes",
    "href": "2_cleaning_general/missing-values.html#footnotes",
    "title": "6  Missing values",
    "section": "",
    "text": "The Atlas of Living Australia matches taxonomic names when data is ingested from data providers. This process means that it’s very rare for a species to be missing higher taxonomic rank names. This might not be the case for other data sources, though!↩︎\nThis column contains the name of the lowest taxonomic rank the occurrence is identified to.↩︎",
    "crumbs": [
      "General data cleaning",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Missing values</span>"
    ]
  },
  {
    "objectID": "2_cleaning_general/strings.html",
    "href": "2_cleaning_general/strings.html",
    "title": "7  Strings",
    "section": "",
    "text": "7.0.1 Prerequisites\nIn this chapter, we will use tree kangaroo occurrence data.\n# WORMS dataset\nworms &lt;- read.csv(here::here(\"data\", \"worms\", \"worms.csv\"))\n# AFD dataset\nafd &lt;- read.csv(\"../data/naming/afd.csv\")\n# packages\nlibrary(galah)\nlibrary(dplyr)\n\n# data: tree kangaroo records\ngalah_config(email = \"your-email-here\")\n\ntree_kangaroo &lt;- galah_call() |&gt;\n  identify(\"Dendrolagus\") |&gt;\n  atlas_occurrences()",
    "crumbs": [
      "General data cleaning",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "2_cleaning_general/strings.html#basic-string-manipulation",
    "href": "2_cleaning_general/strings.html#basic-string-manipulation",
    "title": "7  Strings",
    "section": "7.1 Basic string manipulation",
    "text": "7.1 Basic string manipulation\nThe stringr package provides a number of useful functions for manipulating strings, many of which are useful when dealing with biodiversity data.\n\nlibrary(stringr)\n\n\nTrim\n\nstr_trim(\"  Genus specificus  \")\n\n[1] \"Genus specificus\"\n\nstr_trim(\"  Genus specificus  \", side = \"left\")\n\n[1] \"Genus specificus  \"\n\n\n\n\nSquish\n\nstr_squish(\"  Genus   specificus  \")\n\n[1] \"Genus specificus\"\n\n\n\n\nTruncate\n\nstr_trunc(\"Genus specificus\", width = 10, side = \"right\")\n\n[1] \"Genus s...\"\n\n\n\n\nSplit\n\nstr_split(\"Genus specificus\", \" \")\n\n[[1]]\n[1] \"Genus\"      \"specificus\"\n\n\n\n\nLink together\n\n1str_c(\"Genus\", \"specificus\", sep = \"_\")\n\n\n1\n\nc() stands for “concatenate” which means “to link together in a chain”.\n\n\n\n\n[1] \"Genus_specificus\"",
    "crumbs": [
      "General data cleaning",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "2_cleaning_general/strings.html#matching",
    "href": "2_cleaning_general/strings.html#matching",
    "title": "7  Strings",
    "section": "7.2 Matching",
    "text": "7.2 Matching\nMatching strings is a common task when working with biodiversity data. Matching is a useful way to search or filter records, or to identify records for data cleaning.\n\n7.2.1 Basic matching\nThe stringr package provides a number of functions for matching strings using patterns.\n\nDetect a pattern\n\n# detect\nstr_detect(\"Genus specificus\", \"Genus\")\n\n[1] TRUE\n\n\nUse str_detect() to filter your data.frame.\n\n# 3 possible names in scientificName column\ntree_kangaroo |&gt; distinct(scientificName)\n\n# A tibble: 3 × 1\n  scientificName          \n  &lt;chr&gt;                   \n1 Dendrolagus lumholtzi   \n2 Dendrolagus             \n3 Dendrolagus bennettianus\n\n# detect names matching \"lum\"\ntree_kangaroo |&gt;\n  filter(str_detect(scientificName, \"lum\")) |&gt;\n  select(scientificName)\n\n# A tibble: 779 × 1\n   scientificName       \n   &lt;chr&gt;                \n 1 Dendrolagus lumholtzi\n 2 Dendrolagus lumholtzi\n 3 Dendrolagus lumholtzi\n 4 Dendrolagus lumholtzi\n 5 Dendrolagus lumholtzi\n 6 Dendrolagus lumholtzi\n 7 Dendrolagus lumholtzi\n 8 Dendrolagus lumholtzi\n 9 Dendrolagus lumholtzi\n10 Dendrolagus lumholtzi\n# ℹ 769 more rows\n\n\nstr_subset() is closely related to str_detect(), but str_subset() returns a character vector of all strings that match.\n\n# first 10 rows\ntree_kangaroo |&gt;\n  select(scientificName) |&gt;\n  slice(1:10)\n\n# A tibble: 10 × 1\n   scientificName          \n   &lt;chr&gt;                   \n 1 Dendrolagus lumholtzi   \n 2 Dendrolagus lumholtzi   \n 3 Dendrolagus lumholtzi   \n 4 Dendrolagus lumholtzi   \n 5 Dendrolagus             \n 6 Dendrolagus bennettianus\n 7 Dendrolagus lumholtzi   \n 8 Dendrolagus lumholtzi   \n 9 Dendrolagus             \n10 Dendrolagus bennettianus\n\n# str_subset()\ntree_kangaroo$scientificName |&gt; \n  str_subset(\"lum\") |&gt;\n  head(10L)\n\n [1] \"Dendrolagus lumholtzi\" \"Dendrolagus lumholtzi\" \"Dendrolagus lumholtzi\"\n [4] \"Dendrolagus lumholtzi\" \"Dendrolagus lumholtzi\" \"Dendrolagus lumholtzi\"\n [7] \"Dendrolagus lumholtzi\" \"Dendrolagus lumholtzi\" \"Dendrolagus lumholtzi\"\n[10] \"Dendrolagus lumholtzi\"\n\n\n\n\nRemove a pattern\n\n# remove\nstr_remove(\"Genus specificus\", pattern = \"Genus \")\n\n[1] \"specificus\"\n\n\nUse str_remove() to clean or extract names.\n\ntree_kangaroo |&gt;\n  mutate(\n    species = ifelse(scientificName != \"Dendrolagus\",\n                     str_remove(scientificName, \"Dendrolagus \"),\n                     NA)\n  ) |&gt;\n  select(scientificName, species)\n\n# A tibble: 1,268 × 2\n   scientificName           species     \n   &lt;chr&gt;                    &lt;chr&gt;       \n 1 Dendrolagus lumholtzi    lumholtzi   \n 2 Dendrolagus lumholtzi    lumholtzi   \n 3 Dendrolagus lumholtzi    lumholtzi   \n 4 Dendrolagus lumholtzi    lumholtzi   \n 5 Dendrolagus              &lt;NA&gt;        \n 6 Dendrolagus bennettianus bennettianus\n 7 Dendrolagus lumholtzi    lumholtzi   \n 8 Dendrolagus lumholtzi    lumholtzi   \n 9 Dendrolagus              &lt;NA&gt;        \n10 Dendrolagus bennettianus bennettianus\n# ℹ 1,258 more rows\n\n\n\n\nLocate a pattern\n\nrecords &lt;- c(\"Genus\", \n             \"species\", \n             \"ZZGenus species\", \n             \"Difgenus difspecies\")\n\nFind the start and end position of a pattern.\n\nstr_locate(records, \"Genus\")\n\n     start end\n[1,]     1   5\n[2,]    NA  NA\n[3,]     3   7\n[4,]    NA  NA\n\n\nFind which indices match a pattern.\n\nstr_which(records, \"Genus\")\n\n[1] 1 3\n\n\nAdd this information to a data.frame.\n\ntree_kangaroo |&gt;\n  mutate(\n1    start = str_locate(scientificName, \"lum\")[, 1],\n2    end = str_locate(scientificName, \"lum\")[, 2]\n  ) |&gt;\n  select(scientificName, start, end)\n\n\n1\n\n[, 1] returns column 1 of str_locate() output\n\n2\n\n[, 2] returns column 2 of str_locate() output\n\n\n\n\n# A tibble: 1,268 × 3\n   scientificName           start   end\n   &lt;chr&gt;                    &lt;int&gt; &lt;int&gt;\n 1 Dendrolagus lumholtzi       13    15\n 2 Dendrolagus lumholtzi       13    15\n 3 Dendrolagus lumholtzi       13    15\n 4 Dendrolagus lumholtzi       13    15\n 5 Dendrolagus                 NA    NA\n 6 Dendrolagus bennettianus    NA    NA\n 7 Dendrolagus lumholtzi       13    15\n 8 Dendrolagus lumholtzi       13    15\n 9 Dendrolagus                 NA    NA\n10 Dendrolagus bennettianus    NA    NA\n# ℹ 1,258 more rows\n\n\n\n\n\n7.2.2 Regex matching\nThe examples above demonstrate the use of basic patterns. But for cases that need more specific or advanced matching we can use regular expressions (regex).\nRegex is a powerful tool used to match patterns, replace characters, and extract text from strings. Regex can be complex and unintuitive, but there are websites available, such as Regex Generator, that are extremely helpful. Here we explore a few basic examples, and keep in mind that these methods can be applied to both column name strings and column values.\nThe str_view() function is a useful way to see what a regular expression will return. The results are shown in the console, and elements matched by the regex are surrounded with angle brackets &lt; &gt;.\n\n# Match the first word in the string (the genus)\n1str_view(tree_kangaroo$scientificName, \"^[A-Z][a-z]+\")\n\n\n1\n\nThis regex reads “Do not match all letters (capitalised or not) after word 1.”\n\n\n\n\n [1] │ &lt;Dendrolagus&gt; lumholtzi\n [2] │ &lt;Dendrolagus&gt; lumholtzi\n [3] │ &lt;Dendrolagus&gt; lumholtzi\n [4] │ &lt;Dendrolagus&gt; lumholtzi\n [5] │ &lt;Dendrolagus&gt;\n [6] │ &lt;Dendrolagus&gt; bennettianus\n [7] │ &lt;Dendrolagus&gt; lumholtzi\n [8] │ &lt;Dendrolagus&gt; lumholtzi\n [9] │ &lt;Dendrolagus&gt;\n[10] │ &lt;Dendrolagus&gt; bennettianus\n[11] │ &lt;Dendrolagus&gt; lumholtzi\n[12] │ &lt;Dendrolagus&gt;\n[13] │ &lt;Dendrolagus&gt;\n[14] │ &lt;Dendrolagus&gt; lumholtzi\n[15] │ &lt;Dendrolagus&gt; bennettianus\n[16] │ &lt;Dendrolagus&gt; lumholtzi\n[17] │ &lt;Dendrolagus&gt;\n[18] │ &lt;Dendrolagus&gt; lumholtzi\n[19] │ &lt;Dendrolagus&gt; lumholtzi\n[20] │ &lt;Dendrolagus&gt; lumholtzi\n... and 1248 more\n\n\n\n# Match only the second word (species name)\n1str_view(tree_kangaroo$scientificName, \"(?&lt;=\\\\s)[a-z]+\")\n\n\n1\n\nThis regex reads “Remove everything until and including the space. Return all uncapitalised letters.”\n\n\n\n\n [1] │ Dendrolagus &lt;lumholtzi&gt;\n [2] │ Dendrolagus &lt;lumholtzi&gt;\n [3] │ Dendrolagus &lt;lumholtzi&gt;\n [4] │ Dendrolagus &lt;lumholtzi&gt;\n [6] │ Dendrolagus &lt;bennettianus&gt;\n [7] │ Dendrolagus &lt;lumholtzi&gt;\n [8] │ Dendrolagus &lt;lumholtzi&gt;\n[10] │ Dendrolagus &lt;bennettianus&gt;\n[11] │ Dendrolagus &lt;lumholtzi&gt;\n[14] │ Dendrolagus &lt;lumholtzi&gt;\n[15] │ Dendrolagus &lt;bennettianus&gt;\n[16] │ Dendrolagus &lt;lumholtzi&gt;\n[18] │ Dendrolagus &lt;lumholtzi&gt;\n[19] │ Dendrolagus &lt;lumholtzi&gt;\n[20] │ Dendrolagus &lt;lumholtzi&gt;\n[21] │ Dendrolagus &lt;lumholtzi&gt;\n[24] │ Dendrolagus &lt;lumholtzi&gt;\n[25] │ Dendrolagus &lt;bennettianus&gt;\n[27] │ Dendrolagus &lt;lumholtzi&gt;\n[28] │ Dendrolagus &lt;lumholtzi&gt;\n... and 865 more\n\n\n\n\n7.2.3 Replace\nA common way to clean strings is to match and replace specific patterns. Here are several examples using the stringr package or base R.\n\nstr_replace()gsub()\n\n\nIn stringr, the str_replace() function can be used to replace the first match of a string. The str_replace_all() function can be used to replace all matches.\n\nrecords &lt;- c(\"Genus\", \n             \"species\", \n             \"ZZGenus species\", \n             \"Difgenus difspecies\")\n\n\nstr_replace(records, \"[aeiou]\", \"-\")     # first match\n\n[1] \"G-nus\"               \"sp-cies\"             \"ZZG-nus species\"    \n[4] \"D-fgenus difspecies\"\n\nstr_replace_all(records, \"[aeiou]\", \"-\") # all matches\n\n[1] \"G-n-s\"               \"sp-c--s\"             \"ZZG-n-s sp-c--s\"    \n[4] \"D-fg-n-s d-fsp-c--s\"\n\n\nReplace a matched pattern in a dataframe.\n\ntree_kangaroo |&gt;\n  mutate(\n    name_updated = str_replace(\n      scientificName, \"^[A-Z][a-z]+\", \"new_name\"\n      )\n  ) |&gt;\n  select(scientificName, name_updated)\n\n# A tibble: 1,268 × 2\n   scientificName           name_updated         \n   &lt;chr&gt;                    &lt;chr&gt;                \n 1 Dendrolagus lumholtzi    new_name lumholtzi   \n 2 Dendrolagus lumholtzi    new_name lumholtzi   \n 3 Dendrolagus lumholtzi    new_name lumholtzi   \n 4 Dendrolagus lumholtzi    new_name lumholtzi   \n 5 Dendrolagus              new_name             \n 6 Dendrolagus bennettianus new_name bennettianus\n 7 Dendrolagus lumholtzi    new_name lumholtzi   \n 8 Dendrolagus lumholtzi    new_name lumholtzi   \n 9 Dendrolagus              new_name             \n10 Dendrolagus bennettianus new_name bennettianus\n# ℹ 1,258 more rows\n\n\n\n\nIn base R the gsub() function can be used for pattern replacement.\n\nrecords &lt;- c(\"Genus\", \n             \"species\", \n             \"ZZGenus species\", \n             \"Difgenus difspecies\")\n\n\ngsub(\"[aeiou]\", \"-\", records) # all matches\n\n[1] \"G-n-s\"               \"sp-c--s\"             \"ZZG-n-s sp-c--s\"    \n[4] \"D-fg-n-s d-fsp-c--s\"\n\n\nReplace a matched pattern in a dataframe.\n\ntree_kangaroo$name_updated &lt;- gsub(\n  pattern = \"Dendrolagus\",\n  replacement = \"new_name\",\n  x = tree_kangaroo$scientificName\n)\n\ntree_kangaroo[,c(\"scientificName\", \"name_updated\")]\n\n# A tibble: 1,268 × 2\n   scientificName           name_updated         \n   &lt;chr&gt;                    &lt;chr&gt;                \n 1 Dendrolagus lumholtzi    new_name lumholtzi   \n 2 Dendrolagus lumholtzi    new_name lumholtzi   \n 3 Dendrolagus lumholtzi    new_name lumholtzi   \n 4 Dendrolagus lumholtzi    new_name lumholtzi   \n 5 Dendrolagus              new_name             \n 6 Dendrolagus bennettianus new_name bennettianus\n 7 Dendrolagus lumholtzi    new_name lumholtzi   \n 8 Dendrolagus lumholtzi    new_name lumholtzi   \n 9 Dendrolagus              new_name             \n10 Dendrolagus bennettianus new_name bennettianus\n# ℹ 1,258 more rows\n\n\n\n\n\n\n\nAdvanced regex\nIn some cases a more specific detection and replacement is required.\nLet’s say we want to use marine data and taxonomic names from two sources.\nThe World Register of Marine Species (WoRMS) uses a combination of lower case (scientific_name) and camel case (isExtinct) strings. However, the Australian Fauna Directory (AFD) uses screaming snake case e.g. SCIENTIFIC_NAME. To work with both, case differences can be conformed to a single style, but the format you choose is a matter of personal preference.\n\n\n\nworms_small &lt;- head(worms)\n\n# gsub is a base R function for replacing strings\ncolnames(worms_small) &lt;- sapply(colnames(worms_small), function(name) {\n  name &lt;- tolower(gsub(\"([a-z])([A-Z])\", \"\\\\1_\\\\2\", name))\n  gsub(\"^_\", \"\", name)\n})\n\n# stringr version of above (with a slightly different regex approach)\ncolnames(worms_small) &lt;- sapply(colnames(worms_small), function(name) {\n  str_to_lower(str_replace_all(name, \"(?&lt;=\\\\p{Ll})(\\\\p{Lu})\", \"_\\\\1\"))\n})",
    "crumbs": [
      "General data cleaning",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "2_cleaning_general/strings.html#capitalisation",
    "href": "2_cleaning_general/strings.html#capitalisation",
    "title": "7  Strings",
    "section": "7.3 Capitalisation",
    "text": "7.3 Capitalisation\nCapitalisation, also called case style, can vary between data providers. Each data provider can have their own naming conventions, and even small differences in conventions must be standardised in order to use a data set. There are some basic functions available to change the case of strings in stringr:\n\n# example\ntree_kangaroo$scientificName[1]\n\n[1] \"Dendrolagus lumholtzi\"\n\n\n\nstr_to_lower(tree_kangaroo$scientificName[1])\n\n[1] \"dendrolagus lumholtzi\"\n\nstr_to_upper(tree_kangaroo$scientificName[1])\n\n[1] \"DENDROLAGUS LUMHOLTZI\"\n\nstr_to_title(tree_kangaroo$scientificName[1])\n\n[1] \"Dendrolagus Lumholtzi\"\n\nstr_to_sentence(tree_kangaroo$scientificName[1])\n\n[1] \"Dendrolagus lumholtzi\"\n\n\nNormally higher taxonomy are capitalised e.g. Myrtaceae or Aves. Capitalisation errors are usually quick to spot when you print the data object. Alternatively you can try using str_subset on columns you expect to have capital letters.\nThe code below subsets out unique values for the variable class that have upper case letters. Notice that no matches are found.\n\nlibrary(arrow)\nlibrary(tidyverse)\nlibrary(janitor)\n\nbees &lt;- read_parquet(\"../data/dap/bees.parquet\")\n\nstr_subset(unique(bees$class), \"[:upper:]\")\n\ncharacter(0)\n\n\nWe can confirm that there are no upper case matches by subsetting unique values that have lower case letters to see what is going on. This shows us that Insecta is inputted entirely in lowercase.\n\nstr_subset(unique(bees$class), \"[:lower:]\")\n\n[1] \"insecta\"\n\n\nWe can correct the lower case formatting as below, remember to check the fix before overwriting/removing the erroneous column(s)\n\nbees |&gt;\n  mutate(class_corrected = str_to_sentence(class)) |&gt;\n  select(starts_with(\"class\"))\n\n# A tibble: 1,139 × 2\n   class   class_corrected\n   &lt;chr&gt;   &lt;chr&gt;          \n 1 insecta Insecta        \n 2 insecta Insecta        \n 3 insecta Insecta        \n 4 insecta Insecta        \n 5 insecta Insecta        \n 6 insecta Insecta        \n 7 insecta Insecta        \n 8 insecta Insecta        \n 9 insecta Insecta        \n10 insecta Insecta        \n# ℹ 1,129 more rows\n\nbees_corrected &lt;- bees |&gt;\n  mutate(class_corrected = str_to_sentence(class)) |&gt;\n  select(-class) |&gt;               # Remove erroneous column\n  rename(class = class_corrected) # Rename new column to `class`\n\n\nDax’s note\nThis is a very good case study, and it might be nice to include it, though I don’t think it suits an ALA book to be using Elephant data from GBIF. Is there an ALA data equivalent?",
    "crumbs": [
      "General data cleaning",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "2_cleaning_general/strings.html#case-study-cleaning-location-names",
    "href": "2_cleaning_general/strings.html#case-study-cleaning-location-names",
    "title": "7  Strings",
    "section": "7.4 Case study: Cleaning location names",
    "text": "7.4 Case study: Cleaning location names\nWe will use the janitor R package to explore whether our elephant data has any string issues. The function tabyl will compute a counts and percent of total rows for each unique value.\n\nlibrary(dplyr)\nlibrary(janitor)\nafrican_ele &lt;- arrow::read_parquet(\"../data/gbif/elephant\")\nafrican_ele |&gt;\n  pull(stateProvince) |&gt;\n  tabyl() |&gt;\n  tibble() |&gt;\n  print(n = 20)\n\n# A tibble: 199 × 4\n   `pull(african_ele, stateProvince)`     n   percent valid_percent\n   &lt;chr&gt;                              &lt;int&gt;     &lt;dbl&gt;         &lt;dbl&gt;\n 1 Agadez                                 1 0.0000556     0.0000867\n 2 Al Qahirah                             1 0.0000556     0.0000867\n 3 Alibori                              601 0.0334        0.0521   \n 4 Arusha                               333 0.0185        0.0289   \n 5 Arusha Region                          1 0.0000556     0.0000867\n 6 Atacora                              366 0.0204        0.0317   \n 7 Atakora                              249 0.0139        0.0216   \n 8 Balaka                                 8 0.000445      0.000694 \n 9 Bassila                                1 0.0000556     0.0000867\n10 Batha                                  1 0.0000556     0.0000867\n11 Bauchi                                 7 0.000389      0.000607 \n12 Bengo                                  3 0.000167      0.000260 \n13 Bizerte                                2 0.000111      0.000173 \n14 Borgou                                 7 0.000389      0.000607 \n15 Bouaflé                                3 0.000167      0.000260 \n16 Bouna                                  1 0.0000556     0.0000867\n17 Budongo Forest                         1 0.0000556     0.0000867\n18 Bushenyi                              85 0.00473       0.00737  \n19 Cabo Delgado                           3 0.000167      0.000260 \n20 Cape Prov.                             2 0.000111      0.000173 \n# ℹ 179 more rows\n\n\nFrom the tabyl output, we can see there are few different variations of Province, Prov., Prov. As an example, we will correct these with the tidyverse packages stringr, dplyr, tidyr as well as glue.\n\nlibrary(glue)\n# Create a regular expression to match Prov. and Prov\npattern &lt;- regex(\"Prov(?![:lower:])\")\n# Use `str_subset` to pull out the cases that match our pattern\n# Confirm that these are the problematic ones\n# Assign these into an object\nstr_subset(african_ele$stateProvince, pattern = pattern)\n\n [1] \"Cape Prov.\"        \"Cape Prov.\"        \"West Nile Prov.\"  \n [4] \"Central Prov\"      \"Central Prov\"      \"Coastal Prov\"     \n [7] \"Northeastern Prov\" \"Central Prov\"      \"Eastern Prov\"     \n[10] \"Coastal Prov\"     \n\ntypos_provinces &lt;- str_subset(african_ele$stateProvince, pattern = pattern)\n\n# Create a new variable `stateProvince_clean`\n# `str_detect` for matches of pattern (returns TRUE for match)\n# `if_else`: if TRUE, the `glue` function will take the first part of the province name enclosed in and join it with word Province.\n# if FALSE , it will just take the corresponding value in stateProvince\n# Note that we are assigning these changes to a new object (`african_ele_2`)\nafrican_ele_2 &lt;- african_ele %&gt;%\n  mutate(stateProvince_clean = if_else(str_detect(stateProvince, pattern = pattern),\n    true = glue('{word(stateProvince, sep = \" P\")} Province'),\n    false = stateProvince\n  ))\n\n# Once we've made the correction we want to check we've done it correctly.\n# ALWAYS CHECK YOUR CORRECTIONS\n# Use the `select` function to isolate columns that `starts_with` \"stateProvince\"\n# Use the `filter` function to subset our the problematic provinces\nafrican_ele_2 %&gt;%\n  select(starts_with(\"stateProvince\")) %&gt;%\n  filter(stateProvince %in% typos_provinces)\n\n# A tibble: 10 × 2\n   stateProvince     stateProvince_clean  \n   &lt;chr&gt;             &lt;glue&gt;               \n 1 Cape Prov.        Cape Province        \n 2 Cape Prov.        Cape Province        \n 3 West Nile Prov.   West Nile Province   \n 4 Central Prov      Central Province     \n 5 Central Prov      Central Province     \n 6 Coastal Prov      Coastal Province     \n 7 Northeastern Prov Northeastern Province\n 8 Central Prov      Central Province     \n 9 Eastern Prov      Eastern Province     \n10 Coastal Prov      Coastal Province     \n\n# Its good practice to check the other values were not affected by your corrections\n# Here we are removing the NA with `drop_na` and subsetting unique rows with `distinct`\nafrican_ele_2 %&gt;%\n  select(starts_with(\"stateProvince\")) %&gt;%\n  tidyr::drop_na() %&gt;%\n  distinct()\n\n# A tibble: 198 × 2\n   stateProvince    stateProvince_clean\n   &lt;chr&gt;            &lt;glue&gt;             \n 1 Southern         Southern           \n 2 Taita Taveta     Taita Taveta       \n 3 Mara             Mara               \n 4 Arusha           Arusha             \n 5 Simiyu           Simiyu             \n 6 Morogoro         Morogoro           \n 7 Mashonaland West Mashonaland West   \n 8 Mpumalanga       Mpumalanga         \n 9 KwaZulu-Natal    KwaZulu-Natal      \n10 Manicaland       Manicaland         \n# ℹ 188 more rows\n\n# Final check\n# Check with the original code that detected the issue\nafrican_ele_2 %&gt;%\n  pull(stateProvince_clean) %&gt;%\n  tabyl() %&gt;%\n  tibble() %&gt;%\n  print(n = 20)\n\n# A tibble: 197 × 4\n   .                  n   percent valid_percent\n   &lt;glue&gt;         &lt;int&gt;     &lt;dbl&gt;         &lt;dbl&gt;\n 1 Agadez             1 0.0000556     0.0000867\n 2 Al Qahirah         1 0.0000556     0.0000867\n 3 Alibori          601 0.0334        0.0521   \n 4 Arusha           333 0.0185        0.0289   \n 5 Arusha Region      1 0.0000556     0.0000867\n 6 Atacora          366 0.0204        0.0317   \n 7 Atakora          249 0.0139        0.0216   \n 8 Balaka             8 0.000445      0.000694 \n 9 Bassila            1 0.0000556     0.0000867\n10 Batha              1 0.0000556     0.0000867\n11 Bauchi             7 0.000389      0.000607 \n12 Bengo              3 0.000167      0.000260 \n13 Bizerte            2 0.000111      0.000173 \n14 Borgou             7 0.000389      0.000607 \n15 Bouaflé            3 0.000167      0.000260 \n16 Bouna              1 0.0000556     0.0000867\n17 Budongo Forest     1 0.0000556     0.0000867\n18 Bushenyi          85 0.00473       0.00737  \n19 Cabo Delgado       3 0.000167      0.000260 \n20 Cape Province      3 0.000167      0.000260 \n# ℹ 177 more rows\n\n\nThere are some other issues that can be corrected in a similar approach:\n\nNorth West, North West District and North-Western\nÀfrica Central, Central Province and Central\nAtacora and Atakora\nCoastal Province and Coastal\n\nWe recommend consulting reputable sources to delineate and consolidate similar values.",
    "crumbs": [
      "General data cleaning",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "2_cleaning_general/dates.html",
    "href": "2_cleaning_general/dates.html",
    "title": "8  Dates",
    "section": "",
    "text": "8.0.1 Prerequisites\nIn this chapter, we will use Grevillea (aka spider flower) occurrence data.\n# packages\nlibrary(galah)\nlibrary(dplyr)\n\n# data: grevillea records\ngalah_config(email = \"your-email-here\")\n\nplants &lt;- galah_call() |&gt;\n  identify(\"grevillea\") |&gt;\n  atlas_occurrences()\n\nbirds &lt;- galah_call() |&gt;\n  identify(\"alcedinidae\") |&gt;\n  filter(year == 2022) |&gt;\n  select(group = \"basic\", \n         family, genus, species, \n         cl22, eventDate, year) |&gt;\n  atlas_occurrences()",
    "crumbs": [
      "General data cleaning",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Dates</span>"
    ]
  },
  {
    "objectID": "2_cleaning_general/dates.html#basic-date-manipulation",
    "href": "2_cleaning_general/dates.html#basic-date-manipulation",
    "title": "8  Dates",
    "section": "8.1 Basic date manipulation",
    "text": "8.1 Basic date manipulation\nOne of the most useful data cleaning packages for dates is the lubridate package. Below are some examples of common date cleaning functions. You can find more at the lubridate package website.\n\nlibrary(lubridate)\n\n\n8.1.1 Reformat\nThe lubridate package is incredibly good at reformatting dates written in many different styles to YYYY-MM-DD format. Here are a few examples.\n\ndate(\"2017-10-11T14:02:00\")\n\n[1] \"2017-10-11\"\n\ndmy(\"11 October 2020\")\n\n[1] \"2020-10-11\"\n\nmdy(\"10/11/2020\")\n\n[1] \"2020-10-11\"\n\n\nSometimes dates are presented in formats that do not translate cleanly into R. For example, the following date format isn’t converted correctly when we try to convert it to a date.\n\ndf &lt;- tibble(\n  date = c(\"X2020.01.22\",\n           \"X2020.01.22\",\n           \"X2020.01.22\",\n           \"X2020.01.22\")\n)\n\ndf |&gt; \n  mutate(\n    date = as_date(date)\n  )\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `date = as_date(date)`.\nCaused by warning:\n! All formats failed to parse. No formats found.\n\n\n# A tibble: 4 × 1\n  date  \n  &lt;date&gt;\n1 NA    \n2 NA    \n3 NA    \n4 NA    \n\n\nWe can use % to be more explicit about what information is in each part of our date column, specifying where the 4-digit year (%Y), 2-digit month (%m) and 2 digit day (%d) are within each string. Learn more about date formats in the R 4 Data Science book .\n\ndf |&gt; \n  mutate(\n    date = as_date(date, format = \"X%Y.%m.%d\")\n  )\n\n# A tibble: 4 × 1\n  date      \n  &lt;date&gt;    \n1 2020-01-22\n2 2020-01-22\n3 2020-01-22\n4 2020-01-22\n\n\n\n\n8.1.2 Extract\nThe lubridate package is also very good at extracting specific information from a longer date. This is very useful for summarising, filtering or plotting.\n\n8.1.2.1 Date information\n\nyear(\"2017-11-28T14:02:00\")\n\n[1] 2017\n\nmonth(\"2017-11-28T14:02:00\")\n\n[1] 11\n\nweek(\"2017-11-28T14:02:00\")\n\n[1] 48\n\nday(\"2017-11-28T14:02:00\")\n\n[1] 28\n\n\n\n\n\n8.1.3 Time information\n\nymd_hms(\"2017-11-28T14:02:00\")\n\n[1] \"2017-11-28 14:02:00 UTC\"\n\nymd_hms(\"2017-11-28T14:02:00\", tz = \"Australia/Melbourne\")\n\n[1] \"2017-11-28 14:02:00 AEDT\"\n\nymd_hms(\"2017-11-28T14:02:00\") |&gt; hour()\n\n[1] 14\n\nymd_hms(\"2017-11-28T14:02:00\") |&gt; minute()\n\n[1] 2\n\nam(\"2017-11-28T14:02:00\")\n\n[1] TRUE\n\npm(\"2017-11-28T14:02:00\")\n\n[1] FALSE\n\n\n\n\n8.1.4 An example using galah\nData downloaded using the galah package is loaded into R as date and time data (class POSITct). As a result, you can immediately begin extracting date information using the functions above.\n\nplants |&gt;\n  mutate(\n    year = year(eventDate),\n    month = month(eventDate),\n    week = isoweek(eventDate),\n    day_julian = yday(eventDate)\n    ) |&gt;\n  select(eventDate, year, month, \n         week, day_julian)\n\n# A tibble: 189,720 × 5\n   eventDate            year month  week day_julian\n   &lt;dttm&gt;              &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;\n 1 2018-07-08 00:00:00  2018     7    27        189\n 2 2019-11-14 00:00:00  2019    11    46        318\n 3 2003-09-19 00:00:00  2003     9    38        262\n 4 2019-09-06 00:00:00  2019     9    36        249\n 5 2022-08-31 00:00:00  2022     8    35        243\n 6 1996-10-30 00:00:00  1996    10    44        304\n 7 1948-09-20 00:00:00  1948     9    39        264\n 8 1988-10-13 00:00:00  1988    10    41        287\n 9 2022-10-10 00:00:00  2022    10    41        283\n10 2020-10-21 00:00:00  2020    10    43        295\n# ℹ 189,710 more rows",
    "crumbs": [
      "General data cleaning",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Dates</span>"
    ]
  },
  {
    "objectID": "2_cleaning_general/dates.html#filter",
    "href": "2_cleaning_general/dates.html#filter",
    "title": "8  Dates",
    "section": "8.2 Filter",
    "text": "8.2 Filter\nWe can filter ALA data to within a specific date.\n\n# return records after 2015\nplants |&gt;\n  filter(eventDate &gt;= ymd(\"2016-01-01\"))\n\n# A tibble: 53,021 × 8\n   recordID       scientificName taxonConceptID decimalLatitude decimalLongitude\n   &lt;chr&gt;          &lt;chr&gt;          &lt;chr&gt;                    &lt;dbl&gt;            &lt;dbl&gt;\n 1 00005eb8-4b84… Grevillea mur… https://id.bi…           -35.8             138.\n 2 000143a7-20e2… Grevillea jun… https://id.bi…           -33.7             151.\n 3 00020893-9823… Grevillea aqu… https://id.bi…           -37.3             142.\n 4 0002cd90-4099… Grevillea tre… https://id.bi…           -30.9             134.\n 5 00040117-eae2… Grevillea par… https://id.bi…           -32.8             152.\n 6 00045361-870d… Grevillea bux… https://id.bi…           -33.7             151.\n 7 00053e34-1bdb… Grevillea ros… https://id.bi…           -37.7             145.\n 8 0006e628-69d5… Grevillea rhi… https://id.bi…           -29.5             152.\n 9 00075a74-e3de… Grevillea par… https://id.bi…           -34.2             151.\n10 000858d7-626d… Grevillea      https://id.bi…           -34.0             151.\n# ℹ 53,011 more rows\n# ℹ 3 more variables: eventDate &lt;dttm&gt;, occurrenceStatus &lt;chr&gt;,\n#   dataResourceName &lt;chr&gt;\n\n\n\n# return records between 2015 & 2018\nplants |&gt; \n  filter(eventDate &gt;= ymd(\"2016-01-01\") & \n           eventDate &lt;= ymd(\"2017-12-31\"))\n\n# A tibble: 9,181 × 8\n   recordID       scientificName taxonConceptID decimalLatitude decimalLongitude\n   &lt;chr&gt;          &lt;chr&gt;          &lt;chr&gt;                    &lt;dbl&gt;            &lt;dbl&gt;\n 1 000b499b-dc80… Grevillea bux… https://id.bi…           -33.7             151.\n 2 000e2c2b-953e… Grevillea hil… https://id.bi…            NA                NA \n 3 0014b88f-ecc5… Grevillea gut… https://id.bi…           -32.5             152.\n 4 001ac6ed-1de5… Grevillea ser… https://id.bi…           -32.2             150.\n 5 001c6599-0f27… Grevillea aca… https://id.bi…           -33.4             150.\n 6 001f301f-0192… Grevillea dry… https://id.bi…           -12.5             131.\n 7 002a8fb4-e1f9… Grevillea cal… https://id.bi…           -33.7             151.\n 8 002e9fb9-ff3b… Grevillea cal… https://id.bi…           -33.7             151.\n 9 0038f556-0591… Grevillea lin… https://id.bi…           -33.7             151.\n10 003d2b67-6db4… Grevillea par… https://id.bi…           -34.3             151.\n# ℹ 9,171 more rows\n# ℹ 3 more variables: eventDate &lt;dttm&gt;, occurrenceStatus &lt;chr&gt;,\n#   dataResourceName &lt;chr&gt;\n\n\n\n8.2.1 Filter before download\nIn galah, you can filter data very similarly but before you download",
    "crumbs": [
      "General data cleaning",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Dates</span>"
    ]
  },
  {
    "objectID": "2_cleaning_general/dates.html#summary",
    "href": "2_cleaning_general/dates.html#summary",
    "title": "8  Dates",
    "section": "8.3 Summary",
    "text": "8.3 Summary\nIn this chapter, we provided examples of common functions for cleaning dates and times for ecological data sets.\nIn the next chapter…",
    "crumbs": [
      "General data cleaning",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Dates</span>"
    ]
  },
  {
    "objectID": "2_cleaning_general/dates.html#recycle-bin",
    "href": "2_cleaning_general/dates.html#recycle-bin",
    "title": "8  Dates",
    "section": "8.4 Recycle bin",
    "text": "8.4 Recycle bin",
    "crumbs": [
      "General data cleaning",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Dates</span>"
    ]
  },
  {
    "objectID": "2_cleaning_general/dates.html#unexpected-time",
    "href": "2_cleaning_general/dates.html#unexpected-time",
    "title": "8  Dates",
    "section": "8.5 Unexpected time",
    "text": "8.5 Unexpected time\nSometimes, although the correct filters were used to download a data set, some unexpected values can sneak through and require cleaning. These unexpected values can happen when processes used to clean or categorise data by a data provider or data infrastructure miss a few values. Missed values might have been mis-entered originally, fixed incorrectly or undetected.\nFor example, recall that we filtered our data download query to year == 2022 using galah (?sec-prereq). If we look at the year field returned by galah, it looks like our data is only from 2022.\n\nbirds |&gt;\n  distinct(year)\n\n# A tibble: 1 × 1\n   year\n  &lt;dbl&gt;\n1  2022\n\n\nHowever, we can use the eventDate field to double check this is true. Let’s extract year from eventDate by using the year() function from the lubridate package.\n\nlibrary(lubridate)\n\nbirds_dates &lt;- birds |&gt;\n1  mutate(date = date(eventDate),\n         year_extracted = year(eventDate))\n\nbirds_dates |&gt;\n  select(date, year_extracted)\n\n\n1\n\nWe first convert values in the eventDate column to a date class. The lubridate package is very good at reading dates in many different formats and standardising them into a “yyyy-mm-dd” format. After this conversion, dates can be handled correctly (and more easily) by the lubridate package.\n\n\n\n\n# A tibble: 138,577 × 2\n   date       year_extracted\n   &lt;date&gt;              &lt;dbl&gt;\n 1 2022-04-19           2022\n 2 2022-12-25           2022\n 3 2022-10-27           2022\n 4 2022-01-23           2022\n 5 2022-11-09           2022\n 6 2022-02-05           2022\n 7 2022-11-24           2022\n 8 2022-10-01           2022\n 9 2022-03-21           2022\n10 2022-08-14           2022\n# ℹ 138,567 more rows\n\n\nDespite specifying the year in our galah query, when we summarise our new year_extracted column, we find that there are other unexpected records from 2021, too!\n\nbirds_dates |&gt;\n  group_by(year_extracted) |&gt;\n  count()\n\n# A tibble: 3 × 2\n# Groups:   year_extracted [3]\n  year_extracted      n\n           &lt;dbl&gt;  &lt;int&gt;\n1           2021      4\n2           2022 138571\n3             NA      2\n\n\nViewing these records’ eventDate shows that each of them occurred on New Year’s Eve in 2021—on the cusp of 2022. For some unknown reason they still slipped through into our galah data query.\n\nbirds_dates |&gt;\n  filter(year_extracted == 2021) |&gt;\n  select(eventDate, date, year, year_extracted)\n\n# A tibble: 4 × 4\n  eventDate           date        year year_extracted\n  &lt;dttm&gt;              &lt;date&gt;     &lt;dbl&gt;          &lt;dbl&gt;\n1 2021-12-31 21:00:00 2021-12-31  2022           2021\n2 2021-12-31 18:07:00 2021-12-31  2022           2021\n3 2021-12-31 21:59:00 2021-12-31  2022           2021\n4 2021-12-31 21:04:00 2021-12-31  2022           2021\n\n\nAs we are only interested in records from 2022, we can filter these unexpected 2021 records out of our data set.\n\nbirds_filtered &lt;- birds_dates |&gt;\n  filter(year_extracted == 2022)",
    "crumbs": [
      "General data cleaning",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Dates</span>"
    ]
  },
  {
    "objectID": "3_cleaning_expert/1_intro.html",
    "href": "3_cleaning_expert/1_intro.html",
    "title": "Ecological data cleaning",
    "section": "",
    "text": "This section details data cleaning methods that rely on ecological/biological expert knowledge of your dataset. Not everything will apply to every dataset, and will depend on the species or clades that are in the data.\n\n\n\n\n\nTaxonomic validation\n\n\n\n\n\nTaxonomy\n\n\n\n\n\nGeospatial data\n\n\n\n\n\nOutliers",
    "crumbs": [
      "Ecological data cleaning"
    ]
  },
  {
    "objectID": "3_cleaning_expert/taxonomic-validation.html",
    "href": "3_cleaning_expert/taxonomic-validation.html",
    "title": "9  Taxonomic validation",
    "section": "",
    "text": "9.0.1 Prerequisites\nIn this chapter we will use several datasets:\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(stringr)\nlibrary(janitor)\nlibrary(galah)\n\ngalah_config(email = Sys.getenv(\"ALA_EMAIL\"),\n             username = Sys.getenv(\"GBIF_USERNAME\"),\n             password = Sys.getenv(\"GBIF_PWD\"),\n             verbose = FALSE)\n\nbirds &lt;- galah_call() |&gt;\n  identify(\"alcedinidae\") |&gt;\n  filter(year == 2022) |&gt;\n  select(group = \"basic\", \n         family, genus, species, \n         cl22, eventDate, year) |&gt;\n  atlas_occurrences()\n\ninverts &lt;- here::here(\"data\", \"dap\", \"inverts_subset\") |&gt;\n  arrow::open_dataset() |&gt; \n  collect()\n\neucalypts &lt;- galah_call() |&gt;\n  identify(\"Eucalyptus\") |&gt;\n  filter(eventDate &gt; \"2014-01-01T00:00:00Z\",\n         eventDate &lt; \"2014-06-01T00:00:00Z\") |&gt;\n  select(group = \"basic\", \n         kingdom, phylum, class, order, \n         family, genus, species, taxonRank) |&gt;\n  atlas_occurrences()",
    "crumbs": [
      "Ecological data cleaning",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Taxonomic validation</span>"
    ]
  },
  {
    "objectID": "3_cleaning_expert/taxonomic-validation.html#preview-names",
    "href": "3_cleaning_expert/taxonomic-validation.html#preview-names",
    "title": "9  Taxonomic validation",
    "section": "9.1 Preview names",
    "text": "9.1 Preview names\n\nOne of the simplest ways to determine whether there are any immediate issues with taxonomic names is to print some of them. Here we can already notice that some names are formatted in all capitals while others are not.\n\nbirds |&gt;\n  distinct(scientificName) |&gt;\n  print(n = 25)\n\n# A tibble: 22 × 1\n   scientificName                            \n   &lt;chr&gt;                                     \n 1 Dacelo (Dacelo) novaeguineae              \n 2 Todiramphus (Todiramphus) sanctus         \n 3 Ceyx azureus                              \n 4 Todiramphus (Lazulena) macleayii          \n 5 Dacelo (Dacelo) leachii                   \n 6 Tanysiptera (Uralcyon) sylvia             \n 7 Ceyx pusillus                             \n 8 Todiramphus (Cyanalcyon) pyrrhopygius     \n 9 Syma torotoro                             \n10 Todiramphus                               \n11 ALCEDINIDAE                               \n12 Dacelo (Dacelo) novaeguineae novaeguineae \n13 Dacelo (Dacelo) leachii leachii           \n14 Todiramphus (Todiramphus) sanctus sanctus \n15 Todiramphus (Todiramphus) chloris         \n16 Todiramphus (Todiramphus) sanctus vagans  \n17 Ceyx azureus azureus                      \n18 Ceyx azureus diemenensis                  \n19 Todiramphus (Lazulena) macleayii macleayii\n20 Dacelo                                    \n21 Todiramphus (Lazulena) macleayii incinctus\n22 Ceyx azureus ruficollaris",
    "crumbs": [
      "Ecological data cleaning",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Taxonomic validation</span>"
    ]
  },
  {
    "objectID": "3_cleaning_expert/taxonomic-validation.html#name-format",
    "href": "3_cleaning_expert/taxonomic-validation.html#name-format",
    "title": "9  Taxonomic validation",
    "section": "9.2 Name format",
    "text": "9.2 Name format\nDifferent data providers might use different formats in their taxonomic names to delineate between taxonomic ranks. It doesn’t matter which format your data uses as long as it remains consistent.\nAn an example, data from the ALA specifies subspecies of Acacia observations using \"subsp.\" in the scientific name, whereas subspecies of bird observations simply add an additional name.\n\n\nacacia &lt;- galah_call() |&gt;\n  identify(\"Acacia\") |&gt;\n  filter(year == 2018) |&gt;\n  atlas_occurrences()\n\nacacia |&gt;\n  filter(str_detect(scientificName, \"Acacia brunioides\")) |&gt;\n  distinct(scientificName)\n\n# A tibble: 2 × 1\n  scientificName                     \n  &lt;chr&gt;                              \n1 Acacia brunioides subsp. brunioides\n2 Acacia brunioides                  \n\nbirds &lt;- galah_call() |&gt;\n  identify(\"alcedinidae\") |&gt;\n  filter(year == 2023) |&gt;\n  atlas_occurrences()\n  \nbirds |&gt;\n  filter(str_detect(scientificName, \"Dacelo\")) |&gt;\n  distinct(scientificName)\n\n# A tibble: 6 × 1\n  scientificName                           \n  &lt;chr&gt;                                    \n1 Dacelo (Dacelo) novaeguineae             \n2 Dacelo (Dacelo) leachii                  \n3 Dacelo (Dacelo) novaeguineae novaeguineae\n4 Dacelo                                   \n5 Dacelo (Dacelo) leachii occidentalis     \n6 Dacelo (Dacelo) leachii leachii          \n\n\nAlthough both are correct, be sure to check your data to make sure that this naming format is consistent.",
    "crumbs": [
      "Ecological data cleaning",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Taxonomic validation</span>"
    ]
  },
  {
    "objectID": "3_cleaning_expert/taxonomic-validation.html#taxonomic-names-matching",
    "href": "3_cleaning_expert/taxonomic-validation.html#taxonomic-names-matching",
    "title": "9  Taxonomic validation",
    "section": "9.3 Taxonomic names matching",
    "text": "9.3 Taxonomic names matching\nIt’s not uncommon to receive data that contains some but not all taxonomic rank information. Missing this information can make it difficult to summarise data or create taxonomic visualisations later on.\nAs an example, here is a small sample of our inverts dataset. You’ll notice that we only have scientific_name, class and family information.\n\ninverts_sample &lt;- inverts |&gt;\n  slice(1234:1271)\n\ninverts_sample |&gt; print(n = 5)\n\n# A tibble: 38 × 9\n  record_id      scientific_name class family  year latitude longitude sensitive\n  &lt;chr&gt;          &lt;chr&gt;           &lt;chr&gt; &lt;chr&gt;  &lt;int&gt;    &lt;dbl&gt;     &lt;dbl&gt;     &lt;int&gt;\n1 76213a64-ed41… Helicotylenchu… chro… hoplo…    NA    -23.1      151.         0\n2 e74ec2f0-4cef… Iravadia (Irav… gast… irava…  1903    -16.5      140.         0\n3 340c2b82-6b85… Monomorium bic… inse… formi…  1998    -24.7      150.         0\n4 e7dc1fa1-6524… Saprosites men… inse… scara…  2004    -43.1      147.         0\n5 316ad303-efc6… Amitermes darw… inse… termi…  1953    -21.9      118.         0\n# ℹ 33 more rows\n# ℹ 1 more variable: project &lt;chr&gt;\n\n\nOne way to extract names is to search for names matches in a data infrastructure like the ALA, which has its own taxonomic backbone. We can extract the names from our inverts_sample and save the strings in taxa_sample_names…\n\ntaxa_sample_names &lt;- inverts_sample |&gt;\n  select(scientific_name) |&gt;\n  distinct() |&gt;\n  pull()\n\ntaxa_sample_names[1:5] # first 5 names\n\n[1] \"Helicotylenchus multicinctus\"        \"Iravadia (Iravadia) carpentariensis\"\n[3] \"Monomorium bicorne\"                  \"Saprosites mendax\"                  \n[5] \"Amitermes darwini\"                  \n\n\n…and use those names to search using search_taxa() from galah. We’ll save the results in names_matches_ala.\n\n\n\n\n\n\nSearch tip\n\n\n\n\n\nAnytime you search for taxonomic matches using names, it’s good to double check the urls in taxon_concept_id to make sure your search matched the result you expected!\n\n\n\n\nnames_matches_ala &lt;- search_taxa(taxa_sample_names)\nnames_matches_ala\n\n# A tibble: 38 × 15\n   search_term     scientific_name scientific_name_auth…¹ taxon_concept_id rank \n   &lt;chr&gt;           &lt;chr&gt;           &lt;chr&gt;                  &lt;chr&gt;            &lt;chr&gt;\n 1 Helicotylenchu… Helicotylenchu… (Cobb, 1893)           https://biodive… spec…\n 2 Iravadia (Irav… Iravadia (Irav… (Hedley, 1912)         https://biodive… spec…\n 3 Monomorium bic… Chelaner bicor… (Forel, 1907)          https://biodive… spec…\n 4 Saprosites men… Saprosites men… (Blackburn, 1892)      https://biodive… spec…\n 5 Amitermes darw… Amitermes darw… (Hill, 1922)           https://biodive… spec…\n 6 Schedorhinoter… Schedorhinoter… (Hill, 1933)           https://biodive… spec…\n 7 Sorama bicolor  Sorama bicolor  Walker, 1855           https://biodive… spec…\n 8 Windbalea warr… Windbalea warr… Rentz, 1993            https://biodive… spec…\n 9 Tholymis tilla… Tholymis tilla… (Fabricius, 1798)      https://biodive… spec…\n10 Costellipitar … Costellipitar … (Hedley, 1923)         https://biodive… spec…\n# ℹ 28 more rows\n# ℹ abbreviated name: ¹​scientific_name_authorship\n# ℹ 10 more variables: match_type &lt;chr&gt;, kingdom &lt;chr&gt;, phylum &lt;chr&gt;,\n#   class &lt;chr&gt;, order &lt;chr&gt;, family &lt;chr&gt;, genus &lt;chr&gt;, species &lt;chr&gt;,\n#   vernacular_name &lt;chr&gt;, issues &lt;chr&gt;\n\n\nNow we can merge this information into our inverts_sample data. First, let’s select and rename columns from our search that we want to join with inverts_sample. We’ll add an \"_ala\" suffix to each column name so we can tell apart our data from the ALA from the data already in our data set.\n\nnames_matches_renamed &lt;- names_matches_ala |&gt;\n  select(scientific_name, kingdom:species) |&gt;\n1  rename_with(\\(column_name) paste0(column_name, \"_ala\"),\n              kingdom:species)\nnames_matches_renamed\n\n\n1\n\nThis line uses shorthand to write a function to append a suffix to a column name. An equivalent way of writing this is: function(column_name) {paste0(column_name, \"_ala)}This is applied to each column name from kingdom to species in the names_matches_ala dataframe.\n\n\n\n\n# A tibble: 38 × 8\n   scientific_name         kingdom_ala phylum_ala class_ala order_ala family_ala\n   &lt;chr&gt;                   &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;     \n 1 Helicotylenchus multic… Animalia    Nematoda   Chromado… Panagrol… Hoplolaim…\n 2 Iravadia (Iravadia) ca… Animalia    Mollusca   Gastropo… Hypsogas… Iravadiid…\n 3 Chelaner bicorne        Animalia    Arthropoda Insecta   Hymenopt… Formicidae\n 4 Saprosites mendax       Animalia    Arthropoda Insecta   Coleopte… Scarabaei…\n 5 Amitermes darwini       Animalia    Arthropoda Insecta   Blattodea Termitidae\n 6 Schedorhinotermes actu… Animalia    Arthropoda Insecta   Blattodea Rhinoterm…\n 7 Sorama bicolor          Animalia    Arthropoda Insecta   Lepidopt… Notodonti…\n 8 Windbalea warrooa       Animalia    Arthropoda Insecta   Orthopte… Tettigoni…\n 9 Tholymis tillarga       Animalia    Arthropoda Insecta   Odonata   Libelluli…\n10 Costellipitar inconsta… Animalia    Mollusca   Bivalvia  Cardiida  Veneridae \n# ℹ 28 more rows\n# ℹ 2 more variables: genus_ala &lt;chr&gt;, species_ala &lt;chr&gt;\n\n\nNow let’s join our matched names to our inverts_sample data.\n\ninverts_sample_with_ranks &lt;- names_matches_renamed |&gt;\n  right_join(inverts_sample,                          # join to `inverts_sample`\n             join_by(scientific_name == scientific_name)\n             )\ninverts_sample_with_ranks\n\n# A tibble: 38 × 16\n   scientific_name         kingdom_ala phylum_ala class_ala order_ala family_ala\n   &lt;chr&gt;                   &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;     \n 1 Helicotylenchus multic… Animalia    Nematoda   Chromado… Panagrol… Hoplolaim…\n 2 Iravadia (Iravadia) ca… Animalia    Mollusca   Gastropo… Hypsogas… Iravadiid…\n 3 Saprosites mendax       Animalia    Arthropoda Insecta   Coleopte… Scarabaei…\n 4 Amitermes darwini       Animalia    Arthropoda Insecta   Blattodea Termitidae\n 5 Schedorhinotermes actu… Animalia    Arthropoda Insecta   Blattodea Rhinoterm…\n 6 Sorama bicolor          Animalia    Arthropoda Insecta   Lepidopt… Notodonti…\n 7 Windbalea warrooa       Animalia    Arthropoda Insecta   Orthopte… Tettigoni…\n 8 Tholymis tillarga       Animalia    Arthropoda Insecta   Odonata   Libelluli…\n 9 Costellipitar inconsta… Animalia    Mollusca   Bivalvia  Cardiida  Veneridae \n10 Placamen lamellosum     Animalia    Mollusca   Bivalvia  Cardiida  Veneridae \n# ℹ 28 more rows\n# ℹ 10 more variables: genus_ala &lt;chr&gt;, species_ala &lt;chr&gt;, record_id &lt;chr&gt;,\n#   class &lt;chr&gt;, family &lt;chr&gt;, year &lt;int&gt;, latitude &lt;dbl&gt;, longitude &lt;dbl&gt;,\n#   sensitive &lt;int&gt;, project &lt;chr&gt;\n\n\nWe can check whether our new names match what was already in our data set to verify whether our matches were broadly correct. We’ll use filter() to return rows where family_ala does not equal family. Nothing is returned by our search, meaning the names in family_ala and family all match!\n\ninverts_sample_with_ranks |&gt;\n  select(scientific_name, family_ala, family) |&gt;\n  mutate(family = stringr::str_to_sentence(family)) |&gt; # match formatting\n  filter(family_ala != family)\n\n# A tibble: 0 × 3\n# ℹ 3 variables: scientific_name &lt;chr&gt;, family_ala &lt;chr&gt;, family &lt;chr&gt;",
    "crumbs": [
      "Ecological data cleaning",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Taxonomic validation</span>"
    ]
  },
  {
    "objectID": "3_cleaning_expert/taxonomic-validation.html#mismatches-in-higher-taxonomic-ranks",
    "href": "3_cleaning_expert/taxonomic-validation.html#mismatches-in-higher-taxonomic-ranks",
    "title": "9  Taxonomic validation",
    "section": "9.4 Mismatches in higher taxonomic ranks",
    "text": "9.4 Mismatches in higher taxonomic ranks\nHigher taxonomy from different data providers may not always match. If this is the case, you will need to back-fill the higher taxonomic ranks using data from your preferred taxonomic naming authority.\nLet’s use data of Eucalyptus observations we downloaded from the ALA as an example.\n\neucalypts\n\n# A tibble: 8,467 × 16\n   recordID       scientificName taxonConceptID decimalLatitude decimalLongitude\n   &lt;chr&gt;          &lt;chr&gt;          &lt;chr&gt;                    &lt;dbl&gt;            &lt;dbl&gt;\n 1 0009ba6a-8e8e… Eucalyptus re… https://id.bi…           -17.6             145.\n 2 002b74ab-b8ce… Eucalyptus ca… https://id.bi…           -34.2             141.\n 3 002bde6c-3a7f… Eucalyptus co… https://id.bi…           -30.1             146.\n 4 002cb2ce-c8a1… Eucalyptus ca… https://id.bi…           -37.1             141.\n 5 0031022c-8e9e… Eucalyptus la… https://id.bi…           -34.4             142.\n 6 00407506-383e… Eucalyptus pa… https://id.bi…           -34.1             151.\n 7 004413ca-5a95… Eucalyptus po… https://id.bi…           -35.3             149.\n 8 005371a8-047e… Eucalyptus ca… https://id.bi…           -35.7             145.\n 9 00560db1-bb66… Eucalyptus da… https://id.bi…           -36.3             148.\n10 005fcf1f-3c6f… Eucalyptus no… https://id.bi…           -30.4             152.\n# ℹ 8,457 more rows\n# ℹ 11 more variables: eventDate &lt;dttm&gt;, occurrenceStatus &lt;chr&gt;,\n#   dataResourceName &lt;chr&gt;, kingdom &lt;chr&gt;, phylum &lt;chr&gt;, class &lt;chr&gt;,\n#   order &lt;chr&gt;, family &lt;chr&gt;, genus &lt;chr&gt;, species &lt;chr&gt;, taxonRank &lt;chr&gt;\n\n\nThis occurrence data contains observations of over 373 species.\n\neucalypts |&gt;\n  filter(taxonRank != \"genus\") |&gt;\n  distinct(scientificName) |&gt;\n  count(name = \"n_species\")\n\n# A tibble: 1 × 1\n  n_species\n      &lt;int&gt;\n1       373\n\n\nLet’s say we want to compare these observations to data retrieved outside of the ALA and decide that we’d prefer to use GBIF’s1 taxonomy. Our data is from the ALA, which uses its own taxonomic backbone that differs to GBIF’s (depending on the taxonomic group). Let’s go through the steps to match our taxonomy in our eucalypts data to GBIF’s taxonomy.\nWe can download a species list of Eucalyptus from GBIF. This list returns nearly 1,700 species names!\n\n# This is the original query to download our species list\n# It takes several minutes to download\ngbif_species_list &lt;- request_data(\"species\") |&gt;\n  identify(\"Eucalyptus\") |&gt;\n  collect()\n\ngbif_species_list\n\n\n\nCode to load local version of species list\n# load species list\ngbif_species_list &lt;- arrow::read_parquet(\n  here::here(\"data\", \"lists\", \"gbif_eucalyptus\")) |&gt;\n  collect()\n\ngbif_species_list\n\n\n# A tibble: 1,695 × 22\n   taxonKey scientificName               acceptedTaxonKey acceptedScientificName\n *    &lt;dbl&gt; &lt;chr&gt;                                   &lt;dbl&gt; &lt;chr&gt;                 \n 1  3176716 Eucalyptus calcicola Brooker          3176716 Eucalyptus calcicola …\n 2  3176802 Eucalyptus salicola Brooker           3176802 Eucalyptus salicola B…\n 3  3176920 Eucalyptus crebra F.Muell.            3176920 Eucalyptus crebra F.M…\n 4  3177269 Eucalyptus stricta Sieber e…          3177269 Eucalyptus stricta Si…\n 5  3717566 Eucalyptus alpina Lindl.              3717566 Eucalyptus alpina Lin…\n 6  8164544 Eucalyptus hemiphloia var. …          7908015 Eucalyptus albens Miq.\n 7  9292334 Eucalyptus goniocalyx subsp…          9292334 Eucalyptus goniocalyx…\n 8 11127669 Eucalyptus griffithii Maiden         11127669 Eucalyptus griffithii…\n 9  3176297 Eucalyptus camfieldii Maiden          3176297 Eucalyptus camfieldii…\n10  3176473 Eucalyptus macrorhyncha sub…          3176473 Eucalyptus macrorhync…\n# ℹ 1,685 more rows\n# ℹ 18 more variables: numberOfOccurrences &lt;dbl&gt;, taxonRank &lt;chr&gt;,\n#   taxonomicStatus &lt;chr&gt;, kingdom &lt;chr&gt;, kingdomKey &lt;dbl&gt;, phylum &lt;chr&gt;,\n#   phylumKey &lt;dbl&gt;, class &lt;chr&gt;, classKey &lt;dbl&gt;, order &lt;chr&gt;, orderKey &lt;dbl&gt;,\n#   family &lt;chr&gt;, familyKey &lt;dbl&gt;, genus &lt;chr&gt;, genusKey &lt;dbl&gt;, species &lt;chr&gt;,\n#   speciesKey &lt;dbl&gt;, iucnRedListCategory &lt;chr&gt;\n\n\nTo investigate whether the complete taxonomy—from kingdom to species—matches between our ALA data and GBIF species list, let’s get the columns with taxonomic information from our eucalypts dataframe and our gbif_species_list to compare.\nFirst, we can select the taxonomic rank columns in our ALA eucalypts dataframe (kingdom to species) and use distinct() to remove duplicate rows. This will leave us with one row for each distinct species in our dataset (very similar to a species list).\n\nala_ranks &lt;- eucalypts |&gt;\n  select(kingdom:species) |&gt;\n  distinct()\n\nala_ranks\n\n# A tibble: 312 × 7\n   kingdom phylum     class         order    family    genus      species       \n   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;         &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;      &lt;chr&gt;         \n 1 Plantae Charophyta Equisetopsida Myrtales Myrtaceae Eucalyptus Eucalyptus re…\n 2 Plantae Charophyta Equisetopsida Myrtales Myrtaceae Eucalyptus Eucalyptus ca…\n 3 Plantae Charophyta Equisetopsida Myrtales Myrtaceae Eucalyptus Eucalyptus co…\n 4 Plantae Charophyta Equisetopsida Myrtales Myrtaceae Eucalyptus Eucalyptus la…\n 5 Plantae Charophyta Equisetopsida Myrtales Myrtaceae Eucalyptus Eucalyptus pa…\n 6 Plantae Charophyta Equisetopsida Myrtales Myrtaceae Eucalyptus Eucalyptus po…\n 7 Plantae Charophyta Equisetopsida Myrtales Myrtaceae Eucalyptus Eucalyptus da…\n 8 Plantae Charophyta Equisetopsida Myrtales Myrtaceae Eucalyptus Eucalyptus no…\n 9 Plantae Charophyta Equisetopsida Myrtales Myrtaceae Eucalyptus Eucalyptus pl…\n10 Plantae Charophyta Equisetopsida Myrtales Myrtaceae Eucalyptus Eucalyptus me…\n# ℹ 302 more rows\n\n\nNow let’s filter gbif_species_list to only “accepted” names2 and select the same taxonomic rank columns.\n\ngbif_ranks &lt;- gbif_species_list |&gt;\n  filter(taxonomicStatus == \"ACCEPTED\") |&gt; # accepted names\n  select(kingdom:species) |&gt; \n  select(!contains(\"Key\")) |&gt; # remove Key columns\n1  distinct()\n\ngbif_ranks\n\n\n1\n\nWe added distinct() to remove duplicate rows of species names. These duplicates appear because there might be multiple subspecies under the same species name. For example, Eucalyptus mannifera has 4 subspecies; Eucalyptus wimmerensis has 5. We aren’t interested in identifying species at that level, and so we remove these duplicates to simplify our species list.\n\n\n\n\n# A tibble: 989 × 7\n   kingdom phylum       class         order    family    genus      species     \n   &lt;chr&gt;   &lt;chr&gt;        &lt;chr&gt;         &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;      &lt;chr&gt;       \n 1 Plantae Tracheophyta Magnoliopsida Myrtales Myrtaceae Eucalyptus Eucalyptus …\n 2 Plantae Tracheophyta Magnoliopsida Myrtales Myrtaceae Eucalyptus Eucalyptus …\n 3 Plantae Tracheophyta Magnoliopsida Myrtales Myrtaceae Eucalyptus Eucalyptus …\n 4 Plantae Tracheophyta Magnoliopsida Myrtales Myrtaceae Eucalyptus Eucalyptus …\n 5 Plantae Tracheophyta Magnoliopsida Myrtales Myrtaceae Eucalyptus Eucalyptus …\n 6 Plantae Tracheophyta Magnoliopsida Myrtales Myrtaceae Eucalyptus Eucalyptus …\n 7 Plantae Tracheophyta Magnoliopsida Myrtales Myrtaceae Eucalyptus Eucalyptus …\n 8 Plantae Tracheophyta Magnoliopsida Myrtales Myrtaceae Eucalyptus Eucalyptus …\n 9 Plantae Tracheophyta Magnoliopsida Myrtales Myrtaceae Eucalyptus Eucalyptus …\n10 Plantae Tracheophyta Magnoliopsida Myrtales Myrtaceae Eucalyptus Eucalyptus …\n# ℹ 979 more rows\n\n\nWe can merge our taxonomic rank dataframes together, matching by species name. We’ll distinguish which columns came from each dataframe by appending an \"_ala\" or \"_gbif\" suffix.\n\nmatched_names &lt;- ala_ranks |&gt;\n  left_join(gbif_ranks, \n            join_by(species == species), \n            suffix = c(\"_ala\", \"_gbif\")) |&gt;\n  select(species, everything()) # reorder columns\n\nmatched_names now contains the full taxonomy from the ALA and GBIF for all matched species3.\n\nrmarkdown::paged_table( # print paged table\n  matched_names\n  )\n\n\n  \n\n\n\nAfter matching our names in this way, we can now compare taxonomic rank columns to find mismatches. For example, we can find any species with a mismatch in their kingdom name by filtering to rows where kingdom_ala and kingdom_gbif are not equal. Our returned tibble is empty, meaning there were no mismatches.\n\nmatched_names |&gt;\n  filter(kingdom_ala != kingdom_gbif)\n\n# A tibble: 0 × 13\n# ℹ 13 variables: species &lt;chr&gt;, kingdom_ala &lt;chr&gt;, phylum_ala &lt;chr&gt;,\n#   class_ala &lt;chr&gt;, order_ala &lt;chr&gt;, family_ala &lt;chr&gt;, genus_ala &lt;chr&gt;,\n#   kingdom_gbif &lt;chr&gt;, phylum_gbif &lt;chr&gt;, class_gbif &lt;chr&gt;, order_gbif &lt;chr&gt;,\n#   family_gbif &lt;chr&gt;, genus_gbif &lt;chr&gt;\n\n\nIf we do the same for phylum and class, however, we return quite a few results.\n\nphylumclass\n\n\n\nmatched_names |&gt;\n  filter(phylum_ala != phylum_gbif) |&gt;\n  select(species, phylum_ala, phylum_gbif)\n\n# A tibble: 303 × 3\n   species                   phylum_ala phylum_gbif \n   &lt;chr&gt;                     &lt;chr&gt;      &lt;chr&gt;       \n 1 Eucalyptus resinifera     Charophyta Tracheophyta\n 2 Eucalyptus camaldulensis  Charophyta Tracheophyta\n 3 Eucalyptus coolabah       Charophyta Tracheophyta\n 4 Eucalyptus largiflorens   Charophyta Tracheophyta\n 5 Eucalyptus parramattensis Charophyta Tracheophyta\n 6 Eucalyptus polyanthemos   Charophyta Tracheophyta\n 7 Eucalyptus dalrympleana   Charophyta Tracheophyta\n 8 Eucalyptus nobilis        Charophyta Tracheophyta\n 9 Eucalyptus planchoniana   Charophyta Tracheophyta\n10 Eucalyptus melliodora     Charophyta Tracheophyta\n# ℹ 293 more rows\n\n\n\n\n\nmatched_names |&gt;\n  filter(class_ala != class_gbif) |&gt;\n  select(species, class_ala, class_gbif)\n\n# A tibble: 303 × 3\n   species                   class_ala     class_gbif   \n   &lt;chr&gt;                     &lt;chr&gt;         &lt;chr&gt;        \n 1 Eucalyptus resinifera     Equisetopsida Magnoliopsida\n 2 Eucalyptus camaldulensis  Equisetopsida Magnoliopsida\n 3 Eucalyptus coolabah       Equisetopsida Magnoliopsida\n 4 Eucalyptus largiflorens   Equisetopsida Magnoliopsida\n 5 Eucalyptus parramattensis Equisetopsida Magnoliopsida\n 6 Eucalyptus polyanthemos   Equisetopsida Magnoliopsida\n 7 Eucalyptus dalrympleana   Equisetopsida Magnoliopsida\n 8 Eucalyptus nobilis        Equisetopsida Magnoliopsida\n 9 Eucalyptus planchoniana   Equisetopsida Magnoliopsida\n10 Eucalyptus melliodora     Equisetopsida Magnoliopsida\n# ℹ 293 more rows\n\n\n\n\n\nIt turns out that there is a difference between the ALA and GBIF in their higher taxonomic ranks of Eucalyptus plants.\nIn GBIF, Eucalyptus sits in the phylum Tracheophyta and the class Magnoliopsida…\n\n# Use GBIF\ngalah_config(atlas = \"gbif\")\n\nAtlas selected: Global Biodiversity Information Facility (GBIF) [Global]\n\n# Search for taxonomic information\ngbif_taxa &lt;- search_taxa(\"eucalyptus\")\n\n# Show relevant columns\ngbif_taxa |&gt;\n  select(scientific_name, phylum, class, order)\n\n# A tibble: 1 × 4\n  scientific_name   phylum       class         order   \n  &lt;chr&gt;             &lt;chr&gt;        &lt;chr&gt;         &lt;chr&gt;   \n1 Eucalyptus L'Hér. Tracheophyta Magnoliopsida Myrtales\n\n\n…whereas in the ALA, Eucalyptus sits in the phylum Charophyta and the class Equisetopsida.\n\n# Switch to download from the ALA\ngalah_config(atlas = \"ala\")\n\nAtlas selected: Atlas of Living Australia (ALA) [Australia]\n\n# Search for taxonomic information\nala_taxa &lt;- search_taxa(\"Eucalyptus\")\n\n# Show relevant columns\nala_taxa |&gt;\n  select(scientific_name, phylum, class, order)\n\n# A tibble: 1 × 4\n  scientific_name phylum     class         order   \n  &lt;chr&gt;           &lt;chr&gt;      &lt;chr&gt;         &lt;chr&gt;   \n1 Eucalyptus      Charophyta Equisetopsida Myrtales\n\n\nWe might not know about this issue when we first decide to match GBIF’s taxonomic names to our data. So it’s important to investigate how well these names match (and where there are any mismatches) before merging them to our data.\nIf you are using a taxonomy from ALA or GBIF, you can use search_taxa() in galah to see which names match before you download a species list. For example, we can search for all the species names in our eucalypts dataframe.\n\ngalah_config(atlas = \"gbif\")\n\n# search (this takes ~60 seconds)\nnames_search_results &lt;- \n  eucalypts |&gt;\n  pull(species) |&gt; # pull out species names\n  unique() |&gt;      # remove duplicate names\n  search_taxa()    # search\n\nnames_search_results\n\n\n\nAtlas selected: Global Biodiversity Information Facility (GBIF) [Global]\n\n\n# A tibble: 312 × 14\n   search_term      scientific_name taxon_concept_id canonical_name status rank \n   &lt;chr&gt;            &lt;chr&gt;                      &lt;int&gt; &lt;chr&gt;          &lt;chr&gt;  &lt;chr&gt;\n 1 Eucalyptus resi… Eucalyptus res…          3176649 Eucalyptus re… ACCEP… SPEC…\n 2 Eucalyptus cama… Eucalyptus cam…         11869920 Eucalyptus ca… ACCEP… SPEC…\n 3 Eucalyptus cool… Eucalyptus coo…          3177229 Eucalyptus co… ACCEP… SPEC…\n 4 Eucalyptus larg… Eucalyptus lar…          3177036 Eucalyptus la… ACCEP… SPEC…\n 5 Eucalyptus parr… Eucalyptus par…          3176265 Eucalyptus pa… ACCEP… SPEC…\n 6 Eucalyptus poly… Eucalyptus pol…          3176703 Eucalyptus po… ACCEP… SPEC…\n 7 Eucalyptus dalr… Eucalyptus dal…          3177157 Eucalyptus da… ACCEP… SPEC…\n 8 Eucalyptus nobi… Eucalyptus nob…          3177115 Eucalyptus no… ACCEP… SPEC…\n 9 Eucalyptus plan… Eucalyptus pla…          3176639 Eucalyptus pl… ACCEP… SPEC…\n10 Eucalyptus mell… Eucalyptus mel…          3176794 Eucalyptus me… ACCEP… SPEC…\n# ℹ 302 more rows\n# ℹ 8 more variables: match_type &lt;chr&gt;, kingdom &lt;chr&gt;, phylum &lt;chr&gt;,\n#   class &lt;chr&gt;, order &lt;chr&gt;, family &lt;chr&gt;, genus &lt;chr&gt;, species &lt;chr&gt;\n\n\nOur search has found several mismatches in higher taxonomic ranks. If we are happy with these differences, we can merge our taxonomic rank columns from GBIF with our eucalypt occurrences data4.\n\nmatched_names |&gt;\n  select(species, kingdom_gbif:genus_gbif) |&gt;\n  right_join(eucalypts,\n             join_by(species == species)) |&gt;\n  select(-(kingdom:genus)) |&gt; # remove ALA taxonomic columns\n  rename_with(                # rename columns...\n    ~ str_remove(., \"_gbif\"), # ...by removing \"_gbif\" suffix \n    kingdom_gbif:genus_gbif\n    ) |&gt; \n  rmarkdown::paged_table()    # paged table output",
    "crumbs": [
      "Ecological data cleaning",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Taxonomic validation</span>"
    ]
  },
  {
    "objectID": "3_cleaning_expert/taxonomic-validation.html#detecting-synonyms",
    "href": "3_cleaning_expert/taxonomic-validation.html#detecting-synonyms",
    "title": "9  Taxonomic validation",
    "section": "9.5 Detecting synonyms",
    "text": "9.5 Detecting synonyms\nScientific discoveries and advances in taxonomic classification can cause taxonomic names to change. A taxonomic synonym refers to a scientific name that a taxon that goes by a different name. Synonyms can come about when a taxon was once referred to a taxon that has since had its accepted scientific name changed. Synonyms are important because older records referred to by a synonym can still be searched for and linked to other taxonomic records.\nSynonyms can be tricky to deal with during data cleaning because they can be difficult to spot. Here are several examples of synonyms.\n\n\n\nLitoria caerulea sitting on some tiles.Photo by Thomas Mesaglio CC-BY 4.0 (Int)\n\n\n\n\nAndrocalva rosea flowering.Photo by Will Cornwell CC-BY 4.0 (Int)\n\n\nFrogsMallows\n\n\nRanoidea caerulea is a synonym of Litoria caerulea, a species of frog. The genus and species returned differs between GBIF and the ALA.\n\ngalah_config(atlas = \"gbif\")\ngbif_taxa &lt;- search_taxa(\"Litoria caerulea\")\n\ngbif_taxa |&gt; \n  select(scientific_name, genus, species)\n\n# A tibble: 1 × 3\n  scientific_name                genus    species          \n  &lt;chr&gt;                          &lt;chr&gt;    &lt;chr&gt;            \n1 Litoria caerulea (White, 1790) Ranoidea Ranoidea caerulea\n\n\n\ngalah_config(atlas = \"ala\")\nala_taxa &lt;- search_taxa(\"Litoria caerulea\")\n\nala_taxa |&gt;\n  select(scientific_name, genus, species)\n\n# A tibble: 1 × 3\n  scientific_name  genus   species         \n  &lt;chr&gt;            &lt;chr&gt;   &lt;chr&gt;           \n1 Litoria caerulea Litoria Litoria caerulea\n\n\n\n\n\nCommersonia rosea is a synonym of Androcalva rosea, a species of mallow. The scientific name returned differs between GBIF and the ALA (ALA autocorrects this synonym whereas GBIF retains its synonym name).\n\ngalah_config(atlas = \"gbif\")\ngbif_taxa &lt;- search_taxa(\"commersonia rosea\")\n\ngbif_taxa |&gt; \n  select(scientific_name, genus, species)\n\n# A tibble: 1 × 3\n  scientific_name                           genus      species         \n  &lt;chr&gt;                                     &lt;chr&gt;      &lt;chr&gt;           \n1 Commersonia rosea S.A.J.Bell & L.M.Copel. Androcalva Androcalva rosea\n\n\n\ngalah_config(atlas = \"ala\")\nala_taxa &lt;- search_taxa(\"commersonia rosea\")\n\nala_taxa |&gt; \n  select(scientific_name, genus, species)\n\n# A tibble: 1 × 3\n  scientific_name  genus      species         \n  &lt;chr&gt;            &lt;chr&gt;      &lt;chr&gt;           \n1 Androcalva rosea Androcalva Androcalva rosea\n\n\n\n\n\n\nUsing tools like search_taxa() in galah is a useful way to check whether a search returns the taxonomic information you expect.\n\n9.5.1 Checking for synonyms\nSome species lists return accepted names and synonyms. For example, here is a species list of Eucalyptus downloaded from GBIF.\n\n# This is the original query to download our species list\n# It takes several minutes to download\ngbif_species_list &lt;- request_data(\"species\") |&gt;\n  identify(\"Eucalyptus\") |&gt;\n  collect()\n\ngbif_species_list\n\n\n\nCode to load local version of species list\n# load species list\ngbif_species_list &lt;- arrow::read_parquet(\n  here::here(\"data\", \"lists\", \"gbif_eucalyptus\")) |&gt;\n  collect()\n\ngbif_species_list\n\n\n# A tibble: 1,695 × 22\n   taxonKey scientificName               acceptedTaxonKey acceptedScientificName\n *    &lt;dbl&gt; &lt;chr&gt;                                   &lt;dbl&gt; &lt;chr&gt;                 \n 1  3176716 Eucalyptus calcicola Brooker          3176716 Eucalyptus calcicola …\n 2  3176802 Eucalyptus salicola Brooker           3176802 Eucalyptus salicola B…\n 3  3176920 Eucalyptus crebra F.Muell.            3176920 Eucalyptus crebra F.M…\n 4  3177269 Eucalyptus stricta Sieber e…          3177269 Eucalyptus stricta Si…\n 5  3717566 Eucalyptus alpina Lindl.              3717566 Eucalyptus alpina Lin…\n 6  8164544 Eucalyptus hemiphloia var. …          7908015 Eucalyptus albens Miq.\n 7  9292334 Eucalyptus goniocalyx subsp…          9292334 Eucalyptus goniocalyx…\n 8 11127669 Eucalyptus griffithii Maiden         11127669 Eucalyptus griffithii…\n 9  3176297 Eucalyptus camfieldii Maiden          3176297 Eucalyptus camfieldii…\n10  3176473 Eucalyptus macrorhyncha sub…          3176473 Eucalyptus macrorhync…\n# ℹ 1,685 more rows\n# ℹ 18 more variables: numberOfOccurrences &lt;dbl&gt;, taxonRank &lt;chr&gt;,\n#   taxonomicStatus &lt;chr&gt;, kingdom &lt;chr&gt;, kingdomKey &lt;dbl&gt;, phylum &lt;chr&gt;,\n#   phylumKey &lt;dbl&gt;, class &lt;chr&gt;, classKey &lt;dbl&gt;, order &lt;chr&gt;, orderKey &lt;dbl&gt;,\n#   family &lt;chr&gt;, familyKey &lt;dbl&gt;, genus &lt;chr&gt;, genusKey &lt;dbl&gt;, species &lt;chr&gt;,\n#   speciesKey &lt;dbl&gt;, iucnRedListCategory &lt;chr&gt;\n\n\nGBIF species lists include a taxonomicStatus column that supplies information of whether a taxonomic name is accepted or a synonym. A good example is the list of names for Eucalyptus leucoxylon, which has a number of accepted subspecies names and synonyms.\n\ngbif_species_list |&gt;\n  filter(species == \"Eucalyptus leucoxylon\") |&gt;\n  select(species, taxonomicStatus, acceptedScientificName)\n\n# A tibble: 18 × 3\n   species               taxonomicStatus acceptedScientificName                 \n   &lt;chr&gt;                 &lt;chr&gt;           &lt;chr&gt;                                  \n 1 Eucalyptus leucoxylon SYNONYM         Eucalyptus leucoxylon subsp. leucoxylon\n 2 Eucalyptus leucoxylon SYNONYM         Eucalyptus leucoxylon subsp. leucoxylon\n 3 Eucalyptus leucoxylon ACCEPTED        Eucalyptus leucoxylon subsp. megalocar…\n 4 Eucalyptus leucoxylon ACCEPTED        Eucalyptus leucoxylon F.Muell.         \n 5 Eucalyptus leucoxylon ACCEPTED        Eucalyptus leucoxylon subsp. connata R…\n 6 Eucalyptus leucoxylon SYNONYM         Eucalyptus leucoxylon F.Muell.         \n 7 Eucalyptus leucoxylon SYNONYM         Eucalyptus leucoxylon subsp. leucoxylon\n 8 Eucalyptus leucoxylon SYNONYM         Eucalyptus leucoxylon subsp. leucoxylon\n 9 Eucalyptus leucoxylon ACCEPTED        Eucalyptus leucoxylon subsp. leucoxylon\n10 Eucalyptus leucoxylon ACCEPTED        Eucalyptus leucoxylon var. pauperita J…\n11 Eucalyptus leucoxylon ACCEPTED        Eucalyptus leucoxylon subsp. stephania…\n12 Eucalyptus leucoxylon ACCEPTED        Eucalyptus leucoxylon subsp. bellarine…\n13 Eucalyptus leucoxylon SYNONYM         Eucalyptus leucoxylon subsp. megalocar…\n14 Eucalyptus leucoxylon ACCEPTED        Eucalyptus leucoxylon subsp. petiolari…\n15 Eucalyptus leucoxylon ACCEPTED        Eucalyptus leucoxylon subsp. pruinosa …\n16 Eucalyptus leucoxylon SYNONYM         Eucalyptus leucoxylon subsp. petiolari…\n17 Eucalyptus leucoxylon ACCEPTED        SH0881366.09FU                         \n18 Eucalyptus leucoxylon SYNONYM         Eucalyptus leucoxylon subsp. leucoxylon",
    "crumbs": [
      "Ecological data cleaning",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Taxonomic validation</span>"
    ]
  },
  {
    "objectID": "3_cleaning_expert/taxonomic-validation.html#detecting-homonyms",
    "href": "3_cleaning_expert/taxonomic-validation.html#detecting-homonyms",
    "title": "9  Taxonomic validation",
    "section": "9.6 Detecting homonyms",
    "text": "9.6 Detecting homonyms\nTaxonomy is a complex field of science to categorise millions of species on the taxonomic tree. With so many species to name and order taxonomically, sometimes one name can have identical spelling to another name in an entirely different place on the taxonomic tree.\nFor example, the name Morganella is a genus of bacteria, a genus of fungi, a genus of scale insect, and a genus of brachiopod from the Devonian period5!\nWhen you search for names with search_taxa() from the galah package, you’ll receive a warning that there is a homonym issue.\n\nsearch_taxa(\"morganella\")\n\nWarning: Search returned multiple taxa due to a homonym issue.\nℹ Please provide another rank in your search to clarify taxa.\nℹ Use a `tibble` to clarify taxa, see `?search_taxa`.\n✖ Homonym issue with \"morganella\".\n\n\n# A tibble: 1 × 2\n  search_term issues \n  &lt;chr&gt;       &lt;chr&gt;  \n1 morganella  homonym\n\n\nYou can to clarify the taxonomic name by providing other taxonomic ranks in a tibble. Using the taxon_concept_id rather than the name will enable you to retrieve data using the correct classification.\n\ntaxa &lt;- search_taxa(tibble(kingdom = \"Fungi\", genus = \"Morganella\"))\n\ntaxa |&gt; rmarkdown::paged_table()\n\n\n  \n\n\n# Return record counts, grouped by species\ngalah_call() |&gt;\n  identify(taxa$taxon_concept_id) |&gt;\n  group_by(species) |&gt;\n  atlas_counts()\n\n# A tibble: 2 × 2\n  species                 count\n  &lt;chr&gt;                   &lt;int&gt;\n1 Morganella compacta        88\n2 Morganella purpurascens    38\n\n\nFor more information on advanced taxonomic filtering in galah, you can read this vignette on the package website.",
    "crumbs": [
      "Ecological data cleaning",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Taxonomic validation</span>"
    ]
  },
  {
    "objectID": "3_cleaning_expert/taxonomic-validation.html#packages",
    "href": "3_cleaning_expert/taxonomic-validation.html#packages",
    "title": "9  Taxonomic validation",
    "section": "9.7 Packages",
    "text": "9.7 Packages\nThere are several packages available that can be used to query different taxonomic databases and check for synonyms.\n\nworrmstaxize\n\n\nThe worrms package is the R interface to the World Register of Marine Species (WoRMS). When working with data from this database, the worrms R package has the ability to cross-check synonyms in their database using their taxonomic ID (AphiaID).\nFor example, we can return existing synonyms for Lupocyclus inaequalis by supplying its AphiaID to the wm_synonyms() function.\n\nlibrary(worrms)\n\nmarine_sp &lt;- read_csv(here::here(\"data\",\n                                 \"worms\",\n                                 \"worms.csv\"))\n\nmarine_sp |&gt;\n  filter(scientificname == \"Lupocyclus inaequalis\") |&gt;\n  select(AphiaID, scientificname, status)\n\n# A tibble: 1 × 3\n  AphiaID scientificname        status  \n    &lt;dbl&gt; &lt;chr&gt;                 &lt;chr&gt;   \n1  208785 Lupocyclus inaequalis accepted\n\n\nOur search returns a superseded synonym Goniosoma inaequale.\n\nmarine_sp |&gt;\n  filter(scientificname == \"Lupocyclus inaequalis\") |&gt;\n  pull(AphiaID) |&gt;\n  wm_synonyms() |&gt;\n  select(AphiaID, scientificname, status)\n\n# A tibble: 1 × 3\n  AphiaID scientificname      status                \n    &lt;int&gt; &lt;chr&gt;               &lt;chr&gt;                 \n1  453207 Goniosoma inaequale superseded combination\n\n\n\n\nThe taxize package allows users to search over many taxonomic data sources for hierarchial taxonomic information, such as species names (scientific and common), to resolve synonyms and homonyms.\n\nSynonyms\nWe can match names against up to 118 data sources including GBIF, Catalogue of Life, World Register of Marine Species using gnr_resolve() and return one or more names scored by how well-matched they are to these sources.\nLet’s search for any synonyms of Litoria caerulea as an example.\n\nlibrary(taxize)\n\n# Resolve names\nresolved &lt;- gnr_resolve(unique(\"litoria caerulea\"), best_match_only = TRUE)\nresolved\n\n# A tibble: 1 × 5\n  user_supplied_name submitted_name   matched_name     data_source_title score\n* &lt;chr&gt;              &lt;chr&gt;            &lt;chr&gt;            &lt;chr&gt;             &lt;dbl&gt;\n1 litoria caerulea   Litoria caerulea Litoria caerulea Wikispecies       0.988\n\n\nUsing the resolved name, we can search for its Taxonomic Serial Number using get_tsn(), which taxize uses to as a taxonomic identifier. Then we can search for existing synonyms by supplying the tsn to the synonyms() function.\n\n# Retrieve synonyms\ntsn &lt;- get_tsn(resolved$matched_name)\n\n══  1 queries  ═══════════════\n\n\n\nRetrieving data for taxon 'Litoria caerulea'\n\n\n✔  Found:  Litoria caerulea\n══  Results  ═════════════════\n\n• Total: 1 \n• Found: 1 \n• Not Found: 0\n\nsynonyms(tsn)\n\nAccepted name(s) is/are 'Ranoidea caerulea'\n\n\nUsing tsn(s) 1099550\n\n\n$`662872`\n  sub_tsn          acc_name acc_tsn    acc_author     syn_author\n1  662872 Ranoidea caerulea 1099550 (White, 1790)  (White, 1790)\n2  662872 Ranoidea caerulea 1099550 (White, 1790)    White, 1790\n3  662872 Ranoidea caerulea 1099550 (White, 1790)   Daudin, 1803\n4  662872 Ranoidea caerulea 1099550 (White, 1790)  (White, 1790)\n5  662872 Ranoidea caerulea 1099550 (White, 1790)  (White, 1790)\n6  662872 Ranoidea caerulea 1099550 (White, 1790)   De Vis, 1884\n7  662872 Ranoidea caerulea 1099550 (White, 1790) (De Vis, 1884)\n8  662872 Ranoidea caerulea 1099550 (White, 1790) (De Vis, 1884)\n9  662872 Ranoidea caerulea 1099550 (White, 1790)  (White, 1790)\n                syn_name syn_tsn\n1       Litoria caerulea  662872\n2          Rana caerulea 1099551\n3            Hyla cyanea 1099552\n4     Pelodryas caerulea 1099553\n5          Hyla caerulea 1099554\n6          Hyla irrorata 1099555\n7       Litoria irrorata 1099556\n8     Pelodryas irrorata 1099557\n9 Hyla caerulea caerulea 1106142\n\n\n\n\nHomonyms\nIf a name matches multiple names, get_tsn_() will return all matches.\n\n# resolve morganella name\nresolved &lt;- gnr_resolve(\"morganella\", best_match_only = TRUE)\n\n# Retrieve matches\ntsn &lt;- get_tsn_(resolved$matched_name)\n\n\nRetrieving data for taxon 'Morganella'\n\ntsn\n\n$Morganella\n# A tibble: 8 × 4\n  tsn    scientificName               commonNames nameUsage\n  &lt;chr&gt;  &lt;chr&gt;                        &lt;chr&gt;       &lt;chr&gt;    \n1 200802 Morganella                   NA          valid    \n2 200803 Morganella conspicua         NA          valid    \n3 200804 Morganella longispina        NA          valid    \n4 957632 Morganella                   NA          valid    \n5 958592 Morganella morganii          NA          valid    \n6 963648 Morganella psychrotolerans   NA          valid    \n7 969527 Morganella morganii morganii NA          valid    \n8 969528 Morganella morganii sibonii  NA          valid    \n\n\nYou can then use each tsn number to return the complete classification of the taxonomic name.\n\n# Retrieve upstream taxonomy\n1classification(tsn$Morganella$tsn[1],\n               upto = \"family\", \n2               db = \"itis\"\n               )\n\n\n1\n\nIndexes the first number in the tsn column \"200902\"\n\n2\n\nSpecifies database\n\n\n\n\n$`200802`\n             name         rank     id\n1        Animalia      kingdom 202423\n2       Bilateria   subkingdom 914154\n3     Protostomia infrakingdom 914155\n4       Ecdysozoa  superphylum 914158\n5      Arthropoda       phylum  82696\n6        Hexapoda    subphylum 563886\n7         Insecta        class  99208\n8       Pterygota     subclass 100500\n9        Neoptera   infraclass 563890\n10   Paraneoptera   superorder 914214\n11      Hemiptera        order 103359\n12 Sternorrhyncha     suborder 109185\n13      Coccoidea  superfamily 109195\n14    Diaspididae       family 109198\n15     Morganella        genus 200802\n\nattr(,\"class\")\n[1] \"classification\"\nattr(,\"db\")\n[1] \"itis\"\n\n\n\nIf you are using a list of many names, you can use the other names to establish taxonomic context for matching by adding with_context = TRUE to gnr_resolve(). This context reduces the chances of returning taxonomic homonyms.\n\n# example:\nlist_of_names &lt;- c(\"name1\", \"name2\", \"name3\", ...)\n\nresolved &lt;- gnr_resolve(list_of_names, with_context = TRUE)",
    "crumbs": [
      "Ecological data cleaning",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Taxonomic validation</span>"
    ]
  },
  {
    "objectID": "3_cleaning_expert/taxonomic-validation.html#input-from-experts",
    "href": "3_cleaning_expert/taxonomic-validation.html#input-from-experts",
    "title": "9  Taxonomic validation",
    "section": "9.8 Input from experts",
    "text": "9.8 Input from experts\nProgrammatic solutions for validating taxonomy can only go so far. To obtain a high quality species list, it’s good practice to seek validation from experts. Museums or taxonomic societies are great sources of knowledge.\nHere is a list of some Australian taxonomic society groups to help validate taxonomies.\n\n9.8.1 Australian taxonomic society groups\nVERTEBRATES\n\nAmphibians and reptiles - Australian Herpetological Society\n\nBirds - Birdlife Australia\n\nFish - Australian Society for Fish Biology\n\nMammals - The Australian Mammal Society\n\nINVERTEBRATES\n\nArachnology - Australasian Arachnological Society\n\nEntomology - Australian Entomological Society\n\nMalacology - The Malacological Society of Australasia\n\nNematology - Australasian Association of Nematologists\n\n\n\n9.8.2 Global taxonomy\n\nGBIF taxonomic backbone - Uses over 100 different sources\nIntegrated Taxonomic Information System, ITIS - Authoritative taxonomic information on plants, animals, fungi, and microbes\nCatalogue of Life - Global taxonomic catalogue",
    "crumbs": [
      "Ecological data cleaning",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Taxonomic validation</span>"
    ]
  },
  {
    "objectID": "3_cleaning_expert/taxonomic-validation.html#recycle-bin",
    "href": "3_cleaning_expert/taxonomic-validation.html#recycle-bin",
    "title": "9  Taxonomic validation",
    "section": "9.9 Recycle bin",
    "text": "9.9 Recycle bin\n\n\nSeperators\nIn taxonomic data, separators (such as spaces and underscores) are found in scientific names and are used to delineate the genus and species name. While it is personal choice which separator you use, it is good practice to be consistent with your choice. Consistency ensures that unique values of scientific name truly reflects unique species and not due to inconsistencies.\nFor example, some plant species in the ALA like Acacia specify subspecies\n\nlibrary(arrow)\nlibrary(tidyverse)\nlibrary(janitor)\n\nplants &lt;- open_dataset(\"../data/dap/plants_subset\",\n  format = \"parquet\"\n) |&gt; collect()\n\n### Making some fake missing data for inverts in Class column\ninverts &lt;- open_dataset(\"../data/dap/inverts_subset\") |&gt; collect()\n\nset.seed(5)\ntobemissing &lt;- inverts |&gt;\n  filter(class == \"arachnida\") |&gt;\n  sample_frac(0.3) |&gt;\n  pull(scientific_name) |&gt;\n  unique()\n\ninverts &lt;- inverts |&gt;\n  mutate(class = ifelse(scientific_name %in% tobemissing, NA, class))\n\n\nlibrary(janitor)\n\nplants |&gt;\n  pull(scientific_name) |&gt;\n  tabyl() |&gt;\n  tibble()\n\nConsistent taxonomic formatting may not be an issue if you are downloading data from one single source such as the ALA where scientific names are already formatted consistently e.g. “Moloch horridus”. This may not be the case when consolidating data from multiple sources.\nBelow is code to create an underscore scientific name from one that is separated with a space. Remember to check your changes\n\nplants_updated &lt;- plants |&gt;\n  mutate(scientific_name_undersc = str_replace_all(scientific_name, \" \", \"_\"))\n\nplants_updated |&gt;\n  pull(scientific_name_undersc) |&gt;\n  tabyl() |&gt;\n  tibble()\n\n# A tibble: 623 × 3\n   `pull(plants_updated, scientific_name_undersc)`     n  percent\n   &lt;chr&gt;                                           &lt;int&gt;    &lt;dbl&gt;\n 1 Acacia_asparagoides                                 2 0.000962\n 2 Acacia_barakulensis                                 1 0.000481\n 3 Acacia_barringtonensis                              2 0.000962\n 4 Acacia_beadleana                                    1 0.000481\n 5 Acacia_betchei                                      6 0.00289 \n 6 Acacia_blayana                                      2 0.000962\n 7 Acacia_brunioides                                   1 0.000481\n 8 Acacia_brunioides_subsp._brunioides                 6 0.00289 \n 9 Acacia_brunioides_subsp._granitica                  1 0.000481\n10 Acacia_bulgaensis                                   3 0.00144 \n# ℹ 613 more rows\n\n\n\n\n\n\nGarraffoni, André RS, Thiago Q Araújo, Anete P Lourenço, Loretta Guidi, and Maria Balsamo. 2019. “Integrative Taxonomy of a New Redudasys Species (Gastrotricha: Macrodasyida) Sheds Light on the Invasion of Fresh Water Habitats by Macrodasyids.” Scientific Reports 9 (1): 2067.",
    "crumbs": [
      "Ecological data cleaning",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Taxonomic validation</span>"
    ]
  },
  {
    "objectID": "3_cleaning_expert/taxonomic-validation.html#footnotes",
    "href": "3_cleaning_expert/taxonomic-validation.html#footnotes",
    "title": "9  Taxonomic validation",
    "section": "",
    "text": "Global Biodiversity Infrastructure Facility (GBIF)↩︎\nGBIF’s species list is quite comprehensive, and it includes the taxonomicStatus of a name as “accepted”, “synonym”, “variety” or “doubtful”. To keep our example simpler, we are only using the accepted names.↩︎\nSeveral species names did not match to GBIF. In a complete data cleaning workflow, these should be investigated as the ALA and GBIF might use synonym names to describe the same species or subspecies.↩︎\nRemember that there were some names that did not match GBIF, meaning their taxonomic columns contain NA values. Be sure to either fix these issue before merging dataframes, or back-fill after merging dataframes. Otherwise, you might add missing data in your data set unintentionally!↩︎\nReferred to as “the Age of Fishes”, the Devonian Period occurred ~419 to ~359 million years ago.↩︎",
    "crumbs": [
      "Ecological data cleaning",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Taxonomic validation</span>"
    ]
  },
  {
    "objectID": "3_cleaning_expert/ecological-filtering.html",
    "href": "3_cleaning_expert/ecological-filtering.html",
    "title": "10  Ecological filtering",
    "section": "",
    "text": "10.0.1 Prerequisites\nIn this chapter we will use several datasets:\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(stringr)\nlibrary(janitor)\nlibrary(galah)\n\ngalah_config(email = Sys.getenv(\"ALA_EMAIL\"),\n             username = Sys.getenv(\"GBIF_USERNAME\"),\n             password = Sys.getenv(\"GBIF_PWD\"),\n             verbose = FALSE)\n\nplants &lt;- arrow::open_dataset(\"../data/dap/plants_subset\") |&gt; \n  dplyr::collect()",
    "crumbs": [
      "Ecological data cleaning",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Ecological filtering</span>"
    ]
  },
  {
    "objectID": "3_cleaning_expert/ecological-filtering.html#introduced-or-invasive-species",
    "href": "3_cleaning_expert/ecological-filtering.html#introduced-or-invasive-species",
    "title": "10  Ecological filtering",
    "section": "10.1 Introduced or invasive species",
    "text": "10.1 Introduced or invasive species\nIf your project requires only native species, we can filter out those records using lists available online.\n\ngalah\nThe ALA contains national and state-based conservation status lists. For example, if we wanted to use the Victorian Restricted Species list, we can do a text search for available lists for “victoria” using search_all(lists, \"victoria\").\n\nlist_results &lt;- search_all(lists, \"victoria\")\nlist_results\n\n# A tibble: 33 × 19\n   species_list_uid listName       listType dateCreated lastUpdated lastUploaded\n   &lt;chr&gt;            &lt;chr&gt;          &lt;chr&gt;    &lt;chr&gt;       &lt;chr&gt;       &lt;chr&gt;       \n 1 dr1266           \"2 b) Protect… LOCAL_L… 2014-07-31… 2017-02-15… 2017-02-15T…\n 2 dr1782           \"Advisory Lis… CONSERV… 2014-10-27… 2022-03-16… 2022-03-16T…\n 3 dr967            \"Advisory Lis… CONSERV… 2013-11-12… 2023-06-12… 2023-06-12T…\n 4 dr2504           \"ALT Waterbug… LOCAL_L… 2015-09-08… 2016-06-14… 2016-06-14T…\n 5 dr2683           \"Dung beetles… LOCAL_L… 2016-01-15… 2020-08-20… 2020-08-20T…\n 6 dr4890           \"Endangered P… CONSERV… 2016-05-07… 2016-06-14… 2016-06-14T…\n 7 dr17134          \"Endangered S… CONSERV… 2021-03-30… 2022-11-21… 2022-11-21T…\n 8 dr6635           \"Gippsland’s … LOCAL_L… 2016-11-15… 2016-11-15… 2016-11-15T…\n 9 dr9802           \"Great Victor… LOCAL_L… 2018-11-29… 2018-11-29… 2018-11-29T…\n10 dr7749           \"IBRA Great V… PROFILE  2017-06-19… 2017-07-03… 2017-07-03T…\n# ℹ 23 more rows\n# ℹ 13 more variables: lastMatched &lt;chr&gt;, username &lt;chr&gt;, itemCount &lt;int&gt;,\n#   region &lt;chr&gt;, isAuthoritative &lt;lgl&gt;, isInvasive &lt;lgl&gt;, isThreatened &lt;lgl&gt;,\n#   wkt &lt;chr&gt;, category &lt;chr&gt;, generalisation &lt;chr&gt;, authority &lt;chr&gt;,\n#   sdsType &lt;chr&gt;, looseSearch &lt;lgl&gt;\n\n\nFiltering our result to only authoritative lists can help us find official state lists.\n\nlist_results |&gt; \n  filter(isAuthoritative == TRUE)\n\n# A tibble: 2 × 19\n  species_list_uid listName        listType dateCreated lastUpdated lastUploaded\n  &lt;chr&gt;            &lt;chr&gt;           &lt;chr&gt;    &lt;chr&gt;       &lt;chr&gt;       &lt;chr&gt;       \n1 dr655            Victoria : Con… CONSERV… 2015-04-04… 2023-06-07… 2023-06-07T…\n2 dr490            Victorian Rest… SENSITI… 2013-06-23… 2023-07-11… 2023-06-14T…\n# ℹ 13 more variables: lastMatched &lt;chr&gt;, username &lt;chr&gt;, itemCount &lt;int&gt;,\n#   region &lt;chr&gt;, isAuthoritative &lt;lgl&gt;, isInvasive &lt;lgl&gt;, isThreatened &lt;lgl&gt;,\n#   wkt &lt;chr&gt;, category &lt;chr&gt;, generalisation &lt;chr&gt;, authority &lt;chr&gt;,\n#   sdsType &lt;chr&gt;, looseSearch &lt;lgl&gt;\n\n\nWe can get save this list by saving its contents using show_values(). Then we can use it identify any restricted species by matching names in restricted_species to names in our plants data.\nSTART HERE\n\n# add code to save list, then filter plants data\n\nWe can also use the species_list_uid to filter our queries prior to downloading data in galah.\n\ngalah_call() |&gt;\n  identify(\"plantae\") |&gt;\n  filter(species_list_uid == dr490) |&gt;\n  group_by(species) |&gt;\n  atlas_counts()\n\n# A tibble: 47 × 2\n   species                 count\n   &lt;chr&gt;                   &lt;int&gt;\n 1 Caladenia arenaria       1589\n 2 Gaultheria hispida       1408\n 3 Caladenia concolor        591\n 4 Thelymitra epipactoides   522\n 5 Pterostylis despectans    438\n 6 Caladenia tensa           296\n 7 Caladenia colorata        256\n 8 Prasophyllum frenchii     250\n 9 Caladenia fulva           245\n10 Caladenia valida          244\n# ℹ 37 more rows\n\n\n\n\nGRIIS\nHere we are using the list for Australia from the Global Register of Introduced and Invasive Species (GRIIS). After downloading this list, we read it into R, and exclude invasive species from our example dataset:\n\nlibrary(dplyr)\ngriis_ls &lt;- read.csv(\"../data/lists/GRIIS_Australia_20230331-121730.csv\")\nglimpse(griis_ls)\n\nRows: 2,979\nColumns: 16\n$ scientific_name                  &lt;chr&gt; \"Oenothera longiflora L.\", \"Lampranth…\n$ scientific_name_type             &lt;chr&gt; \"species\", \"species\", \"species\", \"spe…\n$ kingdom                          &lt;chr&gt; \"Plantae\", \"Plantae\", \"Plantae\", \"Pla…\n$ establishment_means              &lt;chr&gt; \"alien\", \"alien\", \"alien\", \"alien\", \"…\n$ is_invasive                      &lt;chr&gt; \"null\", \"null\", \"null\", \"null\", \"null…\n$ occurrence_status                &lt;chr&gt; \"present\", \"present\", \"present\", \"pre…\n$ checklist.name                   &lt;chr&gt; \"Australia\", \"Australia\", \"Australia\"…\n$ checklist.iso_countrycode_alpha3 &lt;chr&gt; \"AUS\", \"AUS\", \"AUS\", \"AUS\", \"AUS\", \"A…\n$ accepted_name.species            &lt;chr&gt; \"Oenothera longiflora\", \"Lampranthus …\n$ accepted_name.kingdom            &lt;chr&gt; \"Plantae\", \"Plantae\", \"Plantae\", \"Pla…\n$ accepted_name.phylum             &lt;chr&gt; \"Tracheophyta\", \"Tracheophyta\", \"Trac…\n$ accepted_name.class              &lt;chr&gt; \"Magnoliopsida\", \"Magnoliopsida\", \"Ma…\n$ accepted_name.order              &lt;chr&gt; \"Myrtales\", \"Caryophyllales\", \"Erical…\n$ accepted_name.family             &lt;chr&gt; \"Onagraceae\", \"Aizoaceae\", \"Ericaceae…\n$ accepted_name.habitat            &lt;chr&gt; \"[\\\"terrestrial\\\"]\", \"[\\\"terrestrial\\…\n$ accepted_name                    &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n\n# Check which species matched the GRIIS list\nmatches &lt;- filter(plants, scientific_name %in% griis_ls$accepted_name.species)\n\n# If you are happy with the matches, you can proceed to remove any records\n# that were matched\nplants_no_griis &lt;- filter(plants, !scientific_name %in% matches)\n\n\n\n\n\n\n\nTip\n\n\n\nYou can apply this concept of filtering to any list of species, or other fields, that you would like to exclude.",
    "crumbs": [
      "Ecological data cleaning",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Ecological filtering</span>"
    ]
  },
  {
    "objectID": "3_cleaning_expert/ecological-filtering.html#extinct-species",
    "href": "3_cleaning_expert/ecological-filtering.html#extinct-species",
    "title": "10  Ecological filtering",
    "section": "10.2 Extinct species",
    "text": "10.2 Extinct species\n\nIn most cases, a year filter applied during your download query should remove most extinct species. Nevertheless, it is important to cross check for extinct species. We can do this using the Interim Register of Marine and Nonmarine Genera (IRMNG). The list is comprehensive and actively maintained. However, much of the data doesn’t go down to species level. As such, we recommend using the following approach to find potentially extinct taxa and further investigate the records that are flagged.\nThe required files are organised by year and can be downloaded from here, and unzipped to your project directory. Below we process the downloaded files and then check for matches in our dataset.\n\nirmng_taxa &lt;- arrow::open_dataset(\"../data/lists/IRMNG_genera_DwCA_2023-05-19/taxon_subset\") |&gt;\n  collect()\n\nirmng_sp &lt;- arrow::open_dataset(\"../data/lists/IRMNG_genera_DwCA_2023-05-19/speciesprofile\") |&gt;\n  collect()\n\n\nlibrary(stringr)\ninverts &lt;- arrow::open_dataset(\"../data/galah/inverts\") |&gt; dplyr::collect()\n\nawc_pattern &lt;- \"(awaiting allocation)\"\ninsed_pattern &lt;- \"incertae sedis\"\n\ncleaned_irmng_taxa &lt;- irmng_taxa |&gt;\n  mutate(\n    class = ifelse(str_detect(class, pattern = paste0(awc_pattern, \"|\", insed_pattern)),\n      word(class), class\n    )\n  ) |&gt;\n  filter(taxonomicStatus == \"accepted\") |&gt; # Filter to accepted names\n  filter(\n    kingdom %in% c(\"Animalia\", \"Plantae\"),\n    !kingdom == \"Questionable / non-biota (fossil)\"\n  ) # Filter to Animal and plants - change if working with other kingdoms\n\n# Join with species profile, remove pesky values and filter to extinct taxa\nextinct_irmng &lt;- irmng_taxa |&gt;\n  left_join(irmng_sp, by = \"taxonID\") |&gt;\n  filter(!scientificName == \"Questionable / non-biota (fossil)\") |&gt;\n  filter(isExtinct == TRUE)\n\n# Summary of extinct species by taxonRank\nextinct_irmng$taxonRank |&gt; janitor::tabyl()\n\n extinct_irmng$taxonRank     n      percent\n                   Class    14 5.926177e-04\n                  Family  1675 7.090247e-02\n                   Genus 21718 9.193193e-01\n              Infraclass     1 4.232983e-05\n                   Order   210 8.889265e-03\n                  Phylum     4 1.693193e-04\n                Subclass     2 8.465967e-05\n\n# Create genus\ninverts_2 &lt;- inverts |&gt;\n  mutate(genus = word(scientificName, 1))\n\n# Extract unique extinct genus and remove genus that have punctuation in them\nextinct_genus &lt;- extinct_irmng |&gt;\n  tidyr::drop_na(genus) |&gt;\n  filter(!str_detect(genus, pattern = regex(\"[:punct:]\"))) |&gt;\n  pull(genus) |&gt;\n  unique()\n\n# Check if there are any matches at genus level\ncheck &lt;- inverts_2 |&gt;\n  filter(str_detect(genus, pattern = regex(paste0(extinct_genus, collapse = \"|\")))) |&gt;\n  pull(scientificName) |&gt;\n  unique()\n\nprint(check)\n\n[1] \"Halobates (Halobates) acherontis\"\n\n\n\n\nAlternatively, we can use the IUCN to retrieve a list of extinct species that are in their database. See the IUCN API for more information on queries based on species categories. Below we will the rredlist package to interface with the IUCN API. Note that you will need to register for an API token, which can take a day or two to be approved. Then we use the rl_sp_category(\"EX\") to return extinct species, to check against our dataset.\n\n# Create IUCN token\nrredlist::rl_use_iucn() # Application can take a day or two!\nusethis::edit_r_environ() # Place the approved token in your R environment\n\nextinct_iucn &lt;- rredlist::rl_sp_category(\"EX\")\nskimr::skim(extinct_iucn)\n\n# Note these are extinct species across the globe\nextinct_sp &lt;- tibble(extinct_iucn$result)\n\n# Find matches\nfilter(inverts, scientificName %in% extinct_sp$scientific_name) # No matches",
    "crumbs": [
      "Ecological data cleaning",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Ecological filtering</span>"
    ]
  },
  {
    "objectID": "3_cleaning_expert/ecological-filtering.html#biological-attributes-and-life-cycle-stages",
    "href": "3_cleaning_expert/ecological-filtering.html#biological-attributes-and-life-cycle-stages",
    "title": "10  Ecological filtering",
    "section": "10.3 Biological attributes and life cycle stages",
    "text": "10.3 Biological attributes and life cycle stages\nIn some cases, you may want to filter out records based on attributes such as sex or life cycle stage, if this metadata is available for your records. In the example below, we download a dataset, including the extra metadata fields needed. We then examine the fields we want to filter by, to see what values are available and how many records are missing values.\n\nlibrary(galah)\n\ngalah_config(\n  email = Sys.getenv(\"ALA_EMAIL\"),\n  atlas = \"Australia\"\n)\n\nbilby &lt;- galah_call() |&gt;\n  galah_identify(\"Macrotis lagotis\") |&gt;\n  galah_filter(year == 2022) |&gt;\n  galah_select(group = \"basic\", sex, lifeStage, reproductiveCondition) |&gt;\n  atlas_occurrences()\n\n# Quick way to check the unique values for each field\nlapply(bilby[c(\"sex\", \"lifeStage\", \"reproductiveCondition\")], unique)\n\nThe check above shows that the lifeStage field has only NA values, so we won’t be able to use it. The other two fields have values so it’s worth checking them out in more detail using skimr::skim() For this example we will focus on the sex field.\n\n# Skim without charts for a more compact output, making sure sex is treated as a factor\nbilby$sex &lt;- factor(bilby$sex)\nskimr::skim_without_charts(bilby, sex) |&gt;\n  skimr::yank(\"factor\")\n\nThe dataset is mostly NA values for the sex field, but say that our project is focused only on female greater bilbies, now we can do our simple filter using == as shown below.\n\nhead(filter(bilby, sex == \"FEMALE\"), 3)\n\nWe could also use != \"MALE to get the same result, since we only have two factor levels, and dplyr::filter() drops NA values. Be aware that if filtering with base R subsetting, the same approach would drop male rows but keep both female and NA rows.\n\nnrow(filter(bilby, sex != \"MALE\"))\nnrow(filter(bilby[bilby$sex != \"MALE\", ]))",
    "crumbs": [
      "Ecological data cleaning",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Ecological filtering</span>"
    ]
  },
  {
    "objectID": "3_cleaning_expert/ecological-filtering.html#ecosystems",
    "href": "3_cleaning_expert/ecological-filtering.html#ecosystems",
    "title": "10  Ecological filtering",
    "section": "10.4 Ecosystems",
    "text": "10.4 Ecosystems\nFiltering by ecosystem, such as removing terrestrial records or aquatic records, can be necessary depending on the project. Below we demonstrate an example of filtering against the World Register of Marine Species (WoRMS), to remove marine invertebrates from our dataset. Note that you could apply this approach to any other ecosystem by using an appropriate list of species.\n\n\n\n\n# Obtain species list\nmy_species &lt;- inverts |&gt;\n  pull(scientificName) |&gt;\n  unique()\n\n# Query WoRMs\nmarine_check &lt;- purrr::map_dfr(\n  my_species,\n  purrr::possibly(~ worrms::wm_records_name(name = .x) |&gt;\n    mutate(search_term = .x))\n)\n# Filter species that are TRUE for isMarine\nmarine_inverts &lt;- marine_check |&gt;\n  filter(isMarine == TRUE)\n\n# Exclude marine invertebrates\nfilter(inverts, !scientificName %in% marine_inverts$search_term)\n\n# A tibble: 4 × 8\n  decimalLatitude decimalLongitude eventDate           scientificName           \n            &lt;dbl&gt;            &lt;dbl&gt; &lt;dttm&gt;              &lt;chr&gt;                    \n1           -13.8             131. 1977-12-11 00:00:00 Halobates (Halobates) ac…\n2           -13.8             131. 1977-12-11 00:00:00 Halobates (Halobates) ac…\n3           -13.8             131. 1977-12-11 00:00:00 Halobates (Halobates) ac…\n4           -13.8             131. 1977-12-11 00:00:00 Halobates (Halobates) ac…\n# ℹ 4 more variables: taxonConceptID &lt;chr&gt;, recordID &lt;chr&gt;,\n#   dataResourceName &lt;chr&gt;, occurrenceStatus &lt;chr&gt;\n\n\nAfter filtering we are left with only four records of one species. It’s always worth double checking the results of your filtering to make sure any species excluded or included are as expected.",
    "crumbs": [
      "Ecological data cleaning",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Ecological filtering</span>"
    ]
  },
  {
    "objectID": "3_cleaning_expert/ecological-filtering.html#summary",
    "href": "3_cleaning_expert/ecological-filtering.html#summary",
    "title": "10  Ecological filtering",
    "section": "10.5 Summary",
    "text": "10.5 Summary\n…something",
    "crumbs": [
      "Ecological data cleaning",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Ecological filtering</span>"
    ]
  },
  {
    "objectID": "3_cleaning_expert/geospatial.html",
    "href": "3_cleaning_expert/geospatial.html",
    "title": "11  Geospatial data",
    "section": "",
    "text": "11.0.1 Prerequisites\nIn this chapter we’ll use data of …\nlibrary(galah)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(sf)\nlibrary(ozmaps)\nlibrary(tidyr)\nlibrary(stringr)\n\ngalah_config(atlas = \"Australia\",\n             email = Sys.getenv(\"ALA_EMAIL\"),\n             verbose = FALSE)\n\nbanksia &lt;- galah_call() |&gt;\n  identify(\"banksia serrata\") |&gt;\n  filter(year &gt; 2022) |&gt;\n  select(group = \"basic\",\n         coordinatePrecision, \n         coordinateUncertaintyInMeters) |&gt;\n  atlas_occurrences()\n\nfrogs &lt;- galah_call() |&gt;\n  identify(\"Litoria chloris\") |&gt;\n  filter(year == 2013) |&gt;\n  select(group = \"basic\",\n         countryCode, locality,\n         family, genus, species, \n         cl22, eventDate) |&gt;\n  atlas_occurrences()",
    "crumbs": [
      "Ecological data cleaning",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Geospatial data</span>"
    ]
  },
  {
    "objectID": "3_cleaning_expert/geospatial.html#quick-visualisation",
    "href": "3_cleaning_expert/geospatial.html#quick-visualisation",
    "title": "11  Geospatial data",
    "section": "11.1 Quick visualisation",
    "text": "11.1 Quick visualisation\nMentioned in the Inspect chapter, one of the most straightforward ways to check for spatial errors is to plot your data onto a map. More obvious spatial errors are much easier to spot visually.\n\n# Retrieve map of Australia\naus &lt;- st_transform(ozmap_country, 4326)\n\n# Remove missing coordinates in Banksia data\n# Then transform into 'sf' object\nbanksia_sf &lt;- banksia |&gt; \n  tidyr::drop_na(starts_with(\"decimal\")) |&gt; \n  st_as_sf(coords = c(\"decimalLongitude\", \"decimalLatitude\"), \n           crs = 4326)\n\n# A quick plot\nggplot() + \n  geom_sf(data = aus, colour = \"black\", fill = NA) + \n  geom_sf(data = banksia_sf)",
    "crumbs": [
      "Ecological data cleaning",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Geospatial data</span>"
    ]
  },
  {
    "objectID": "3_cleaning_expert/geospatial.html#missing-coordinates",
    "href": "3_cleaning_expert/geospatial.html#missing-coordinates",
    "title": "11  Geospatial data",
    "section": "11.2 Missing coordinates",
    "text": "11.2 Missing coordinates\n\nMentioned in the Missing Values chapter, many spatial analytical tools are not compatible with missing coordinate data. We recommend identifying the rows that have missing data before deciding to exclude them.\n\n# Identify missing data in coordinates\nbanksia |&gt; \n  filter(is.na(decimalLatitude) | is.na (decimalLongitude))\n\n# A tibble: 1 × 10\n  recordID        scientificName taxonConceptID decimalLatitude decimalLongitude\n  &lt;chr&gt;           &lt;chr&gt;          &lt;chr&gt;                    &lt;dbl&gt;            &lt;dbl&gt;\n1 40ea51f1-ccb9-… Banksia serra… https://id.bi…              NA               NA\n# ℹ 5 more variables: eventDate &lt;dttm&gt;, occurrenceStatus &lt;chr&gt;,\n#   dataResourceName &lt;chr&gt;, coordinatePrecision &lt;dbl&gt;,\n#   coordinateUncertaintyInMeters &lt;dbl&gt;\n\n\nYou can use drop_na() to remove missing values from your dataset.\n\n# Excluding them\nbanksia &lt;- banksia |&gt; \n  tidyr::drop_na(decimalLatitude, decimalLongitude)",
    "crumbs": [
      "Ecological data cleaning",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Geospatial data</span>"
    ]
  },
  {
    "objectID": "3_cleaning_expert/geospatial.html#filter-coordinates",
    "href": "3_cleaning_expert/geospatial.html#filter-coordinates",
    "title": "11  Geospatial data",
    "section": "11.3 Filter coordinates",
    "text": "11.3 Filter coordinates\n\n11.3.1 Precision\nNot all observations have the same degree of precision. Coordinate precision can vary between data sources and recording equipment. For example, coordinates recorded with a GPS unit or a phone generally have higher precision than coordinates recorded manually from a locality description.\nThe degree of precision you require will depend on the granularity of your research question and analysis. A fine-scale question will require data measured at a fine-scale to answer it. National or global scale questions require less precise data.\nWhen downloading data from the ALA with the galah package, it’s possible to include the column coordinatePrecision—a decimal representation of how precise the coordinates of an observation are—to your data.\n\nbanksia |&gt;\n  select(scientificName, \n         coordinatePrecision\n         ) |&gt;\n1  filter(!is.na(coordinatePrecision))\n\n\n1\n\nNot all records have this information recorded, so we also filter to only records with a coordinatePrecision value.\n\n\n\n\n# A tibble: 77 × 2\n   scientificName  coordinatePrecision\n   &lt;chr&gt;                         &lt;dbl&gt;\n 1 Banksia serrata         0.000000001\n 2 Banksia serrata         0.000000001\n 3 Banksia serrata         0.000000001\n 4 Banksia serrata         0.000000001\n 5 Banksia serrata         0.000000001\n 6 Banksia serrata         0.000000001\n 7 Banksia serrata         0.000000001\n 8 Banksia serrata         0.000000001\n 9 Banksia serrata         0.000000001\n10 Banksia serrata         0.000000001\n# ℹ 67 more rows\n\n\nOnly a few records have coordinatePrecision recorded, but that subset of records are very precise.\n\nbanksia |&gt; \n  group_by(coordinatePrecision) |&gt;\n  count()\n\n# A tibble: 2 × 2\n# Groups:   coordinatePrecision [2]\n  coordinatePrecision     n\n                &lt;dbl&gt; &lt;int&gt;\n1         0.000000001    77\n2        NA             620\n\n\nFilter your records to only those under a specific measure of precision.\n\n# Filter by number of decimal places\nbanksia &lt;- banksia |&gt;\n  filter(coordinatePrecision &lt;= 0.001)\n\n\n\n11.3.2 Uncertainty\nSimilarly, not all observations have the same degree of location certainty. An organism’s exact location will likely have an area of uncertainty around it, which can grow or shrink depending on the method of observation and the species observed. For example, if a person uses a precise GPS and high-definition camera to make observations of snails, their observed location will be of higher certainty than a person using a phone camera to make observations of birds in the distance. The exact location might also be obscured for sensitivity purposes. Uncertainty inevitably affects how robust the results from species distribution models are.\nWhen downloading data from the ALA with the galah package, it’s possible to include the column coordinateUncertaintyInMeters—a measure of the circular area that captures the true location—to your data. We added this column in our original galah query.\n\nbanksia |&gt;\n  select(scientificName,\n         coordinateUncertaintyInMeters\n         )\n\n# A tibble: 697 × 2\n   scientificName  coordinateUncertaintyInMeters\n   &lt;chr&gt;                                   &lt;dbl&gt;\n 1 Banksia serrata                           316\n 2 Banksia serrata                          2268\n 3 Banksia serrata                            NA\n 4 Banksia serrata                            NA\n 5 Banksia serrata                            NA\n 6 Banksia serrata                            15\n 7 Banksia serrata                             4\n 8 Banksia serrata                            NA\n 9 Banksia serrata                          2457\n10 Banksia serrata                             4\n# ℹ 687 more rows\n\n\nThere is a range of coordinate uncertainty in our data, but all records are assumed within a 10-metre area of their observation.\n\nbanksia |&gt; \n  group_by(coordinateUncertaintyInMeters) |&gt;\n  count()\n\n# A tibble: 144 × 2\n# Groups:   coordinateUncertaintyInMeters [144]\n   coordinateUncertaintyInMeters     n\n                           &lt;dbl&gt; &lt;int&gt;\n 1                             1     4\n 2                             2     4\n 3                             3    30\n 4                             4   120\n 5                             5    53\n 6                             6    15\n 7                             7    12\n 8                             8    23\n 9                             9    17\n10                            10    56\n# ℹ 134 more rows\n\n\nIf your analysis requires greater certainty, you can then filter your records to a smaller area of uncertainty.\n\n# Filter by number of decimal places\nbanksia &lt;- banksia |&gt;\n  filter(coordinateUncertaintyInMeters &lt;= 5)\n\n\n\n11.3.3 Obscured location\nOccurrence records of sensitive, endangered or critically endangered species my be obscured (i.e. generalised, obfuscated) to protect the true location of the species. This process blurs the of an organism actual location to avoid risks like poaching or capture while still allowing their data to be included in broader summaries.\nIn the ALA, the field dataGeneralizations contains information of whether a record has been has been obscured and the size of the area the point has been generalised to.\n\n\n\n\n\n\nNote\n\n\n\n\n\nThe dataGeneralizations field will only be available to use or download when there are records in your query that have been generalised/obscured.\n\n\n\n\nsearch_all(fields, \"dataGeneralization\")\n\n# A tibble: 2 × 3\n  id                      description                        type  \n  &lt;chr&gt;                   &lt;chr&gt;                              &lt;chr&gt; \n1 dataGeneralizations     Data Generalised during processing fields\n2 raw_dataGeneralizations &lt;NA&gt;                               fields\n\n\nFor example, the Western Swamp Tortoise is a critically endangered species in Western Australia. There are 97 total observations of this species in the ALA.\n\ngalah_call() |&gt;\n  identify(\"Pseudemydura umbrina\") |&gt;\n  atlas_counts()\n\n# A tibble: 1 × 1\n  count\n  &lt;int&gt;\n1    97\n\n\nGrouping record counts by the dataGeneralizations column shows that 96 of the 97 records have been obscured by 10 km.\n\ngalah_call() |&gt;\n  identify(\"Pseudemydura umbrina\") |&gt;\n  group_by(dataGeneralizations) |&gt;\n  atlas_counts()\n\n# A tibble: 1 × 2\n  dataGeneralizations                                                      count\n  &lt;chr&gt;                                                                    &lt;int&gt;\n1 Record is Critically Endangered in Western Australia. Generalised to 10…    96\n\n\nFor more information, check out ALA’s support article about working with threatened, migratory and sensitive species.",
    "crumbs": [
      "Ecological data cleaning",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Geospatial data</span>"
    ]
  },
  {
    "objectID": "3_cleaning_expert/geospatial.html#correct-coordinates",
    "href": "3_cleaning_expert/geospatial.html#correct-coordinates",
    "title": "11  Geospatial data",
    "section": "11.4 Correct coordinates",
    "text": "11.4 Correct coordinates\nSpatial outliers can sometimes be due to [taxonomic misidentification], but not always. Sometimes, records that appear as outliers can be true observations of a species, but the record has a mistake in its coordinates. To avoid deleting data that can be included in your analysis, it’s good practice to use several sources of spatial information to decide whether an unexpected data point is due to a small but fixable error in coordinates, or not.\nMany coordinates issues can be solved with data manipulation instead of discarding. Here are several coordinate issues that can be identified and corrected.\n\nFlipped coordinates\nFlipped coordinates typically appear as a clustering of points, whereby swapping the latitude and longitude will place the coordinates where they are expected. (Jin and Yang 2020)\nDax’s note: I don’t think this is a very good example, but I’m not sure whether there are any examples of this on the ALA. Not sure if this should be included at all then, if that’s the case.\n\n\nnative_mice &lt;- galah_call() |&gt;\n  identify(\"Dasyuroides byrnei\") |&gt;\n  select(scientificName, decimalLongitude, decimalLatitude,\n         eventDate,\n         country, countryCode, locality, \n         COUNTRY_COORDINATE_MISMATCH,\n         group = \"assertions\") |&gt;\n  atlas_occurrences()\n\nRetrying in 1 seconds.\n\nnative_mice |&gt;\n  filter(COUNTRY_COORDINATE_MISMATCH == TRUE) |&gt;\n  select(decimalLongitude, decimalLatitude, eventDate, country, countryCode, locality)\n\n# A tibble: 105 × 6\n   decimalLongitude decimalLatitude eventDate country   countryCode\n              &lt;dbl&gt;           &lt;dbl&gt; &lt;dttm&gt;    &lt;chr&gt;     &lt;chr&gt;      \n 1             43.7           -39.0 NA        Australia AU         \n 2             35.4           -59.0 NA        Australia AU         \n 3             39.4           -43.5 NA        Australia AU         \n 4             39.4           -43.5 NA        Australia AU         \n 5             40             -41.4 NA        Australia AU         \n 6             31.2           -58.1 NA        Australia AU         \n 7             39.2           -48.2 NA        Australia AU         \n 8             46.7           -39.4 NA        Australia AU         \n 9             32.5           -56.6 NA        Australia AU         \n10             32.3           -56.8 NA        Australia AU         \n# ℹ 95 more rows\n# ℹ 1 more variable: locality &lt;chr&gt;\n\nggplot() + \n  geom_sf(data = aus) +\n  geom_point(data = native_mice,\n             aes(x = decimalLongitude,\n                 y = decimalLatitude))\n\nWarning: Removed 163 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\n\n\n\n\nIncorrect numeric sign\nIf there is a clustering of points mirrored to another hemisphere, consider swapping the sign and correct rather than discarding the points.\nIf using the galah package, you can add the PRESUMED_SWAPPED_COORDINATE assertion column to your download to help find occurrence records flagged as suspicious for swapped coordinates.\n\ndesert_plant &lt;- galah_call() |&gt;\n  identify(\"Eremophila macdonnellii\") |&gt;\n  select(group = \"basic\", \n         PRESUMED_SWAPPED_COORDINATE) |&gt; # add assertion column\n  atlas_occurrences() |&gt;\n  drop_na(decimalLongitude, decimalLatitude) # remove NA coordinates\n\nWe can see this single record highlighted in orange on our map, sitting in a very similar location to where Australia would be if we mirrored its location.\n\nggplot() + \n  geom_sf(data = aus) +\n  geom_point(data = desert_plant,\n             aes(x = decimalLongitude, \n                 y = decimalLatitude,\n                 colour = PRESUMED_SWAPPED_COORDINATE)) + \n  pilot::scale_color_pilot()\n\n\n\n\n\n\n\n\nWe can fix the numeric symbols using case_when() from dplyr, which works the same as an ifelse statement (but can handle many of statements at once). The first updates our decimalLongitude column so that when decimalLongitude is less than 0, we remove the negative symbol, otherwise we keep the original longitude value. The second updates our decimalLatitude column so that when decimalLatitude is greater than 0, we’ll “glue” on a negative symbol, otherwise we keep the original latitude value.\n\nlibrary(glue)\n\ndesert_plant_filtered &lt;- desert_plant |&gt;\n  mutate(\n    decimalLongitude = case_when(\n      decimalLongitude &lt; 0 ~ str_remove(decimalLongitude, \"-\") |&gt;\n1        as.numeric(),\n      .default = decimalLongitude\n    ),\n    decimalLatitude = case_when(\n      decimalLatitude &gt; 0 ~ glue(\"-{decimalLatitude}\") |&gt; \n        as.numeric(),\n      .default = decimalLatitude\n    ))\n\n\n1\n\nUsing a string operation on our numeric column converts the value to a character. We have to convert the value back to a numeric value to avoid getting any class mismatch errors.\n\n\n\n\nOur updated map has fixed the coordinates of our record.\n\nggplot() + \n  geom_sf(data = aus) +\n  geom_point(data = desert_plant_filtered,\n             aes(x = decimalLongitude, \n                 y = decimalLatitude,\n                 colour = PRESUMED_SWAPPED_COORDINATE)) + \n  pilot::scale_color_pilot()\n\n\n\n\n\n\n\n\n\n\nLocation description doesn’t match coordinates\n\nLet’s use the red-eyed tree frog data we downloaded at the start of the chapter. When we plot the coordinates of our red-eyed tree frog occurrences, there is an unexpected observation near Japan. This is quite surprising - red-eyed tree frogs are not native to Japan!\n\n# Get a map of aus, transform projection\naus &lt;- ozmaps::ozmap_country |&gt;\n  st_transform(crs = st_crs(4326))\n\n# Map\nggplot() +\n  geom_sf(data = aus,\n          fill = NA,\n          colour = \"grey60\") +\n  geom_point(data = frogs,\n             aes(x = decimalLongitude,\n                 y = decimalLatitude),\n             colour = \"#557755\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\nLet’s check the countryCode column to see whether this might be an Australian record with a mistake in the coordinates.\nUsing distinct(), we can see that there are 2 country codes…\n\nfrogs |&gt;\n  distinct(countryCode)\n\n# A tibble: 2 × 1\n  countryCode\n  &lt;chr&gt;      \n1 AU         \n2 JP         \n\n\n…and filtering to Japan (\"JP\") identifies our stray data point.\n\nfrogs |&gt;\n  filter(countryCode == \"JP\")\n\n# A tibble: 1 × 14\n  recordID        scientificName taxonConceptID decimalLatitude decimalLongitude\n  &lt;chr&gt;           &lt;chr&gt;          &lt;chr&gt;                    &lt;dbl&gt;            &lt;dbl&gt;\n1 c08e641e-cf01-… Litoria chlor… https://biodi…            24.5             152.\n# ℹ 9 more variables: eventDate &lt;dttm&gt;, occurrenceStatus &lt;chr&gt;,\n#   dataResourceName &lt;chr&gt;, countryCode &lt;chr&gt;, locality &lt;chr&gt;, family &lt;chr&gt;,\n#   genus &lt;chr&gt;, species &lt;chr&gt;, cl22 &lt;chr&gt;\n\n\nSo far this observation does seem to be in Japan. To be extra certain, we can also use the column locality, which provides additional information from the data collector about the record’s location.\n\nfrogs |&gt;\n  filter(countryCode == \"JP\") |&gt;\n  select(countryCode, locality, scientificName, decimalLatitude, decimalLongitude)\n\n# A tibble: 1 × 5\n  countryCode locality scientificName  decimalLatitude decimalLongitude\n  &lt;chr&gt;       &lt;chr&gt;    &lt;chr&gt;                     &lt;dbl&gt;            &lt;dbl&gt;\n1 JP          mt bucca Litoria chloris            24.5             152.\n\n\nThe locality column reveals the observation was made in “mt bucca”. This is surprising to see because Mt Bucca is a mountain in Queensland!\nWhen we look at our Japan data point’s decimalLongitude and decimalLatitude alongside other values in our data, it becomes clear that the Japan data point seems to sit within the same numerical range as other points, but is positive rather than negative.\n\nfrogs |&gt;\n  arrange(desc(countryCode)) |&gt;\n  select(countryCode, decimalLongitude, decimalLatitude) |&gt;\n  print(n = 5)\n\n# A tibble: 30 × 3\n  countryCode decimalLongitude decimalLatitude\n  &lt;chr&gt;                  &lt;dbl&gt;           &lt;dbl&gt;\n1 JP                      152.            24.5\n2 AU                      153.           -28.4\n3 AU                      153.           -28.4\n4 AU                      153.           -28.2\n5 AU                      149.           -20.3\n# ℹ 25 more rows\n\n\nAll of this evidence suggests that our Japan “outlier” might instead be an occurrence point with a mis-entered latitude coordinate.\nLet’s fix this by adding a negative symbol (-) to the record’s latitude coordinate number. We’ll use case_when() from dplyr to specify that if the countryCode == \"JP\", then we’ll “glue” a negative in front of decimalLatitude.\n\nlibrary(glue)\n\nfrogs_fixed &lt;- frogs |&gt;\n  mutate(\n    decimalLatitude = case_when(\n      countryCode == \"JP\" ~ glue(\"-{decimalLatitude}\") |&gt;\n1        as.numeric(),\n      .default = decimalLatitude \n    ))\n\nfrogs_fixed |&gt;\n  filter(countryCode == \"JP\") |&gt; \n  select(decimalLatitude, decimalLongitude, countryCode)\n\n\n1\n\nUsing a string operation on our numeric column converts the value to a character. We have to convert the value back to a numeric value to avoid getting any class mismatch errors.\n\n\n\n\n# A tibble: 1 × 3\n  decimalLatitude decimalLongitude countryCode\n            &lt;dbl&gt;            &lt;dbl&gt; &lt;chr&gt;      \n1           -24.5             152. JP         \n\n\nMapping our data again shows our outlier is an outlier no longer!\n\n\nCode\nggplot() +\n  geom_sf(data = aus,\n          fill = NA,\n          colour = \"grey60\") +\n  geom_point(data = frogs_fixed,\n             aes(x = decimalLongitude,\n                 y = decimalLatitude),\n             colour = \"#557755\") +\n  theme_void()",
    "crumbs": [
      "Ecological data cleaning",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Geospatial data</span>"
    ]
  },
  {
    "objectID": "3_cleaning_expert/geospatial.html#remove-records",
    "href": "3_cleaning_expert/geospatial.html#remove-records",
    "title": "11  Geospatial data",
    "section": "11.5 Remove records",
    "text": "11.5 Remove records\nSome coordinates issues cannot be fixed or inferred. In this case, it is important that you identify which records have issues and remove them prior to analysis.\nHere are some examples of geospatial errors that might need to be identified and removed in your dataset.\n\nUsing expert distributions\nComing soon once galah supports expert distributions…\n\nOne way to identify suspicious observations is to use an expert distribution to determine whether an occurrence record is within the possible range of a species. At the most basic, expert distributions can be found in the literature (like this one), then compared visually to your points.\nIt’s also possible to download expert distributions as shapefiles, and these can be plotted on a map to directly compare with your occurrence record locations.\n\n\n\nZero coordinates\nSome records are mistakenly recorded with zero as their latitude and/or longitude coordinates. These records will not accurately represent their valid location and must be removed.\nIf using the galah package, you can add the ZERO_COORDINATE assertion column to your download to find occurrence records flagged as suspicious for zero coordinates.\n\nacacias &lt;- galah_call() |&gt;\n  identify(\"acacia aneura\") |&gt;\n  select(group = \"basic\",\n         ZERO_COORDINATE, # add assertion column\n         countryCode, locality) |&gt;\n  atlas_occurrences()\n\nRetrying in 1 seconds.\n\n\nWe can see the suspicious record in orange on our map.\n\nggplot() + \n  geom_sf(data = aus) +\n  geom_point(data = acacias,\n             aes(x = decimalLongitude, \n                 y = decimalLatitude,\n                 colour = ZERO_COORDINATE)) +\n  pilot::scale_color_pilot()\n\nWarning: Removed 255 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\n\n\nWe can remove the problematic record by filtering our data to remove records with longitude or latitude coordinates that equal zero.\n\nacacias_filtered &lt;- acacias |&gt;\n  filter(decimalLongitude != 0,\n         decimalLatitude != 0)\n\nggplot() + \n  geom_sf(data = aus) +\n  geom_point(data = acacias_filtered,\n             aes(x = decimalLongitude, \n                 y = decimalLatitude,\n                 colour = ZERO_COORDINATE)) +\n  pilot::scale_color_pilot()\n\n\n\n\n\n\n\n\n\n\nCentroids\nCentroids, or coordinates that mark the exact centre point of an area, are sometimes assigned to an occurrence record when the original observation location was provided as a description. If a record was collected using a vague locality description or from incorrect georeferencing, centroids can be used to categorise the record into broadly the correct area1.\nIf using the galah package, we can add the COORDINATES_CENTRE_OF_COUNTRY or COORDINATES_CENTRE_OF_STATEPROVINCE assertions columns to your download to find occurrence records flagged as suspicious for centroid coordinates.\n\n# example Common Brown butterflies\nbutterflies &lt;- galah_call() |&gt;\n  identify(\"Heteronympha merope\") |&gt;\n  filter(year == 2014,\n         decimalLatitude &lt; 0) |&gt;\n  select(group = \"basic\",\n         COORDINATES_CENTRE_OF_COUNTRY, # add assertion column\n         COORDINATES_CENTRE_OF_STATEPROVINCE, # add assertion column\n         countryCode, locality) |&gt;\n  atlas_occurrences()\n\nFiltering our data to records flagged as suspicious, we return one record.\n\nbutterflies |&gt;\n  filter(\n    COORDINATES_CENTRE_OF_COUNTRY == TRUE |\n    COORDINATES_CENTRE_OF_STATEPROVINCE == TRUE\n    )\n\n# A tibble: 1 × 12\n  recordID        scientificName taxonConceptID decimalLatitude decimalLongitude\n  &lt;chr&gt;           &lt;chr&gt;          &lt;chr&gt;                    &lt;dbl&gt;            &lt;dbl&gt;\n1 89186e67-be72-… Heteronympha … https://biodi…           -31.3             147.\n# ℹ 7 more variables: eventDate &lt;dttm&gt;, occurrenceStatus &lt;chr&gt;,\n#   dataResourceName &lt;chr&gt;, countryCode &lt;chr&gt;, locality &lt;chr&gt;,\n#   COORDINATES_CENTRE_OF_COUNTRY &lt;lgl&gt;,\n#   COORDINATES_CENTRE_OF_STATEPROVINCE &lt;lgl&gt;\n\n\nThe suspicious record is the single orange point on our map.\n\nggplot() + \n  geom_sf(data = aus) +\n  geom_point(data = butterflies,\n             aes(x = decimalLongitude, \n                 y = decimalLatitude,\n                 colour = COORDINATES_CENTRE_OF_STATEPROVINCE)) +\n  pilot::scale_color_pilot() +\n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\nWe can remove this data point by excluding this record from our dataframe.\n\nbutterflies_filtered &lt;- butterflies |&gt;\n  filter(COORDINATES_CENTRE_OF_STATEPROVINCE == FALSE)\n\nggplot() + \n  geom_sf(data = aus) +\n  geom_point(data = butterflies_filtered,\n             aes(x = decimalLongitude, \n                 y = decimalLatitude,\n                 colour = COORDINATES_CENTRE_OF_STATEPROVINCE)) +\n  pilot::scale_color_pilot() +\n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n\nCities, zoos, aquariums, museums & herbaria\nSome observations are recorded in locations where animals and plants live but do not naturally occur. A common example is observations recorded at public facilities like zoos, aquariums and botanic gardens.\nOther times, observations are recorded in places where specimens of animals and plants might be stored, but not where they were observed. Common examples are museums and herbaria.\nIn some cases, like with records of the Gorse Bitter-pea, these locations can appear suspicious but not overly obvious. When we map these observations, there is a tailing distribution of points in Western Australia with several points located near the west coast of Australia.\n\nbitter_peas &lt;- galah_call() |&gt;\n  identify(\"Daviesia ulicifolia\") |&gt;\n  atlas_occurrences()\n\nRetrying in 1 seconds.\n\nggplot() + \n  geom_sf(data = aus) +\n  geom_point(data = bitter_peas,\n             aes(x = decimalLongitude,\n                 y = decimalLatitude),\n             colour = pilot::pilot_color(\"navy\"))\n\nWarning: Removed 252 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\n\n\nSuspiciously, if we Google the coordinates of the Western Australia Herbarium, the coordinates happen to overlap with one of the points.\n\nggplot() + \n  geom_sf(data = aus) +\n  geom_point(data = bitter_peas,\n             aes(x = decimalLongitude,\n                 y = decimalLatitude),\n             colour = \"#204466\") +\n  geom_point(aes(x = 115.8,\n                 y = -31.9),\n             colour = \"#f28100\") +\n  theme(legend.position = \"none\")\n\nWarning: Removed 252 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\n\n\nFiltering our data to the two left-most data points reveals that the data resources that supplied those records are both state herbaria.\n\nbitter_peas |&gt;\n  filter(decimalLongitude &lt; 120) |&gt;\n  select(dataResourceName)\n\n# A tibble: 2 × 1\n  dataResourceName                             \n  &lt;chr&gt;                                        \n1 National Herbarium of Victoria (MEL) AVH data\n2 NSW AVH feed                                 \n\n\nHaving identified they could be can remove these records from our data.\n\nbitter_peas_filtered &lt;- bitter_peas |&gt;\n  filter(decimalLongitude &gt; 120)\n\nggplot() + \n  geom_sf(data = aus) +\n  geom_point(data = bitter_peas_filtered,\n             aes(x = decimalLongitude,\n                 y = decimalLatitude),\n             colour = \"#204466\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nYou can use the field basisOfRecord to avoid including records from museums and herbaria when creating your query in galah.\n\nlibrary(galah)\n\n# Show values in `basisOfRecord` field\n# search_all(fields, \"basisOfRecord\") |&gt; \n#   show_values() \n\ngalah_call() |&gt;\n  identify(\"Daviesia ulicifolia\") |&gt;\n  filter(basisOfRecord == \"HUMAN_OBSERVATION\") |&gt;\n  atlas_counts()",
    "crumbs": [
      "Ecological data cleaning",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Geospatial data</span>"
    ]
  },
  {
    "objectID": "3_cleaning_expert/geospatial.html#packages",
    "href": "3_cleaning_expert/geospatial.html#packages",
    "title": "11  Geospatial data",
    "section": "11.6 Packages",
    "text": "11.6 Packages\n\nCoordinateCleaner\nThe CoordinateCleaner package is a package for automated flagging of common spatial and temporal errors of biological and paleaontological data. It is particularly good at cleaning data from GBIF.\nHere is an example of a general cleaning function, but there are many more bespoke options that the package offers.\n\nlibrary(CoordinateCleaner)\n\n# Run record-level tests\ncoordinate_tests &lt;- clean_coordinates(x = butterflies, \n                                      species = \"scientificName\")\n\nReading layer `ne_50m_land' from data source \n  `C:\\Users\\KEL329\\AppData\\Local\\Temp\\RtmpU1YWTA\\ne_50m_land.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 1420 features and 3 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -180 ymin: -89.99893 xmax: 180 ymax: 83.59961\nGeodetic CRS:  WGS 84\n\nsummary(coordinate_tests)\n\n    .val     .equ     .zer     .cap     .cen     .sea     .otl     .gbf \n       0        0        0       22        0       11       60        0 \n   .inst .summary \n      13       95 \n\nplot(coordinate_tests)",
    "crumbs": [
      "Ecological data cleaning",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Geospatial data</span>"
    ]
  },
  {
    "objectID": "3_cleaning_expert/geospatial.html#summary",
    "href": "3_cleaning_expert/geospatial.html#summary",
    "title": "11  Geospatial data",
    "section": "11.7 Summary",
    "text": "11.7 Summary\nEach of the cleaning steps in this chapter do not have to be run in order, or even at all. Whether they are used is context dependent and taxon dependent. As an example, what is one species that has many “wrong” coordinates based on many of the steps listed above?\nThe Great White Shark.\n[Shark photo, map of shark records]\nYet this species has a massive range and is observed in many locations across the globe. Be sure to consider the taxonomic and spatial range of your species before jumping into data cleaning!",
    "crumbs": [
      "Ecological data cleaning",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Geospatial data</span>"
    ]
  },
  {
    "objectID": "3_cleaning_expert/geospatial.html#recycle-bin",
    "href": "3_cleaning_expert/geospatial.html#recycle-bin",
    "title": "11  Geospatial data",
    "section": "11.8 Recycle bin",
    "text": "11.8 Recycle bin\n\n\nEqual longitude/latitude\nSome records might have an accidental duplicated coordinate, resulting in longitude and latitude coordinates that are the same. You can identify and filter these records by checking for equal lat/lon coordinates.\n\n# Need to find some data that has this\nbanksia |&gt;\n  filter(decimalLatitude == decimalLongitude)\n\n# A tibble: 0 × 10\n# ℹ 10 variables: recordID &lt;chr&gt;, scientificName &lt;chr&gt;, taxonConceptID &lt;chr&gt;,\n#   decimalLatitude &lt;dbl&gt;, decimalLongitude &lt;dbl&gt;, eventDate &lt;dttm&gt;,\n#   occurrenceStatus &lt;chr&gt;, dataResourceName &lt;chr&gt;, coordinatePrecision &lt;dbl&gt;,\n#   coordinateUncertaintyInMeters &lt;dbl&gt;\n\n\n\n\n\nCapital cities, urban areas, buildings\nA risk of using data of many types is that sometimes, if observations and specimen data are mixed, some coordinates will specify the location of the specimen, not the observation. These records must be excluded if you are interested in analysing occurrence locations.\n\n# example of many samples in cities (USA & Europe)\n# Placynthiella uliginosa\n\n\n\n\n\nJin, Jing, and Jun Yang. 2020. “BDcleaner: A Workflow for Cleaning Taxonomic and Geographic Errors in Occurrence Data Archived in Biodiversity Databases.” Global Ecology and Conservation 21 (March): e00852. https://doi.org/10.1016/j.gecco.2019.e00852.",
    "crumbs": [
      "Ecological data cleaning",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Geospatial data</span>"
    ]
  },
  {
    "objectID": "3_cleaning_expert/geospatial.html#footnotes",
    "href": "3_cleaning_expert/geospatial.html#footnotes",
    "title": "11  Geospatial data",
    "section": "",
    "text": "This can happen when record locations is incorrectly given as the physical location of the specimen, or because they represent individuals from captivity or grown in horticulture (but were not clearly labelled as such).↩︎",
    "crumbs": [
      "Ecological data cleaning",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Geospatial data</span>"
    ]
  },
  {
    "objectID": "3_cleaning_expert/outliers.html",
    "href": "3_cleaning_expert/outliers.html",
    "title": "12  Outliers",
    "section": "",
    "text": "12.1 Alternative methods\nHere we document some other existing methods that can be used for outlier detection, and their limitations.",
    "crumbs": [
      "Ecological data cleaning",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Outliers</span>"
    ]
  },
  {
    "objectID": "3_cleaning_expert/outliers.html#alternative-methods",
    "href": "3_cleaning_expert/outliers.html#alternative-methods",
    "title": "12  Outliers",
    "section": "",
    "text": "Species Distribution Modelling for outlier detection:\n\nSimões and Peterson (2018)\nMaximum Entropy modelling (MaxEnt) was used to model habitat suitability for five species of leaf beetles in the genus Mesomphalia\nThe method relies on the assumption that an errornous point will have a lower habitat suitability value than a true point.\nFor their dataset, the method was useful for identifying geographical position errors, but not species level identification errors.\n\n\n\n\n\n\n\nSimões, Marianna VP, and A Townsend Peterson. 2018. “Utility and Limitations of Climate-Matching Approaches in Detecting Different Types of Spatial Errors in Biodiversity Data.” Insect Conservation and Diversity 11 (5): 407–14.",
    "crumbs": [
      "Ecological data cleaning",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Outliers</span>"
    ]
  },
  {
    "objectID": "4_accessing/where-to-get-data.html",
    "href": "4_accessing/where-to-get-data.html",
    "title": "13  Where to get data",
    "section": "",
    "text": "13.0.1 Prerequisites\nFirst, we’ll load packages that we’ll need to display data and figures over the chapter.\nlibrary(sf)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tidyterra)\nlibrary(terra)\nlibrary(here)",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Where to get data</span>"
    ]
  },
  {
    "objectID": "4_accessing/where-to-get-data.html#open-source-data",
    "href": "4_accessing/where-to-get-data.html#open-source-data",
    "title": "13  Where to get data",
    "section": "13.1 Open-source data",
    "text": "13.1 Open-source data\nOpen-source data are data made openly accessible for editing and use, licensed under an open license. The following are some places where you can find open-source data.\n\n13.1.1 Biodiversity data\n\nLiving AtlasesGBIFBiocollectionsData providers\n\n\nLiving Atlases are national or regional infrastructures that aggregate biodiversity data from many different sources. These sources include research projects, government monitoring programs, museums & herbaria, and citizen science apps like iNaturalist and eBird. Some examples are:\n\n\n\nCountry/Region\nName\nAcronym\n\n\n\n\nAustralia\nAtlas of Living Australia\nALA\n\n\nAustria\nBiodiversitäts-Atlas Österreich\nBAO\n\n\nBrazil\nSistema de Informação sobre a Biodiversidade Brasileira\nSiBBr\n\n\nEstonia\neElurikkus\n\n\n\nFrance\nPortail français d’accès aux données d’observation sur les espèces\nOpenObs\n\n\nGuatemala\nSistema Nacional de Información sobre Diversidad Biológica de Guatemala\nSNIBgt\n\n\nPortugal\nGBIF Portugal\nGBIF.pt\n\n\nSpain\nGBIF Spain\nGBIF.es\n\n\nSweden\nSwedish Biodiversity Data Infrastructure\nSBDI\n\n\nUnited Kingdom\nNational Biodiversity Network\nNBN\n\n\n\nLiving Atlases work with local data providers to ingest and standardise open-source data, and some even use a specific taxonomic backbone. If your project is focused on a specific region, downloading data directly from a regional node may be more appropriate.\nSee a complete list of existing national and regional Living Atlases.\n\n\nThe Global Biodiversity Information Facility (GBIF) is an international data infrastructure and a network that aggregates biodiversity data from the many Living Atlases around the world. GBIF acts as an overarching organisation to store and provide these data from the Living Atlas “nodes” using a unified data standard.\nAt present, GBIF manages and serves over 2.6 billion occurrence data points!\nSee a complete list of national and regional nodes that contribute to GBIF.\n\n\nBiocollections are data infrastructures that hold specimen data from museums and collections.\nSome examples include:\n\n\n\nName\nDescription\n\n\n\n\nIntegrated Digitzed Biocollections\nHolds data of biological specimens that have been made electronically available (i.e., digitised)\n\n\nVertNet\nHolds data of vertebrate specimens from more than 400 collections & 120 publishers\n\n\nAustralasian Virtual Herbarium (AVH)\nHolds over eight million plant, algae and fungi specimens\n\n\n\n\n\nIf your project relates to data from a specific data provider, it also might be best to download data directly from the source.\nFor example, a common citizen science tool to collect species observations is iNaturalist. Downloading directly from the original data source can help to ensure you don’t have any stray data from other sources in your download. You can directly contact data providers to ensure the data hasn’t been pre-filtered before downloading.\n\n\n\n\n\n13.1.2 Spatial data\nSpatial data contain information that corresponds to an area on the globe and can be plotted onto a map. Spatial data can be represented as vector or raster data.\nThere are two types of spatial data that you will probably use:\n\nVectorsRasters\n\n\nVectors are data for drawing points, lines and shapes. They contain a geometry column which contains information to draw points, lines or polygons onto a map.\nCountry or region outlines are often saved as vectors, which are typically loaded using an R package like {rnaturalearth} or by reading in a .shp file using the {sf} package.\n\nstate_outline &lt;- sf::st_read(\"path/to/file.shp\")\n\nHere is an example of what vector data looks like in R…\n\nozmaps::ozmap_states\n\nSimple feature collection with 9 features and 1 field\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 105.5507 ymin: -43.63203 xmax: 167.9969 ymax: -9.229287\nGeodetic CRS:  GDA94\n# A tibble: 9 × 2\n  NAME                                                                  geometry\n* &lt;chr&gt;                                                       &lt;MULTIPOLYGON [°]&gt;\n1 New South Wales              (((150.7016 -35.12286, 150.6611 -35.11782, 150.6…\n2 Victoria                     (((146.6196 -38.70196, 146.6721 -38.70259, 146.6…\n3 Queensland                   (((148.8473 -20.3457, 148.8722 -20.37575, 148.85…\n4 South Australia              (((137.3481 -34.48242, 137.3749 -34.46885, 137.3…\n5 Western Australia            (((126.3868 -14.01168, 126.3625 -13.98264, 126.3…\n6 Tasmania                     (((147.8397 -40.29844, 147.8902 -40.30258, 147.8…\n7 Northern Territory           (((136.3669 -13.84237, 136.3339 -13.83922, 136.3…\n8 Australian Capital Territory (((149.2317 -35.222, 149.2346 -35.24047, 149.271…\n9 Other Territories            (((167.9333 -29.05421, 167.9188 -29.0344, 167.93…\n\n\n…and what it looks like when plotted with ggplot2.\n\nggplot() + \n  geom_sf(data = ozmaps::ozmap_states) + \n  theme_void()\n\n\n\n\n\n\n\n\n\n\nRasters are data for drawing a layer of data values over a gridded area. They contain values of a variable (like temperature) for each pixel of a grid, and Each pixel of the grid represents a square area (e.g., 1 km2). Just like how the smaller each pixel is on a TV screen the higher its definition, the smaller each square is in a raster layer the higher its resolution.\nClimate data is often saved as a raster, which is typically loaded using an R package like {geodata} or by reading in a .tif file using the {terra} package.\n\n\nworld_clim_raster &lt;- rast(here(\"data/rasters/aggregated_bioclim.tif\"))\n\nHere is an example of what raster data looks like in R…\n\nworld_clim_raster\n\nclass       : SpatRaster \ndimensions  : 86, 87, 19  (nrow, ncol, nlyr)\nresolution  : 0.5416667, 0.5416667  (x, y)\nextent      : 112.5, 159.625, -55.58333, -9  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource      : aggregated_bioclim.tif \nnames       : wc2.1~bio_1, wc2.1~bio_2, wc2.1~bio_3, wc2.1~bio_4, wc2.1~bio_5, wc2.1~bio_6, ... \nmin values  :    7.499508,    7.540306,    41.79295,    85.12752,    18.11505,   -2.798391, ... \nmax values  :   28.209095,   16.710342,    80.15718,   676.51477,    41.65941,   18.436970, ... \n\n\n…and what it looks like when plotted with tidyterra and ggplot2. This map displays Australia’s annual mean temperature (BioClim 1) in low-resolution.\n\nggplot() +\n  geom_spatraster(data = world_clim_raster,\n                  mapping = aes(fill = wc2.1_30s_bio_1)) +\n  theme_void()\n\n\n\n\n\n\n\n\n\n\n\nHere are some examples of where to download spatial data.\n\nClimate dataShapefiles\n\n\nWorldClim is a database of global gridded climate and weather data for historic, current and future conditions.\nEcologists and biologists tend to work specifically with Bioclimatic variables (BioClim). which are typically more meaningful variables for understanding biological things, derived from fluctuations in temperature and rainfall.\nExamples of BioClim variables include Temperature Annual Range, Annual Precitipation, or Precipitation in the Wettest or Driest month. See the complete list of BioClim variables.\nRasters are read into R as a .tif file.\n\n\nShapefiles are vector data with information to draw the outline of one or more specific areas or regions.\nOne of the best ways to search for shapefiles is Google. Some of the safest places to find up-to-date shapefiles are on national or regional government websites. For example, the Australian Bureau of Statistics (ABS) holds shapefiles with many levels of regional boundaries, ranging from states/territories to local government areas.\nShapefiles are read into R as a .shp file. These .shp files are usually within a folder (often a zipped folder) that contains several other files that help to build the .shp file when it is loaded. Here is an example of the contents of an unzipped folder containing a shapefile:\n\n\n\nA folder containing the shapefile for local government areas\n\n\nThey are then read into R using a function like st_read() from the sf package.\n\nlibrary(sf)\nlibrary(rmapshaper)\n\nshapefile &lt;- st_read(here(\"path\",\n                          \"to\",\n                          \"shapefile.shp\"),\n                     quiet = TRUE) |&gt;\n1  ms_simplify(keep = 0.1)\n\n\n1\n\nMany shapefiles are a large file size. ms_simplify() from the rmapshaper package simplifies the shapefile by reducing the number of points that make up the polygon while maintaining its overall shape. This is a handy way to reduce the size of your shapefile in R.\n\n\n\n\n\n\n\n\n\n13.1.3 Taxonomic data\nTaxonomy is a complex and broad field of investigation. A comprehensive look into taxonomy is well outside the scope of this book. However, It’s a good idea to consider the taxonomic classification of the organism(s) you’re interested in and any potential naming differences between data sources.\nWe do advise that before deciding on a final taxonomy to download or use, it’s worth being aware of what naming authority your data is using as its taxonomic backbone. In some taxonomic groups, names can vary widely depending on what taxonomic authority is used. Double check your data after your download them to make sure the classifications you expect are what you finding. This check will help prevent errors later on (though you might still need to re-code data manually).\nWe discuss these considerations in more detail in [Chapter xxx taxonomy expert cleaning].\nHere are some examples of where to find Australian taxonomic information.\n\n\n\nName\nDescription\n\n\n\n\nThe Australian Faunal Directory (AFD)\nAn online catologue of nomenclature and taxonomy of animal species known to occur in Australia\n\n\nThe Australian Plant Name Index (APNI)\nA tool for the botanical community containing accepted scientific names of plants\n\n\nThe Australian Plant Census\nContains the currently accepted scientific names for Australian vascular flora.\n\n\n\n\n\n13.1.4 Trait data\nTrait data contains measurements of organisms’ morphological or behavioural traits (e.g., stem length, leaf size, egg size, migratory distance, soil carbon). These data are useful for comparing spatial or temporal differences between individuals, groups or species.\nThe following are some examples of where to find trait data.\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nAustraits\nA plant trait database that synthesises data from field surveys, published literature, taxonomic monographs, and individual taxon descriptions. The database holds nearly 500 traits across more than 30,000 taxa.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Where to get data</span>"
    ]
  },
  {
    "objectID": "4_accessing/where-to-get-data.html#packages-for-downloading-data",
    "href": "4_accessing/where-to-get-data.html#packages-for-downloading-data",
    "title": "13  Where to get data",
    "section": "13.2 Packages for downloading data",
    "text": "13.2 Packages for downloading data\nThere are a range of R packages available for accessing biodiversity data. These packages serve as convenient interfaces to various data providers by making respective APIs usable directly within R. The functionality offered by these packages typically ranges from querying species occurrence records, to more comprehensive taxonomic and spatial download queries.\nBelow, we highlight some commonly used packages. We encourage users to explore the documentation of each package to understand their capabilities, which will help you select one (or more!) that align with your specific needs.\n\n13.2.1 Occurrence data\n\ngalah\ngalah is an interface for accessing biodiversity data like occurrences, counts, species and media (e.g., images & sounds) from the Living Atlases and GBIF.\nIn the majority of examples over this book we will be using the galah package. One benefit of using galah is that it uses tidy syntax (much like dplyr) to edit & filter download queries. Additionally, galah can access data from 10 other Living Atlases and GBIF.\n\nlibrary(galah)\n\ngalah_config(email = \"your-email-here\") # Registered ALA email\n\ngalah_call() |&gt;\n  identify(\"perameles\") |&gt;\n  filter(year == 2001) |&gt;\n  atlas_occurrences()\n\n\n\n# A tibble: 344 × 8\n   recordID       scientificName taxonConceptID decimalLatitude decimalLongitude\n   &lt;chr&gt;          &lt;chr&gt;          &lt;chr&gt;                    &lt;dbl&gt;            &lt;dbl&gt;\n 1 0053a1f3-b5e1… Perameles nas… https://biodi…           -34.4             151.\n 2 0135db9a-80ff… Perameles nas… https://biodi…           -33.3             151.\n 3 013b9cb6-7d89… Perameles nas… https://biodi…           -28.2             153.\n 4 01c5d084-f4a5… Perameles nas… https://biodi…           -29.2             153.\n 5 02943584-050a… Perameles nas… https://biodi…           -33.3             151.\n 6 02af5fdd-4800… Perameles nas… https://biodi…           -29.3             152.\n 7 02c5d0db-913f… Perameles nas… https://biodi…           -31.2             153.\n 8 04ad578b-af11… Perameles nas… https://biodi…           -26.7             152.\n 9 0518bfb9-cf9d… Perameles nas… https://biodi…           -34.3             151.\n10 05496ff9-d61e… Perameles nas… https://biodi…           -33.3             151.\n# ℹ 334 more rows\n# ℹ 3 more variables: eventDate &lt;dttm&gt;, occurrenceStatus &lt;chr&gt;,\n#   dataResourceName &lt;chr&gt;\n\n\n\n\nOther packages\n\nrgbifrinatrebirdspocc\n\n\nrgbif searches and retrieves data from the Global Biodiversity Information Facility (GBIF).\n\nlibrary(rgbif)\n\n# Download occurrences\nocc_search(scientificName = \"Calopteryx splendens\",\n           country = \"DK\",\n           year=\"1999,2005\")\n\n\n\nrinat is an R wrapper for accessing iNaturalist observations.\n\nlibrary(rinat)\n\n# Download occurrences\nget_inat_obs(taxon_name = \"Colibri\",\n             quality = \"research\",\n             maxresults = 500)\n\n\n\nrebird provides access to the eBird web services.\n\nlibrary(rebird)\n\n# Download occurrences\nebirdgeo(species = species_code('spinus tristis'), \n         lat = 42, \n         lng = -76)\n\n\n\nspocc queries and collects species occurrence data from a variety of sources, including GBIF, VertNet and iDigBio.\n\nlibrary(spocc)\n\n# Download occurrences\ndf &lt;- occ(query = 'Accipiter striatus', \n          from = c('gbif', 'idigbio'), \n          limit = 25)\nocc2df(df)\n\n\n\n\n\n\n\n13.2.2 Spatial data\n\ngeodataozmapsrnaturalearthelevatr\n\n\ngeodata contains data of climate, elevation, soil, crop, species occurrence and administrative boundaries.\n\n# Download world climate data\nworldclim &lt;- worldclim_country(\n    country = \"Australia\",\n    var = \"bio\",\n    res = 5,\n    path = here::here(\"path\", \"to\", \"folder\")\n  )\n\n\n\nozmaps contains simple features (sf) data for plotting maps of Australia and its regions.\n\nlibrary(ozmaps)\n\naus &lt;- ozmap_data(data = \"states\")\n\nggplot() +\n  geom_sf(data = aus) + \n  theme_void()\n\n\n\nrnaturalearth contains simple features (sf) data for plotting world maps, countries, sovereign states and map units.\n\nlibrary(rnaturalearth)\n\n# Download outline of Brazil\nbrazil &lt;- ne_countries(scale = \"medium\", \n                       continent = 'south america', \n                       returnclass = \"sf\") |&gt;\n  filter(name == \"Brazil\")\n\nggplot() +\n  geom_sf(data = brazil) +\n  theme_void()\n\n\n\nelevatr downloads elevation data from various sources like AWS Open Data Terrain Tiles.\n\nlibrary(elevatr)\nlibrary(rnaturalearth)\n\n# Download outline of Cambodia\ncambodia &lt;- ne_countries(scale = \"medium\", \n                         continent = 'asia', \n                         returnclass = \"sf\") |&gt;\n  filter(name == \"Cambodia\")\n\n# Download elevation data for Cambodia\ncambodia_elev &lt;- get_elev_raster(locations = cambodia, \n                                 z = 11, \n                                 clip = \"locations\", \n                                 neg_to_na = \"TRUE\")\n\n\n\n\n\n\n13.2.3 Trait data\n\naustraits\n\n\naustraits allows users to access, explore and wrangle plant trait data from the AusTraits database, which synthesises 500 traits across more than 30,000 taxa.\n\nlibrary(austraits)\n\n# load database\naustraits &lt;- load_austraits(version = \"4.0.1\", \n                            path = \"path/to/folder\")\n\n# extract data by trait\nwood_density &lt;- austraits |&gt; \n  extract_trait(\"wood_density\")",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Where to get data</span>"
    ]
  },
  {
    "objectID": "4_accessing/where-to-get-data.html#summary",
    "href": "4_accessing/where-to-get-data.html#summary",
    "title": "13  Where to get data",
    "section": "13.3 Summary",
    "text": "13.3 Summary\nOver this chapter, we hope you have found some ideas of where to access biodiversity data. The following chapter will help explain how to work with large datasets in R.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Where to get data</span>"
    ]
  },
  {
    "objectID": "4_accessing/large-downloads.html",
    "href": "4_accessing/large-downloads.html",
    "title": "14  Large downloads",
    "section": "",
    "text": "14.0.1 Prerequisites\nIn this chapter, we will use pardalote occurrence data since 2020 from the ALA.\n# packages\nlibrary(galah)\nlibrary(dplyr)\nlibrary(readr)\n\n# data: Pardalote records since 2020\ngalah_config(email = \"your-email-here\") # ALA Registered email\ndir.create(\"tmp\")\n\ngalah_call() |&gt;\n  identify(\"Pardalotus\") |&gt;\n  filter(year &gt;= 2000) |&gt;\n  select(genus, \n         species, \n         scientificName, \n         cl22,\n         year,\n         month, \n         decimalLatitude,\n         decimalLongitude) |&gt; \n  atlas_occurrences() |&gt; \n  write_csv(\"tmp/pardalotes.csv\")\n\n### WE PROBABLY NEED TO GET THEM TO SAVE IT SOMEWHERE? NOT SURE IF THIS IS BAD PRACTICE ###\nThe {arrow} package allows users to easily read and write different file formats, and analyse larger than memory datasets using {dplyr} verbs. A common workflow consists of opening a dataset, filtering or summarising according to some property of the data, and writing this to a new file. This is relatively simple to do with a small csv file, and we can do something conceptually similar using {arrow} for larger datasets1.\nLet’s start by accessing the data as a dataset instead of reading it into memory.\n::: {.panel-tabset .nav-pills}\n#### {arrow}\nlibrary(arrow)\npardalotes &lt;- open_dataset(\"tmp/pardalotes.csv\", format = \"csv\")",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Large downloads</span>"
    ]
  },
  {
    "objectID": "4_accessing/large-downloads.html#recycle-bin",
    "href": "4_accessing/large-downloads.html#recycle-bin",
    "title": "14  Large downloads",
    "section": "14.1 Recycle bin",
    "text": "14.1 Recycle bin",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Large downloads</span>"
    ]
  },
  {
    "objectID": "4_accessing/large-downloads.html#footnotes",
    "href": "4_accessing/large-downloads.html#footnotes",
    "title": "14  Large downloads",
    "section": "",
    "text": "The dataset used in this example is relatively small (approx. 200,000 rows), but the benefits of using {arrow} become obvious once the number of rows in your dataset approaches tens or hundreds of millions.↩︎\nIn contrast, csv files store data in rows, which is much less efficient for storage and takes up more space on disk.↩︎",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Large downloads</span>"
    ]
  },
  {
    "objectID": "4_accessing/merging.html",
    "href": "4_accessing/merging.html",
    "title": "15  Merging multiple datasets",
    "section": "",
    "text": "This is a common task when working with data. This chapter could provide some context about joins and using %in% and (maybe) some pointers of how to check that your joined dataset didn’t lose something you were expecting. Checking merged datasets could also be its own section, depending on what happens.\nThis could be a useful resource: https://github.com/gadenbuie/tidyexplain",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Merging multiple datasets</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "16  References",
    "section": "",
    "text": "Garraffoni, André RS, Thiago Q Araújo, Anete P Lourenço, Loretta Guidi,\nand Maria Balsamo. 2019. “Integrative Taxonomy of a New Redudasys\nSpecies (Gastrotricha: Macrodasyida) Sheds Light on the Invasion of\nFresh Water Habitats by Macrodasyids.” Scientific\nReports 9 (1): 2067.\n\n\nGodfree, Robert C., Nunzio Knerr, Francisco Encinas-Viso, David\nAlbrecht, David Bush, D. Christine Cargill, Mark Clements, et al. 2021.\n“Implications of the 2019–2020 Megafires for the Biogeography and\nConservation of Australian Vegetation.” Nature\nCommunications 12 (1): 1023. https://doi.org/10.1038/s41467-021-21266-5.\n\n\nJin, Jing, and Jun Yang. 2020. “BDcleaner: A Workflow for Cleaning\nTaxonomic and Geographic Errors in Occurrence Data Archived in\nBiodiversity Databases.” Global Ecology and Conservation\n21 (March): e00852. https://doi.org/10.1016/j.gecco.2019.e00852.\n\n\nMarsh, Jess, Payal Bal, Hannah Fraser, Kate Umbers, Aaron Greenville,\nLibby Rumpff, and John Woinarski. 2021. “Assessment of the Impacts\nof the 2019-20 Wildfires of Southern and Eastern Australia on\nInvertebrate Species Final Report.”\n\n\nRowley, Jodi JL, and Corey T Callaghan. 2020. “The FrogID Dataset:\nExpert-Validated Occurrence Records of Australia’s Frogs Collected by\nCitizen Scientists.” ZooKeys 912: 139.\n\n\nSimões, Marianna VP, and A Townsend Peterson. 2018. “Utility and\nLimitations of Climate-Matching Approaches in Detecting Different Types\nof Spatial Errors in Biodiversity Data.” Insect Conservation\nand Diversity 11 (5): 407–14.",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>References</span>"
    ]
  },
  {
    "objectID": "packages.html",
    "href": "packages.html",
    "title": "17  Packages",
    "section": "",
    "text": "17.1 Download data:",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "packages.html#download-data",
    "href": "packages.html#download-data",
    "title": "17  Packages",
    "section": "",
    "text": "17.1.1 galah\n{galah} is an R and Python interface to biodiversity data hosted by the Atlas of Living Australia (ALA). It enables users to locate and download species occurrence records (observations, specimens, eDNA records, etc.), taxonomic information, or associated media such as images or sounds, and to restrict their queries to particular taxa or locations. \n\n\n\n\n  \n\n\n17.1.2 rgbif\n{rgbif} is the Global Biodiversity Information Facility (GBIF)’s R package for downloading global biodiversity occurrence data and is the main node for all living atlases. Users can locate, restrict, and download occurrence records of interest across the globe as well associated multimedia. {rgbif} is one of four clients available to retrieve data. It is also available in Python, Ruby and PHP languages.\n\n\n\n\n   :::\n\n\n17.1.3 spocc\nspocc {spocc} is an umbrella package that can retrieve data from multiple open-access biodiversity data repositories: GBIF, iNaturalist, VertNet, eBird, iDigBio, OBIS and the Atlas of Living Australia.",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "packages.html#visualise-your-data",
    "href": "packages.html#visualise-your-data",
    "title": "17  Packages",
    "section": "17.2 Visualise your data",
    "text": "17.2 Visualise your data\n\n\n \n\n\n17.2.1 skimr\nA helpful tool to quickly summarise your data, particularly prior to data cleaning or whilst in the process of choosing an analysis. You can also use the skim function to calculate the number of columns or rows, view the number of empty or N/A data cells, and describe constituent data types. The summary function provides summary statistics of numerical data such as means, medians, minimum and maximums, as well as quartiles. skim allows the user to have a basic grasp of the spread of numercial data through averages, standard deviations and mini histograms.\n\n\n\n\n \n\n\n17.2.2 tidyverse\n{tidyverse} is an umbrella package installing many packages into R that are useful for data wrangling, cleaning and analysis. Some notable packages within the tidyverse are {dplyr}, {ggplot2} and {stringr}. For example, you can use {dplyr} to add new columns to your data, filter your data for certain values and arrange rows in a preferred order; {ggplot2} can plot and visualise your data, and {stringr} can (though not limited to) help you locate and fix typos and extra spaces in your data.",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "packages.html#general-cleaning",
    "href": "packages.html#general-cleaning",
    "title": "17  Packages",
    "section": "17.3 General cleaning",
    "text": "17.3 General cleaning\n\n\n \n\n\n17.3.1 janitor\n{janitor} is an effective R package to use for pre-cleaning data, especially when working with large data sets. It can help prepare data column names into a consistent format in order for combining data sets or simply the ease of processing of data later on (clean_names). For example, you might want to keep all column names lower case using underscores instead. You can quickly find any duplicate records (get_dupes()) using and produce counts of various combinations of data.\n\n\n\n17.3.2 Taxonomic cleaning\n\n\n \n\n\n17.3.3 dwctaxon\n{dwctaxon} is a package built for editing and validating Darwin Core (a biodiversity data structure that uses standardised row and column names) taxonomy data. As some species have lots of different accepted names or synonyms, this mismatch can impact the ability to merge varying datasets as the same species may be recognized as lots of different ones. It is useful for use as part of the cleaning and formatting process.",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "appendix.html",
    "href": "appendix.html",
    "title": "18  Appendix",
    "section": "",
    "text": "18.1 Why do we still have to clean data held in data infrastructures?\nData infrastructures aggregate data from thousands of different data providers, and standardise them so that data from many disparate sources can be used together.\nData providers, however, can provide data with mistakes, and data infrastructures are not the ultimate taxonomic or ecological experts. Ultimately, it’s a team effort to catch errors, and it’s up to data providers to double check that any flagged errors are indeed actually errors.",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Appendix</span>"
    ]
  },
  {
    "objectID": "appendix.html#data-scope",
    "href": "appendix.html#data-scope",
    "title": "18  Appendix",
    "section": "18.2 Data scope",
    "text": "18.2 Data scope\nData scope refers to the type and extent of data needed for your project. Defining your scope is an essential part of forming a research question, ultimately impacting what data you will use in your project. Availability of data may therefore influence your scope and research question.\nFor example, you might have a question about several species in the same area. However, data for one or more of those species could be limited because observations are rare, surveying the area where it lives is difficult, or only several historical records exist.\nWithout narrowing your data scope, you might find yourself downloading more data than you need, which can needlessly increase how much time is spent processing data prior to analyses. Alternatively, you might find there isn’t enough data to answer your question.\nWhile there are workable methods to analyse small sets of biodiversity data (e.g. hulls), it’s worth thinking critically about whether the amount of data available will allow you to sufficiently answer your research question.\nTo start, some initial questions you might ask are:\n\nWhat is the temporal unit relevant for your research question?\nAm I only interested in more recent data? Is there data that are too old to be relevant for my question?\nWhat is the taxonomic unit of your proposed research question?\nIs my question specific to one or more species in the same taxonomic group? Does it compare between higher taxonomic levels like genus, family or order?\nWhat is the spatial scale of your proposed research question?\nIs my question relevant at a global or national level, or is it specific to a region or ecosystem?\n\nQuestions like these will help you define what data is most relevant for your research question, and help you begin to think about how much evidence available, and the trade-offs you might make between the specificity of your question and the certainty of your answer.",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Appendix</span>"
    ]
  },
  {
    "objectID": "appendix.html#galah",
    "href": "appendix.html#galah",
    "title": "18  Appendix",
    "section": "18.3 galah",
    "text": "18.3 galah\n\n18.3.1 Searching for fields",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Appendix</span>"
    ]
  },
  {
    "objectID": "appendix.html#subset-of-data-from-inverts-australia",
    "href": "appendix.html#subset-of-data-from-inverts-australia",
    "title": "18  Appendix",
    "section": "18.4 Subset of data from Inverts Australia",
    "text": "18.4 Subset of data from Inverts Australia\n\n# Inverts subset: arachnid data\nspiders &lt;- here::here(\"data\",\"dap\",\"inverts_subset\") |&gt;\n  open_dataset() |&gt;\n  filter(class == \"arachnida\") |&gt;\n  collect()\n\n\n\n\n\nGodfree, Robert C., Nunzio Knerr, Francisco Encinas-Viso, David Albrecht, David Bush, D. Christine Cargill, Mark Clements, et al. 2021. “Implications of the 2019–2020 Megafires for the Biogeography and Conservation of Australian Vegetation.” Nature Communications 12 (1): 1023. https://doi.org/10.1038/s41467-021-21266-5.\n\n\nMarsh, Jess, Payal Bal, Hannah Fraser, Kate Umbers, Aaron Greenville, Libby Rumpff, and John Woinarski. 2021. “Assessment of the Impacts of the 2019-20 Wildfires of Southern and Eastern Australia on Invertebrate Species Final Report.”",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Appendix</span>"
    ]
  }
]
---
editor_options: 
  chunk_output_type: console
---

# Column classes & names

Each column in a data set contains data of a specific **class**. A class defines what type of data is in a column and, for R, how that data should be interpreted and used. It doesn't make much sense to try to run a mathematical equation on a word or a sentence. The phrase "hello" doesn't reveal whether something is true or false. Knowing what *types* of data are in each column of your dataset will help ensure your data is handled as expected later on.

A dataset's **column names** might need some cleaning, too. Some columns might have names that aren't clear about what data they contain (e.g., `col1`, `tga42.D`). Other columns might be formatted strangely when loaded from a csv or a spreadsheet, (e.g., `How.Much.Soil.Is.In.This.Plot..`). Column names might also be inconsistent or formatted strangely (e.g., `species_name`, `scientificName`). 

In this chapter we will show how to check the class of each column in your data set. We will then show ways to rename and edit column names to make them clearer or easier to work with.

### Prerequisites

In this chapter, we will use *Litoria* frog occurrence data since 2020 in Tasmania.

```{r}
#| warning: false
#| message: false
#| echo: false
# packages
library(galah)
library(dplyr)

galah_config(email = Sys.getenv("ALA_EMAIL"),
             verbose = FALSE)
frogs <- galah_call() |>
  identify("Litoria") |>
  filter(year >= 2020, 
         cl22 == "Tasmania") |>
  select(group = "basic",
         genus, species) |>
  atlas_occurrences()
```

```{r}
#| eval: false
# packages
library(galah)
library(dplyr)

# data: frog records
galah_config(email = "your-email-here")

frogs <- galah_call() |>
  identify("Litoria") |>
  filter(year >= 2020, 
         cl22 == "Tasmania") |>
  select(group = "basic",
         genus, species) |>
  atlas_occurrences()

# WORMS dataset
marine_species <- readr::read_csv(here::here("data", "worms", "worms.csv"))
```

::: aside
<img src="https://ala-images.s3.ap-southeast-2.amazonaws.com/store/2/a/8/f/c3c17ed0-952c-46c5-8de2-0069ff38f8a2/original" class="rounded"/></img>

::: figure-caption
[*Litoria watjulumensis* seated on a rock.<br>Photo by simono CC-BY-NC 4.0 (Int)](https://biocache.ala.org.au/occurrences/44ed2cdd-ab7c-4974-b2fd-6a6394d5cd7b)
:::
:::

## Column classes

Columns define what type of data they contain by specifying a class. Classes are important because R handles each differently depending what they are.

Viewing your data using functions we used in the [Inspect chapter]() allows you to get a quick glimpse of each column's class.

:::{.panel-tabset .nav-pills}

#### `glimpse()`

Using `glimpse()` displays the column class beside the column names (e.g., *<chr>*)

```{r}
library(dplyr)

glimpse(frogs)
```

#### `str()`

Using `str()` displays the column class after the column name and before the number of rows (e.g., `chr`)

```{r}
str(frogs)
```

#### `skim()`

The `skim()` function groups columns by their type/class.

```{r}
#| message: false
#| warning: false
library(skimr)

skim(frogs)
```

#### `sapply()`

You can return the class of every column using `sapply()` from base R.

```{r}
sapply(frogs, class)
```

#### `map()`

You can return the class of every column using `map()` from the purrr package.

```{r}
#| message: false
#| warning: false
library(purrr)

frogs |>
  purrr::map(class)
```

:::

If you are using a `tibble()`, the class is also displayed below each column name when you view your dataframe.

```{r}
frogs
```

Let's breakdown what we can learn about our class types:

  *  Columns like `scientificName` are are text strings of type `character` 
  *  Columns like `decimalLatitude` and `decimalLongitude` are decimal numbers of type `numeric`
  *  The `eventDate` column contains a date + time and is of type `POSIXct`/`dttm`
  *  Columns like `recordID` and `taxonConceptID` contain both characters and numbers, but are of type `character` because this type prevents any loss of data[^column-names-and-classes-2].

[^column-names-and-classes-2]: To avoid conflicts, R has an internal coercion hierarchy rule to avoid data loss. The rule of thumb is that if a data type can't exist in a child data type, then the parent data type is used instead. The R coercion hierarchy is:<br>  `logical` `->` `integer` `->` `numeric` `->` `complex` -> `character`<br><br>You don't need to memorise this, but it's worth being aware of this hierarchy, as R might make decisions to prevent a class error and you might not know why! [Learn more in this article](https://annakrystalli.me/rrresearchACCE20/data-types-structures-and-classes.html).

The important point to takeaway: Our columns' type classes are what we expect given their data. This isn't always the case.

If we change just one of the values in `decimalLatitude` to a "degrees minutes seconds" format, R will change the entire column's class to `character` to prevent any loss of data.


```{r}
# duplicate data
frogs_class <- frogs

# check class
class(frogs_class$decimalLatitude)

# change one of the values to a degrees minutes seconds format
frogs_class$decimalLatitude[5] <- "40Â° 51' 59 N"

# check class
class(frogs_class$decimalLatitude)
```

A simple typo in the raw data or spreadsheet you load into R could be all it takes to change the type class of an entire column. Be sure to keep your eyes out for strange column classes!

## Column names

There are many reasons why you might need to change the name of one or more columns in a dataset. Let's look at a few of the more common tasks when cleaning ecological data.

### Make column names consistent

Column names should use consistent naming conventions. Common naming formats include "snake case" and "camel case". These naming formats are popular because they are readable and easy to work with in code.

**Camel case** uses a lowercase first letter, then capitalises every word after.

```{r}
#| echo: false
c("scientificName", "dataResourceName", "eventDate")
```

**Snake case** uses entirely lowercase names, separating words using an underscore (`_`).

```{r}
#| echo: false
c("scientific_name", "data_resource_name", "event_date")
```

Data downloaded from the ALA uses camel case[^column-names-and-classes-1].

[^column-names-and-classes-1]: This is because queries to the ALA use other coding languages, namely `solr` and `JSON`, and the column names in these languages are typically written in camel case. To maintain consistency with what's on the ALA and to avoid hidden name cleaning, galah chooses to return camel case names, too.

```{r}
colnames(frogs)
```

However, R is case sensitive. If two names have exactly the same letters but different capitalisation, R considers them different names entirely. To help avoid mistakes caused by capitalisation, **it is more popular to use snake case in R. This is also the column name convention we recommend**.

One of the most useful column name cleaning functions is `clean_names()` from the janitor package. This function can read in any column names and convert them to snake case if possible.

```{r}
#| warning: false
#| message: false
library(janitor)

frogs_clean <- frogs |>
  clean_names() |>
  colnames()
frogs_clean
```

### Rename columns

Renaming columns is a frequent data cleaning task. Column names might need renaming to make it clearer what data they contain, or to make a name consistent with another dataset prior to merging their contents together.

There are several ways to rename columns in R.

::: {.panel-tabset .nav-pills}
#### `rename()`

`rename()` (from dplyr) provides an easy way to rename one or more columns.

```{r}
frogs |>
  select(decimalLatitude, decimalLongitude) |>
  rename(latitude = decimalLatitude,
         longitude = decimalLongitude)
```

`rename_with()` is a more powerful verion of `rename()`. It allows more advanced renaming by using functions to rename matching columns.

```{r}
frogs |>
  rename_with(toupper, starts_with("decimal"))

frogs |>
  rename_with( ~ tolower(gsub("decimal", "new_", .x, fixed = TRUE)))
```

#### `names()` + `<-`

Index a specific column name in base R with the help of `names()`. Assign a new column name to replace an old column name using the assign operator `<-`.

```{r}
names(frogs)[names(frogs) == "decimalLatitude"] <- "latitude"
names(frogs)[names(frogs) == "decimalLongitude"] <- "longitude"

frogs[,c("latitude", "longitude")]
```

```{r}
#| echo: false
names(frogs)[names(frogs) == "latitude"] <- "decimaLatitude"
names(frogs)[names(frogs) == "longitude"] <- "decimalLongitude"
```

:::

### Separate columns

Sometimes it is useful to split information in one column into several columns. One good example is if genus and species names are held within one column like `scientificName`. Let's separate these names into two columns using `separate()` from the tidyr package.

```{r}
#| warning: false
#| message: false
library(tidyr)

frogs_separate <- frogs |>
  separate(scientificName, 
           c("genus", "species"), # new column names
           fill = "right",        # fill missing values in right column
           remove = FALSE         # keep input column
           ) |> 
  select(scientificName, genus, species)
frogs_separate
```

### Join columns

Alternatively, it is useful to join information in multiple columns. One good example is to create label names when genus and species names are in separate columns. Let's rejoin the `genus` and `species` columns we created in the previous section using `unite()` from the tidyr package.

```{r}
frogs_separate |>
  unite("single_name", 
        genus:species, # select columns to join
        sep = " ",     # separate with a space
        na.rm = TRUE,  # remove NA values
        remove = FALSE # keep input column
        ) |>
  select(genus, species, single_name)
```

## Summary

In this chapter, we provided some ways to check the data types/classes of your data set's columns, and showed how to rename or edit columns.

In the next chapter we will learn to xxx...

---
editor: 
  markdown: 
    wrap: 72
code-annotations: hover
number-depth: 3
---

# Strings

When data are recorded (whether in a field survey or on a computer), text (or **strings**) can be formatted in *many* different ways in a column. Tiny differences between text like capitalisations, extra spaces, quotations, apostrophes and other symbols can all affect a data set. Each of these differences can be the difference between a data point being grouped, merged, filtered or analysed correctly...or not.

This chapter will provide many common tools that exist in R to clean strings. We will provide examples of how to use each tool, hopefully providing a useful list of tasks and functions to use when cleaning your data set.

### Prerequisites

In this chapter, we will use tree kangaroo occurrence data.

```{r}
#| warning: false
#| message: false
# WORMS dataset
worms <- read.csv("../data/worms/worms.csv")
# AFD dataset
afd <- read.csv("../data/naming/afd.csv")
# Inverts
inverts <- arrow::open_dataset("../data/galah/inverts") |> dplyr::collect()
# Plants
plants <- arrow::open_dataset("../data/dap/plants_subset") |> dplyr::collect()
```

```{r}
#| warning: false
#| message: false
#| echo: false
# packages
library(galah)
library(dplyr)
galah_config(email = Sys.getenv("ALA_EMAIL"),
             verbose = FALSE)
tree_kangaroo <- galah_call() |>
  galah_identify("Dendrolagus") |>
  atlas_occurrences()
```

```{r}
#| eval: false
# packages
library(galah)
library(dplyr)

# data: tree kangaroo records
galah_config(email = "your-email-here")

tree_kangaroo <- galah_call() |>
  galah_identify("Dendrolagus") |>
  atlas_occurrences()
```

:::{.aside}

<img class = "rounded" src="https://ala-images.s3.ap-southeast-2.amazonaws.com/store/2/d/7/e/1f21b7e5-1cc7-45a0-8f83-d8e5dd51e7d2/original"></img>

::: {.figure-caption}
[*Dendrolagus lumholtzi* sitting on a branch.<br>Photo by matthewkwan  CC-BY](https://biocache.ala.org.au/occurrences/290bcdef-d02a-49fe-b96b-96865527f02f)
:::
:::

## Basic string manipulation

The `stringr` package provides a number of useful functions for manipulating
strings, many of which are useful when dealing with biodiversity data. 

```{r}
#| warning: false
#| message: false
library(stringr)
```

#### Trim

```{r}
str_trim("  Genus specificus  ")
str_trim("  Genus specificus  ", side = "left")
```

#### Squish

```{r}
str_squish("  Genus   specificus  ")
```

#### Truncate

```{r}
str_trunc("Genus specificus", width = 10, side = "right")
```

#### Split

```{r}
str_split("Genus specificus", " ")
```

#### Link together

```{r}
str_c("Genus", "specificus", sep = "_") # <1>
```
1. `c()` stands for "concatenate" which means "to link together in a chain".

## Matching

Matching strings is a common task when working with biodiversity data. etc etc.

### Basic matching

The `stringr` package provides a number of functions for matching strings using
patterns.

```{r}
# detect and remove
str_detect("Genus specificus", "Genus")
str_remove("Genus specificus", pattern = "Genus ")

# locate and subset
records <- c("Genus", "species", "Genus species", "Difgenus difspecies")
str_locate(records, "Genus")
str_subset(records, "Genus")
```

### Regex matching

The examples above demonstrate the use of basic patterns. But for cases that
need more specific or advanced matching we can use **regular expressions (regex)**.

Regex is a powerful tool used to match patterns, replace characters, and extract text from strings. Regex can be complex and
unintuitive, but there are websites available, such as [Regex
Generator](https://regex-generator.olafneumann.org/), that are extremely
helpful. Here we explore a few basic examples, and keep in mind that these
methods can be applied to both column name strings and column values. In the
case of column names, regex can be useful when conforming datasets (see
[Integration]("./access_integration.qmd")) or to meet a stylistic requirement.
Applied to column values, there is a range of utility, such as unifying the
formatting of taxonomic or location names. 

The `str_view()` function is particularly useful for exploring regular
expressions to see pattern matches. The results are shown in the console, and
elements matched by the regex are surrounded with angle brackets < >. 

```{r}
# Match the first word in the string (the genus)
str_view(tree_kangaroo$scientificName, "^[A-Z][a-z]+")
# Match only the second word (species name)
str_view(tree_kangaroo$scientificName, "(?<=\\s)[a-z]+")
```

### Replacements

In base R the `gsub()` function can be used for pattern replacement. In
`stringr`, the `str_replace()` function can be used to replace the first match
of a string. The `str_replace_all()` function can be used to replace all
matches. 

```{r}
# str_replace() example
```

Base example:

```{r}
tree_kangaroo$scientificName <- gsub(
  pattern = "Dendrolagus",
  replacement = "Newname",
  x = tree_kangaroo$scientificName
)
```

## Case style

Case style can vary across data providers due to variable naming conventions. There are some basic functions available to change the case of strings in `stringr`:

```{r}
str_to_lower(plants$scientific_name[1])
str_to_upper(plants$scientific_name[1])
str_to_title(plants$scientific_name[1])
```

In some cases a more specific detection and replacement is required. For
example, the World Register of Marine Species (WoRMS) uses a combination of
lower case (scientific_name) and camel case (isExtinct). However, the Australian
Fauna Directory (AFD) uses screaming snake case e.g. SCIENTIFIC_NAME. To work
with both, case differences can be conformed to a single style, but the format
you choose is a matter of personal preference. 

<!-- Andrew: This does the same as the original chunk but like 1/4 the size -->
```{r}
worms_small <- head(worms)

# gsub is a base R function for replacing strings
colnames(worms_small) <- sapply(colnames(worms_small), function(name) {
  name <- tolower(gsub("([a-z])([A-Z])", "\\1_\\2", name))
  gsub("^_", "", name)
})

# stringr version of above (with a slightly different regex approach)
colnames(worms_small) <- sapply(colnames(worms_small), function(name) {
  str_to_lower(str_replace_all(name, "(?<=\\p{Ll})(\\p{Lu})", "_\\1"))
})
```




## Taxonomy

```{r loaddata}
#| warning: false
#| message: false
library(arrow)
library(tidyverse)
library(janitor)

bees <- read_parquet("../data/dap/bees.parquet")

plants <- open_dataset("../data/dap/plants_subset",
  format = "parquet"
) |> collect()

### Making some fake missing data for inverts in Class column
inverts <- open_dataset("../data/dap/inverts_subset") |> collect()

set.seed(5)
tobemissing <- inverts |>
  filter(class == "arachnida") |>
  sample_frac(0.3) |>
  pull(scientific_name) |>
  unique()

inverts <- inverts |>
  mutate(class = ifelse(scientific_name %in% tobemissing, NA, class))
```

Advances in taxonomy, especially in molecular biology has allowed researchers to describe new species more efficiently than ever before [@garraffoni2019integrative]. Modern approaches has also enabled reclassification of organisms that have been incorrectly described in the past. Unfortunately, multiple names (synonyms) for the same organism can arise when taxonomy is not unanimously agreed upon by researchers.

Harmonising taxonomic names is a prevalent and complex issue and so far, no unifying solution has been put forward --- making research with biodiversity data challenging. A potential solution would require pulling together domain knowledge from experts and compiling a database for where taxonomic history for describe species is traceable and linked with published literature.

While there is no perfect solution, some tips, tricks and tools do exist. In this chapter we will go through some of these to clean taxonomic data and deal with synonyms.

### Capitalisation

Normally higher taxonomy are capitalised e.g. Myrtaceae or Aves. Capitalisation errors are usually quick to spot when you print the data object. Alternatively you can try using `str_subset` on columns you expect to have capital letters.

The code below subsets out unique values for the variable `class` that have upper case letters. Notice that no matches are found

```{r}
library(tidyverse)

str_subset(unique(bees$class), "[:upper:]")
```

We can confirm that there are no upper case matches by subsetting unique values that have lower case letters to see what is going on. This shows us that Insecta is inputted entirely in lowercase.

```{r}
str_subset(unique(bees$class), "[:lower:]")
```

We can correct the lower case formatting as below, remember to check the fix before overwriting/removing the erroneous column(s)

```{r}
bees |>
  mutate(class_corrected = str_to_sentence(class)) |>
  select(starts_with("class"))

bees_corrected <- bees |>
  mutate(class_corrected = str_to_sentence(class)) |>
  select(-class) |> # Remove erroreous column
  rename(class = class_corrected) # Rename corrected column as the new 'class'
```

### Seperators

In a taxonomic data, separators such as, spaces and underscore are found in scientific names and are used to delineate the genus and [species name](https://dwc.tdwg.org/terms/#dwc:specificEpithet). While it is personal choice which separator you use, it is good practice to be consistent with your choice. Consistency ensures that unique values of scientific name truly reflects unique species and not due to inconsistencies.

Try `tabyl-ing` your taxonomic columns to check if you have any inconsistencies first

```{r}
library(janitor)

plants |>
  pull(scientific_name) |>
  tabyl() |>
  tibble()
```

Consistent taxonomic formatting may not be an issue if you are downloading data from one single source such as the ALA where scientific names are already formatted consistently e.g. "Moloch horridus". This may not be the case when consolidating data from multiple sources.

Below is code to create an underscore scientific name from one that is separated with a space. Remember to check your changes

```{r}
plants_updated <- plants |>
  mutate(scientific_name_undersc = str_replace_all(scientific_name, " ", "_"))

plants_updated |>
  pull(scientific_name_undersc) |>
  tabyl() |>
  tibble()
```



---

*Dax's note*

I think we can delete the case study below for brevity. I've left it in case it generates any additional ideas for the chapter.



## Simple case study

We will use the `janitor` R package to explore whether our elephant data has any
string issues. The function `tabyl` will compute a counts and percent of total
rows for each unique value.

```{r, eval = TRUE}
library(dplyr)
library(janitor)
african_ele <- arrow::read_parquet("../data/gbif/elephant")
african_ele |>
  pull(stateProvince) |>
  tabyl() |>
  tibble() |>
  print(n = 20)
```

From the `tabyl` output, we can see there are few different variations of
`Province`, `Prov.`, `Prov`. As an example, we will correct these with the
`tidyverse` packages `stringr`, `dplyr`, `tidyr` as well as `glue`.

```{r, eval = TRUE, echo = TRUE}
library(glue)
# Create a regular expression to match Prov. and Prov
pattern <- regex("Prov(?![:lower:])")
# Use `str_subset` to pull out the cases that match our pattern
# Confirm that these are the problematic ones
# Assign these into an object
str_subset(african_ele$stateProvince, pattern = pattern)
typos_provinces <- str_subset(african_ele$stateProvince, pattern = pattern)

# Create a new variable `stateProvince_clean`
# `str_detect` for matches of pattern (returns TRUE for match)
# `if_else`: if TRUE, the `glue` function will take the first part of the province name enclosed in and join it with word Province.
# if FALSE , it will just take the corresponding value in stateProvince
# Note that we are assigning these changes to a new object (`african_ele_2`)
african_ele_2 <- african_ele %>%
  mutate(stateProvince_clean = if_else(str_detect(stateProvince, pattern = pattern),
    true = glue('{word(stateProvince, sep = " P")} Province'),
    false = stateProvince
  ))

# Once we've made the correction we want to check we've done it correctly.
# ALWAYS CHECK YOUR CORRECTIONS
# Use the `select` function to isolate columns that `starts_with` "stateProvince"
# Use the `filter` function to subset our the problematic provinces
african_ele_2 %>%
  select(starts_with("stateProvince")) %>%
  filter(stateProvince %in% typos_provinces)

# Its good practice to check the other values were not affected by your corrections
# Here we are removing the NA with `drop_na` and subsetting unique rows with `distinct`
african_ele_2 %>%
  select(starts_with("stateProvince")) %>%
  tidyr::drop_na() %>%
  distinct()

# Final check
# Check with the original code that detected the issue
african_ele_2 %>%
  pull(stateProvince_clean) %>%
  tabyl() %>%
  tibble() %>%
  print(n = 20)
```

There are some other issues that can be corrected in a similar approach:

-   `North West`, `North West District` and `North-Western`
-   `Àfrica Central`, `Central Province` and `Central`
-   `Atacora` and `Atakora`
-   `Coastal Province` and `Coastal`

We recommend consulting reputable sources to delineate and consolidate
similar values.


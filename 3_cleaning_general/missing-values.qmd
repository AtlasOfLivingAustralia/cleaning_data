---
editor_options: 
  chunk_output_type: console
---

# Missing values

## Missing values

```{r}
library(skimr)
iris %>%
  skim() %>%
  dplyr::filter(n_missing > 0)
```

## Missing coordinates

If your research question requires spatial information, then it may be useful to
exclude records that are missing coordinates data. Many spatial analytical tools
are not compatible with missing coordinate data. We recommend tallying and
identifying the rows that have missing data before excluding. 

You can use `drop_na()` to remove missing values from your dataset.

```{r, eval=FALSE}
library(galah)
banksia_serrata <- galah_call() |> 
  galah_identify("banksia_serrata") |> 
  galah_filter(year > 2022) |>  
  atlas_occurrences()

library(dplyr)

# Identify missing data in coordinates
banksia_serrata |> 
  filter(is.na(decimalLatitude) | is.na (decimalLongitude))

# Excluding them
banksia_serrata |> 
  tidyr::drop_na(decimalLatitude, decimalLongitude)
```

#### Missing higher taxonomy {.unnumbered}

If you noticed you have missing data in these columns, you can usually back fill this information using your [chosen naming authority](link%20back%20to%20section) or retrieving this information from a living atlas such as the ALA.

The code below demonstrates how you can isolate the `scientific_names` of taxa with missing data and searching for taxonomic information from ALA

<!-- (Example WORK IN PROGRESS, need better fake data, Inverts?) -->

<!-- Seperate chunk where message = TRUE for hits -->

```{r loaddata}
#| warning: false
#| message: false
library(arrow)
library(tidyverse)
library(janitor)

bees <- read_parquet("../data/dap/bees.parquet")

plants <- open_dataset("../data/dap/plants_subset",
  format = "parquet"
) |> collect()

### Making some fake missing data for inverts in Class column
inverts <- open_dataset("../data/dap/inverts_subset") |> collect()

set.seed(5)
tobemissing <- inverts |>
  filter(class == "arachnida") |>
  sample_frac(0.3) |>
  pull(scientific_name) |>
  unique()

inverts <- inverts |>
  mutate(class = ifelse(scientific_name %in% tobemissing, NA, class))
```


```{r}
library(galah)

# Configure galah to point to Australia node
galah_config(
  atlas = "Australia",
  email = Sys.getenv("ALA_EMAIL")
)

# These are the taxa missing `class` information
to_search <- inverts |>
  filter(is.na(class)) |>
  select(scientific_name) |>
  distinct()

# Reformat scientific_name to scientificName as the latter is the ALA format
backfilled_taxa <- to_search |>
  rename(scientificName = scientific_name) |>
  search_taxa(to_search) |>
  tibble()

backfilled_taxa
```

#### Insufficient taxonomic rank {.unnumbered}

If a record is not identified down to the taxonomic level that needed for the study e.g. species, then the record should be removed.

During your data download, ensure you have requested for the column [`taxonRank`](https://dwc.tdwg.org/terms/#dwc:taxonRank), this variable tells us the lowest level of `scientificName`.

```{r, eval=FALSE}
library(galah)

galah_config(
  email = Sys.getenv("ALA_EMAIL"),
  atlas = "Australia"
)

honeyeaters <- galah_call() |>
  galah_identify("Meliphagidae") |>
  galah_filter(year == 2012 & stateProvince == "New South Wales") |>
  galah_select(group = "basic", taxonRank) |>
  atlas_occurrences()

honeyeaters$taxonRank |> unique()

honeyeaters |> filter(taxonRank == "species")
```

```{r}
library(arrow)
library(dplyr)

# honeyeaters <- galah_call() |>
#   galah_identify("Meliphagidae") |>
#   galah_filter(year == 2012 & stateProvince == "New South Wales") |>
#   galah_select(group = "basic", taxonRank) |>
#   atlas_occurrences()

# write_parquet(honeyeaters, "data/galah/honeyeater")

honeyeaters <- open_dataset("../data/galah/honeyeater") |> collect()

honeyeaters$taxonRank |> unique()

honeyeaters |> filter(taxonRank == "species")
```

#### Inconsistent higher taxonomy {.unnumbered}

A great approach to detect inconsistencies in your taxonomic data is to compute counts for each level of taxonomic rank. These counts act as a check for you to verify that the data is in line with your expectation. This is particularly important when combining data from different sources where their taxonomy might vary. If you have detected inconsistencies as we have done below, you will have to correct accordingly, either by consulting a taxonomic expert or a naming authority and ensure this is reported in your methods.

```{r}
# Get counts for every species where they have more than 1 class
plants |>
  select(phylum:species, scientific_name) |>
  distinct() |>
  group_by(species) |>
  summarise(n_class = length(unique(class))) |>
  filter(n_class > 1)

# Get the species that have more than 1 class
inconsistent_taxa <- plants |>
  select(phylum:species, scientific_name) |>
  distinct() |>
  group_by(species) |>
  summarise(n_class = length(unique(class))) |>
  filter(n_class > 1) |>
  pull(species)

# Filter species that have more than 1 class
plants |>
  filter(species %in% inconsistent_taxa) |>
  select(phylum:species, scientific_name) |>
  arrange(species) |>
  distinct()
```